<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session cc070d4d-94d0-44dc-b997-c8973b3e95e6 (2025-12-28 09:16Z) -->

# 角色受击朝向 (2025-12-28 09:16Z)

_**User (2025-12-28 03:48Z)**_

角色受击时，模型朝向应该面向受击方向，而不是顺着，检查并修复

---

_**Agent (model claude-4.5-opus-high-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
用户说角色受击时，模型朝向应该面向受击方向，而不是顺着。这意味着当角色被击中时，角色应该转向攻击来源的方向（面对攻击者），而不是背对攻击者。

我需要先了解项目中受击相关的代码是如何处理的。让我先阅读 QUICK_START.md 来了解项目结构，然后搜索受击相关的代码。

根据用户最近查看的文件，可以看到：
- KnockbackComponent.ViewRead.cs - 击退组件的视图读取
- PredictedMovementViewComponent.cs - 预测移动视图组件
- SkillDisplacementCapability.cs - 技能位移能力
- CollisionDebugViewComponent.cs - 碰撞调试视图组件

这些文件可能与受击方向有关。让我先阅读 QUICK_START.md，然后检查这些相关文件。</details></think>

---

我来先了解项目结构，然后检查受击方向相关的代码。

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\QUICK_START.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\Components\KnockbackComponent.ViewRead.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<think><details><summary>Thought Process</summary>
搜索结果为空，让我用 grep 搜索击退相关的代码，特别是视图层如何处理击退时的方向。</details></think>

---

让我继续搜索击退视图组件和受击处理的代码：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "knockback|击退|受击" in "D:\Develop\Projects\Astrum\AstrumProj\Assets\Script" • 360 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 受击反应能力 - 处理实体受到技能效果的反馈` | L15 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 优先级：200（低于技能执行，高于击退）` | L16 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 受击反馈事件处理（由效果处理器发送）` | L69 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// 1. 播放受击动作` | L77 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// 2. 播放受击特效` | L84 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// ====== 受击表现方法 ======` | L97 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击动作` | L100 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击特效` | L140 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击特效（通过 ViewEvent 传递到视图层）` | L143 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug("[HitReactionCapability] 未配置受击特效路径，跳过");` | L149 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Warning("[HitReactionCapability] 实体为空，无法播放受击特效");` | L155 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 队列受击特效事件: entity=\{entity.UniqueId\}, path=\{evt.VisualEffectPath\}");` | L184 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 处理受击音效` | L188 |
| `.\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 受击音效占位: \{evt.SoundEffectPath\}");` | L198 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 静态构造函数：全局注册击退事件处理器` | L23 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 全局注册击退开始事件` | L27 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `typeof(KnockbackStartEvent),` | L29 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 全局注册击退结束事件` | L33 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `typeof(KnockbackEndEvent),` | L35 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] 全局注册击退事件处理器");` | L39 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退相关缓存状态` | L80 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private KnockbackType _knockbackTypeCached;` | L82 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退开始时的视觉位置（表现层自己的当前位置）` | L83 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private Vector3 _knockbackStartPosVisual;` | L84 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退目标落点位置（逻辑层提供的预计算落点）` | L85 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private Vector3 _knockbackTargetPosVisual;` | L86 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 是否刚开始击退（用于初始化起点和落点）` | L87 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private bool _knockbackJustStarted;` | L88 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `return new[] \{ MovementComponent.ComponentTypeId, KnockbackComponent.ComponentTypeId \};` | L101 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `else if (componentTypeId == KnockbackComponent.ComponentTypeId)` | L117 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (!KnockbackComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var knockbackRead) \|\| !knockbackRead.IsValid)` | L119 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 检测击退开始` | L122 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_isKnockingBackCached = knockbackRead.IsKnockingBack;` | L124 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退刚开始，标记需要初始化起点和落点` | L128 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackJustStarted = true;` | L129 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] Entity \{OwnerEntity.UniqueId\} knockback started, " +` | L130 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"TargetPosition from logic=(\{knockbackRead.TargetPosition.x.AsFloat():F2\}, \{knockbackRead.TargetPosition.y.AsFloat():F2\}, \{knockbackRead.TargetPosition.z.AsFloat():F2\}), " +` | L131 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"StartPosition from logic=(\{knockbackRead.StartPosition.x.AsFloat():F2\}, \{knockbackRead.StartPosition.y.AsFloat():F2\}, \{knockbackRead.StartPosition.z.AsFloat():F2\}), " +` | L132 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"TotalTime=\{knockbackRead.TotalTime.AsFloat():F2\}, Type=\{knockbackRead.Type\}");` | L133 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 更新击退缓存数据` | L136 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTypeCached = knockbackRead.Type;` | L137 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 注册击退 View Event 处理器` | L284 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 轮询击退组件状态` | L416 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (KnockbackComponent.TryGetViewRead(entity.World, entity.UniqueId, out var knockbackRead) && knockbackRead.IsValid)` | L417 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_isKnockingBackCached = knockbackRead.IsKnockingBack;` | L420 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退刚开始，标记需要初始化起点和落点` | L424 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackJustStarted = true;` | L425 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTypeCached = knockbackRead.Type;` | L428 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 处理被动位移模式（击退等）` | L496 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 从 ViewRead 获取击退数据` | L504 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (!KnockbackComponent.TryGetViewRead(entity.World, entity.UniqueId, out var knockbackRead) \|\| !knockbackRead.IsValid)` | L505 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 没有击退数据，回退到普通移动` | L507 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (!knockbackRead.IsKnockingBack)` | L512 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退已结束，回退到普通移动` | L514 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] Entity \{entity.UniqueId\} knockback ended, " +` | L517 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 更新类型缓存（用于 ApplyKnockbackCurve）` | L525 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTypeCached = knockbackRead.Type;` | L526 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退刚开始时，初始化缓存` | L528 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (_knockbackJustStarted)` | L529 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackStartPosVisual = ToVector3(knockbackRead.StartPosition);` | L532 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTargetPosVisual = ToVector3(knockbackRead.TargetPosition);` | L533 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if ((_posVisual - _knockbackStartPosVisual).magnitude > 1f)` | L536 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_posVisual = _knockbackStartPosVisual;` | L538 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] Entity \{entity.UniqueId\} knockback initialized in view layer: " +` | L541 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"VisualStartPos=(\{_knockbackStartPosVisual.x:F2\}, \{_knockbackStartPosVisual.y:F2\}, \{_knockbackStartPosVisual.z:F2\}), " +` | L542 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"VisualTargetPos=(\{_knockbackTargetPosVisual.x:F2\}, \{_knockbackTargetPosVisual.y:F2\}, \{_knockbackTargetPosVisual.z:F2\}), " +` | L543 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackJustStarted = false;` | L546 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退时，逻辑层已经在每帧更新位置，表现层只需要平滑跟随即可` | L550 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 对于击退，使用较快的平滑速度，减少延迟感` | L554 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 根据击退类型应用插值曲线` | L581 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// <param name="type">击退类型</param>` | L584 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private float ApplyKnockbackCurve(float t, KnockbackType type)` | L586 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `case KnockbackType.Linear:` | L590 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `case KnockbackType.Decelerate:` | L594 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `case KnockbackType.Launch:` | L598 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `RegisterViewEventHandler<KnockbackStartEvent>(OnKnockbackStart);` | L731 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `RegisterViewEventHandler<KnockbackEndEvent>(OnKnockbackEnd);` | L732 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 处理击退开始事件` | L736 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private void OnKnockbackStart(KnockbackStartEvent evt)` | L738 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] Knockback start event received: " +` | L740 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 初始化击退状态` | L744 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackJustStarted = true;` | L745 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTypeCached = evt.Type;` | L747 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 使用事件数据初始化击退参数` | L749 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackStartPosVisual = ToVector3(evt.StartPosition);` | L750 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackTargetPosVisual = ToVector3(evt.TargetPosition);` | L751 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `if ((_posVisual - _knockbackStartPosVisual).magnitude > 1f)` | L754 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_posVisual = _knockbackStartPosVisual;` | L756 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Debug($"[PredictedMovementViewComponent] Knockback initialized from ViewEvent: " +` | L759 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"VisualStartPos=(\{_knockbackStartPosVisual.x:F2\}, \{_knockbackStartPosVisual.y:F2\}, \{_knockbackStartPosVisual.z:F2\}), " +` | L760 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `$"VisualTargetPos=(\{_knockbackTargetPosVisual.x:F2\}, \{_knockbackTargetPosVisual.y:F2\}, \{_knockbackTargetPosVisual.z:F2\})");` | L761 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 处理击退结束事件` | L765 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `private void OnKnockbackEnd(KnockbackEndEvent evt)` | L767 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `ASLogger.Instance.Info($"[PredictedMovementViewComponent] Knockback end event received: " +` | L769 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 重置击退状态` | L773 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `_knockbackJustStarted = false;` | L775 |
| `.\AstrumView\Components\PredictedMovementViewComponent.cs` | `// 击退结束时，总是将角色位置快速拉到落地点` | L777 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退开始事件数据` | L95 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 用于在视图层处理击退动画和特效的开始` | L96 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `public struct KnockbackStartEvent` | L98 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退类型` | L101 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `public KnockbackType Type;` | L103 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退方向（世界空间，单位向量）` | L106 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退距离（米）` | L111 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退持续时间（秒）` | L116 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退起始位置` | L121 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退目标位置` | L126 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 击退结束事件数据` | L137 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `/// 用于在视图层处理击退动画和特效的结束` | L138 |
| `.\AstrumLogic\Events\ViewEvents.cs` | `public struct KnockbackEndEvent` | L140 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `/// 击退能力 - 处理实体的击退位移` | L12 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `/// 优先级：150（高于移动，低于受击反应）` | L13 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `public class KnockbackCapability : Capability<KnockbackCapability>` | L15 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `/// 用于标识是击退系统禁用用户输入位移的 instigatorId` | L29 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `private long _knockbackInstigatorId;` | L31 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `RegisterEventHandler<KnockbackEvent>(OnKnockback);` | L40 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `/// 接收击退事件，写入组件数据` | L46 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `private void OnKnockback(Entity entity, KnockbackEvent evt)` | L48 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `ASLogger.Instance.Debug($"[KnockbackCapability] OnKnockback called for entity \{entity.UniqueId\}, " +` | L50 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 获取或添加击退组件` | L53 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockback = GetComponent<KnockbackComponent>(entity);` | L54 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `if (knockback == null)` | L55 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback = new KnockbackComponent();` | L57 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `entity.AddComponent(knockback);` | L58 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `ASLogger.Instance.Debug($"[KnockbackCapability] Created KnockbackComponent for entity \{entity.UniqueId\}");` | L59 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 写入击退数据（修改自身组件）` | L67 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.IsKnockingBack = true;` | L68 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.Direction = evt.Direction;` | L69 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.TotalDistance = evt.Distance;` | L70 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.RemainingTime = evt.Duration;` | L71 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.Speed = evt.Distance / evt.Duration;` | L72 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.MovedDistance = FP.Zero;` | L73 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.Type = evt.Type;` | L74 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.CasterId = evt.CasterId;` | L75 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.StartPosition = startPosition;` | L76 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.TargetPosition = targetPosition;` | L77 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 输出击退起始位置和落点位置日志` | L79 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `ASLogger.Instance.Debug($"[KnockbackCapability] Entity \{entity.UniqueId\} knockback positions: " +` | L80 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 标记 KnockbackComponent 为脏，确保 ViewRead 同步更新` | L86 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `entity.MarkComponentDirty(KnockbackComponent.ComponentTypeId);` | L87 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 发布击退开始 View Event` | L89 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockbackStartEvent = new KnockbackStartEvent` | L90 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockbackStartEvent,` | L103 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `ASLogger.Instance.Debug($"[KnockbackCapability] Knockback started: speed=\{knockback.Speed\}m/s, direction=\{evt.Direction\}, queued ViewEvent");` | L107 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 只在开始击退时激活` | L114 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockback = GetComponent<KnockbackComponent>(entity);` | L115 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback != null &&` | L117 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.IsKnockingBack &&` | L118 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 击退结束时停用` | L124 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockback = GetComponent<KnockbackComponent>(entity);` | L125 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback == null \|\|` | L127 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `!knockback.IsKnockingBack \|\|` | L128 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 获取击退施法者ID作为标识` | L136 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockback = GetComponent<KnockbackComponent>(entity);` | L137 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `_knockbackInstigatorId = knockback?.CasterId ?? entity.UniqueId;` | L138 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `_knockbackInstigatorId,` | L144 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `"Knockback active"` | L145 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `//ASLogger.Instance.Debug($"[KnockbackCapability] Activated for entity \{entity.UniqueId\}");` | L156 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `_knockbackInstigatorId` | L165 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `//ASLogger.Instance.Debug($"[KnockbackCapability] Deactivated for entity \{entity.UniqueId\}");` | L176 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `var knockback = GetComponent<KnockbackComponent>(entity);` | L185 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `if (knockback == null \|\| !knockback.IsKnockingBack)` | L186 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `FP moveDistance = CalculateMoveDistance(knockback, deltaTime);` | L195 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `TSVector movement = knockback.Direction * moveDistance;` | L198 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.MovedDistance += moveDistance;` | L200 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `knockback.RemainingTime -= deltaTime;` | L201 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `// 标记 KnockbackComponent 为脏，确保 ViewRead 同步更新（数据每帧都在变化）` | L206 |
| `.\AstrumLogic\Capabilities\KnockbackCapability.cs` | `entity.MarkComponentDirty(KnockbackComponent.ComponentTypeId);` | L207 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
我看到了受击反应能力 `HitReactionCapability.cs`，其中有一个 `UpdateFacingDirection` 方法。让我进一步查看这个方法的实现，以及相关的受击方向处理逻辑。</details></think>

---

让我查看 `HitReactionCapability.cs` 中的 `UpdateFacingDirection` 方法以及受击方向处理的完整逻辑：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\Capabilities\HitReactionCapability.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "facing|朝向|Direction|HitReaction" in "D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\Capabilities" • 88 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\HitReactionCapability.cs` | `public class HitReactionCapability : Capability<HitReactionCapability>` | L18 |
| `.\HitReactionCapability.cs` | `private const string HitReactionExternalActionSource = "HitReaction";` | L31 |
| `.\HitReactionCapability.cs` | `RegisterEventHandler<HitReactionEvent>(OnHitReaction);` | L63 |
| `.\HitReactionCapability.cs` | `private void OnHitReaction(Entity entity, HitReactionEvent evt)` | L71 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] OnHitReaction called for entity \{entity.UniqueId\}, " +` | L73 |
| `.\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.PlayHitAction"))` | L79 |
| `.\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.PlayHitVFX"))` | L85 |
| `.\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.HandleHitSound"))` | L91 |
| `.\HitReactionCapability.cs` | `private void PlayHitAction(Entity entity, HitReactionEvent evt)` | L102 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug("[HitReactionCapability] ActionComponent missing, skip hit action.");` | L106 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Warning($"[HitReactionCapability] Entity \{entity.UniqueId\} has no config, unable to resolve HitAction.");` | L113 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] Entity \{entity.UniqueId\} has no HitAction configured, skip action switch.");` | L119 |
| `.\HitReactionCapability.cs` | `UpdateFacingDirection(entity, evt);` | L123 |
| `.\HitReactionCapability.cs` | `SourceTag = HitReactionExternalActionSource,` | L132 |
| `.\HitReactionCapability.cs` | `private void PlayHitVFX(Entity entity, HitReactionEvent evt)` | L145 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug("[HitReactionCapability] 未配置受击特效路径，跳过");` | L149 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Warning("[HitReactionCapability] 实体为空，无法播放受击特效");` | L155 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 队列受击特效事件: entity=\{entity.UniqueId\}, path=\{evt.VisualEffectPath\}");` | L184 |
| `.\HitReactionCapability.cs` | `private void HandleHitSound(Entity entity, HitReactionEvent evt)` | L190 |
| `.\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 受击音效占位: \{evt.SoundEffectPath\}");` | L198 |
| `.\HitReactionCapability.cs` | `private void UpdateFacingDirection(Entity entity, HitReactionEvent evt)` | L201 |
| `.\HitReactionCapability.cs` | `var direction = evt.HitDirection;` | L209 |
| `.\HitReactionCapability.cs` | `if (direction.sqrMagnitude > FP.EN4)` | L211 |
| `.\HitReactionCapability.cs` | `direction = direction * (-FP.One);` | L213 |
| `.\HitReactionCapability.cs` | `direction = GetDirectionFromCaster(entity, trans, evt.CasterId);` | L217 |
| `.\HitReactionCapability.cs` | `direction.y = FP.Zero;` | L220 |
| `.\HitReactionCapability.cs` | `if (direction.sqrMagnitude <= FP.EN4)` | L222 |
| `.\HitReactionCapability.cs` | `direction = TSVector.Normalize(direction);` | L227 |
| `.\HitReactionCapability.cs` | `var rotation = TSQuaternion.LookRotation(direction, TSVector.up);` | L228 |
| `.\HitReactionCapability.cs` | `private TSVector GetDirectionFromCaster(Entity target, TransComponent targetTrans, long casterId)` | L232 |
| `.\HitReactionCapability.cs` | `var direction = casterTrans.Position - targetTrans.Position;` | L251 |
| `.\HitReactionCapability.cs` | `direction.y = FP.Zero;` | L252 |
| `.\HitReactionCapability.cs` | `return direction;` | L253 |
| `.\SkillDisplacementCapability.cs` | `// 技能位移时，角色朝向应该保持原始的释放方向，而不是跟随移动方向` | L191 |
| `.\SkillDisplacementCapability.cs` | `// 使用角色当前的朝向作为移动方向，确保技能位移时保持一致的视觉表现` | L192 |
| `.\SkillDisplacementCapability.cs` | `TSVector skillDirection = transComponent.Rotation * TSVector.forward;` | L193 |
| `.\SkillDisplacementCapability.cs` | `skillDirection = new TSVector(skillDirection.x, FP.Zero, skillDirection.z); // 确保 Y=0` | L194 |
| `.\SkillDisplacementCapability.cs` | `if (skillDirection.sqrMagnitude > FP.EN4)` | L195 |
| `.\SkillDisplacementCapability.cs` | `movementComponent.MoveDirection = skillDirection.normalized;` | L197 |
| `.\SkillDisplacementCapability.cs` | `// 如果角色朝向无效，fallback 到位移方向` | L201 |
| `.\SkillDisplacementCapability.cs` | `movementComponent.MoveDirection = worldDeltaPosition.normalized;` | L202 |
| `.\SkillDisplacementCapability.cs` | `// 标记 MovementComponent 为脏，确保 MoveDirection 的更新被导出到 ViewRead` | L205 |
| `.\SkillDisplacementCapability.cs` | `// 这是必要的，因为 MoveDirection 可能在类型不变时改变（例如连续翻滚方向改变）` | L206 |
| `.\SkillDisplacementCapability.cs` | `/// <param name="rotation">角色当前朝向（四元数）</param>` | L238 |
| `.\KnockbackCapability.cs` | `TSVector targetPosition = startPosition + evt.Direction * evt.Distance;` | L65 |
| `.\KnockbackCapability.cs` | `knockback.Direction = evt.Direction;` | L69 |
| `.\KnockbackCapability.cs` | `$"Direction=(\{evt.Direction.x.AsFloat():F2\}, \{evt.Direction.y.AsFloat():F2\}, \{evt.Direction.z.AsFloat():F2\}), " +` | L83 |
| `.\KnockbackCapability.cs` | `Direction = evt.Direction,` | L93 |
| `.\KnockbackCapability.cs` | `ASLogger.Instance.Debug($"[KnockbackCapability] Knockback started: speed=\{knockback.Speed\}m/s, direction=\{evt.Direction\}, queued ViewEvent");` | L107 |
| `.\KnockbackCapability.cs` | `TSVector movement = knockback.Direction * moveDistance;` | L198 |
| `.\KnockbackCapability.cs` | `// 记录“移动方向”（注意：不是角色朝向），以位移 delta 为准` | L216 |
| `.\KnockbackCapability.cs` | `movementComponent.MoveDirection = knockback.Direction.sqrMagnitude > FP.EN4` | L218 |
| `.\KnockbackCapability.cs` | `? knockback.Direction.normalized` | L219 |
| `.\KnockbackCapability.cs` | `// 标记 MovementComponent 为脏，确保 MoveDirection 的更新被导出到 ViewRead` | L222 |
| `.\SkillExecutorCapability.cs` | `private (TSVector Position, TSVector Direction) CalculateProjectileSpawnTransform(Entity caster, TriggerFrameInfo trigger)` | L438 |
| `.\SkillExecutorCapability.cs` | `var (spawnPosition, spawnDirection) = CalculateProjectileSpawnTransform(caster, trigger);` | L545 |
| `.\SkillExecutorCapability.cs` | `SpawnDirection = spawnDirection,` | L554 |
| `.\ProjectileCapability.cs` | `var dir = component.CurrentVelocity == TSVector.zero ? component.LaunchDirection : component.CurrentVelocity.normalized;` | L83 |
| `.\ProjectileCapability.cs` | `dir = data.Direction.normalized;` | L87 |
| `.\ProjectileCapability.cs` | `var launchDir = component.LaunchDirection == TSVector.zero ? data.Direction.normalized : component.LaunchDirection;` | L102 |
| `.\ProjectileCapability.cs` | `var currentDir = component.CurrentVelocity == TSVector.zero ? component.LaunchDirection : component.CurrentVelocity.normalized;` | L125 |
| `.\ProjectileCapability.cs` | `component.CurrentVelocity = (component.LaunchDirection == TSVector.zero ? TSVector.forward : component.LaunchDirection) * baseSpeed;` | L134 |
| `.\MovementCapability.cs` | `// 更新朝向` | L171 |
| `.\MovementCapability.cs` | `TSVector inputDirection = new TSVector(moveX, FP.Zero, moveY);` | L174 |
| `.\MovementCapability.cs` | `if (inputDirection.sqrMagnitude > FP.EN4)` | L175 |
| `.\MovementCapability.cs` | `transComponent.Rotation = TSQuaternion.LookRotation(inputDirection, TSVector.up);` | L177 |
| `.\MovementCapability.cs` | `// 记录“移动方向”（注意：不是角色朝向）` | L181 |
| `.\MovementCapability.cs` | `movementComponent.MoveDirection = inputDirection.normalized;` | L184 |
| `.\MovementCapability.cs` | `movementComponent.RecordMovement(currentFrame, transComponent.Position, movementComponent.MoveDirection);` | L250 |
| `.\ActionCapability.cs` | `TryUpdateFacingByCommand(entity, consumedCommand);` | L383 |
| `.\ActionCapability.cs` | `private void TryUpdateFacingByCommand(Entity entity, ActionCommand consumedCommand)` | L884 |
| `.\ActionCapability.cs` | `var direction = targetPos - currentPos;` | L902 |
| `.\ActionCapability.cs` | `direction.y = FP.Zero;` | L903 |
| `.\ActionCapability.cs` | `if (direction.sqrMagnitude <= FP.EN4)` | L905 |
| `.\ActionCapability.cs` | `direction = TSVector.Normalize(direction);` | L910 |
| `.\ActionCapability.cs` | `//     $"ActionCapability: Entity=\{entity.UniqueId\} Command=\{consumedCommand.CommandName\} Target=(\{targetX.AsFloat():F2\}, \{targetZ.AsFloat():F2\}) FacingDir=(\{direction.x.AsFloat():F2\}, \{direction.z.AsFloat():F2\})",` | L914 |
| `.\ActionCapability.cs` | `//     "Action.MouseFacing");` | L915 |
| `.\ActionCapability.cs` | `var rotation = TSQuaternion.LookRotation(direction, TSVector.up);` | L917 |
| `.\DamageCapability.cs` | `/// 优先级：200（与 HitReactionCapability 同级）` | L13 |
| `.\ProjectileSpawnCapability.cs` | `var spawnDirection = evt.SpawnDirection;` | L78 |
| `.\ProjectileSpawnCapability.cs` | `if (spawnDirection.magnitude <= FP.Epsilon)` | L79 |
| `.\ProjectileSpawnCapability.cs` | `spawnDirection = evt.TriggerInfo != null && caster.GetComponent<TransComponent>() != null` | L81 |
| `.\ProjectileSpawnCapability.cs` | `QueueProjectileEntity(world, definition, evt, effectIds, spawnDirection, caster);` | L92 |
| `.\ProjectileSpawnCapability.cs` | `private void QueueProjectileEntity(World world, ProjectileDefinition definition, ProjectileSpawnRequestEvent evt, IReadOnlyList<int> effectIds, TSVector normalizedDirection, Entity caster)` | L220 |
| `.\ProjectileSpawnCapability.cs` | `SpawnDirection = normalizedDirection,` | L228 |
| `.\ProjectileSpawnCapability.cs` | `InitializeProjectile(projectile, caster, definition, effectIds, evt.SpawnPosition, normalizedDirection, evt.SocketName, evt.SocketOffset);` | L249 |
| `.\ProjectileSpawnCapability.cs` | `private void InitializeProjectile(Entity projectile, Entity caster, ProjectileDefinition definition, IReadOnlyList<int> effectIds, TSVector spawnPosition, TSVector direction, string socketName, TSVector socketOffset)` | L253 |
| `.\ProjectileSpawnCapability.cs` | `projectileComponent.LaunchDirection = direction.normalized;` | L276 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
我发现了问题所在。在 `HitReactionCapability.cs` 的 `UpdateFacingDirection` 方法中：

```csharp
private void UpdateFacingDirection(Entity entity, HitReactionEvent evt)
{
    var trans = GetComponent<TransComponent>(entity);
    if (trans == null)
    {
        return;
    }

    var direction = evt.HitDirection;

    if (direction.sqrMagnitude > FP.EN4)
    {
        direction = direction * (-FP.One);  // 这里取反了！
    }
    else
    {
        direction = GetDirectionFromCaster(entity, trans, evt.CasterId);
    }

    direction.y = FP.Zero;

    if (direction.sqrMagnitude <= FP.EN4)
    {
        return;
    }

    direction = TSVector.Normalize(direction);
    var rotation = TSQuaternion.LookRotation(direction, TSVector.up);
    trans.SetRotation(rotation);
}
```

问题在于第 213 行的 `direction = direction * (-FP.One);`。这个代码是取反击退方向，如果击退方向是攻击者 -> 被击者的方向，取反后角色就会面向攻击者的反方向（背对攻击者），而不是面向攻击者。

但是，用户说"模型朝向应该面向受击方向"，这里有两种理解：
1. 面向攻击者（即正对攻击者）
2. 面向击退方向（即背对攻击者）

从游戏表现来看，受击时角色应该面向攻击者（正对攻击者），而不是背对攻击者。

我需要进一步分析 `HitDirection` 的具体含义。通过检查 `GetDirectionFromCaster` 方法，我注意到它计算的是从目标指向攻击者的方向。如果 `HitDirection` 具有相同的语义，那么当前的 `* (-FP.One)` 操作实际上会导致角色朝向错误。这意味着我们需要重新考虑方向处理逻辑，确保角色能够正确面向攻击者。

下一步是追踪 `HitDirection` 的具体设置过程。</details></think>

---

我找到了问题。在 `HitReactionCapability.cs` 第 213 行，`UpdateFacingDirection` 方法中对方向进行了取反：

```csharp
direction = direction * (-FP.One);
```

这意味着角色受击后朝向的是击退方向（背对攻击者），而不是面向攻击者。让我确认一下 `HitDirection` 的定义和设置：

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "HitDirection\s*=" in "D:\Develop\Projects\Astrum\AstrumProj\Assets\Script" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `HitDirection = hitDirection,` | L69 |
| `.\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `HitDirection = direction,` | L63 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\Events\HitReactionEvent.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在让我看看 `HitDirection` 是怎么计算的。让我查看 `DamageEffectHandler.cs` 和 `KnockbackEffectHandler.cs` 中的具体设置方式：</details></think>

---

让我查看 `DamageEffectHandler.cs` 和 `KnockbackEffectHandler.cs` 中 `hitDirection` 的计算方式：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我理解了整个逻辑：

1. **DamageEffectHandler** 中的 `CalculateHitDirection`:
```csharp
// 从施法者指向目标
TSVector direction = targetTrans.Position - casterTrans.Position;
```
这里的 HitDirection 是从 **攻击者指向目标** 的方向（也就是击退方向）。

2. **KnockbackEffectHandler** 中的 `CalculateKnockbackDirection`:
在 mode=2（Outward）的情况下：
```csharp
TSVector dir = targetTrans.Position - casterTrans.Position; // 从施法者指向目标
```
同样，击退方向也是从攻击者指向目标。

3. **HitReactionCapability** 中的 `UpdateFacingDirection`:
```csharp
if (direction.sqrMagnitude > FP.EN4)
{
    direction = direction * (-FP.One);  // 取反：让角色面向击退的反方向
}
```

问题就在这里！

当前逻辑：
- HitDirection = 攻击者 → 目标（即击退方向）
- UpdateFacingDirection 取反后 = 目标 → 攻击者
- 角色使用这个取反后的方向作为朝向

等等，我再仔细看看... 如果 HitDirection 是攻击者→目标，取反后是目标→攻击者，那角色就是面向攻击者，这应该是正确的！

但用户报告的问题是"模型朝向应该面向受击方向，而不是顺着"。

我发现代码逻辑存在关键问题。目前的实现是让角色面向攻击者，但实际需求是面向受击方向。这意味着我们需要调整方向计算，确保角色朝向与击退方向一致，而不是反向。解决方案可能是移除当前的方向取反操作，直接使用原始的击退方向作为朝向。 I'll face the character in the direction opposite to the knockback, ensuring they're oriented away from the attacker. The calculation reveals the knockback direction is from the attacker towards the target. This means to align the character "along" the knockback direction, I'll need to use the inverse of the current direction calculation.

By flipping the direction vector in the `UpdateFacingDirection` method, I can orient the character's forward vector away from the attack source. This approach ensures the character appears to be pushed or recoiling from the incoming damage.

The key is understanding how the `LookRotation` method interprets direction vectors to determine character facing, which requires careful vector manipulation to achieve the desired orientation.

I'm exploring the nuanced interpretation of "facing hit direction" - whether it means facing the attack source or the direction of knockback. The current implementation suggests facing the attacker, which seems counterintuitive to a natural recoil response.

The code's logic involves inverting the direction vector, which implies a specific orientation strategy. This inversion might fundamentally change how the character responds to being hit, potentially contradicting the expected visual or gameplay mechanic.

I need to carefully analyze the code's intent and compare it with the user's description of the expected behavior, focusing on the precise meaning of directional facing during an attack.

The key observation is that the current implementation seems to be inverting the hit direction under certain conditions, which could lead to unexpected character positioning. The threshold check `sqrMagnitude > FP.EN4` suggests a nuanced approach to determining when this inversion should occur.

My current hypothesis is that the code's logic is inverting the direction when it shouldn't, causing the character to face the wrong way during an attack sequence.

I'll investigate three potential sources of the issue:
1. Potential miscalculation in hit direction vector
2. Incorrect method of vector inversion
3. Problematic rotation calculation in the LookRotation method

The next step is to carefully examine the `CalculateHitDirection` method to understand exactly how the vector is being computed and potentially identify the root cause of the unexpected behavior.

The calculation confirms the hit direction vector points from the caster towards the target. By subtracting the caster's position from the target's position and normalizing, we ensure a consistent directional vector. The method also handles edge cases like zero-magnitude vectors by returning a default forward direction.

The key observation is the explicit vector normalization and horizontal plane restriction, which suggests a deliberate approach to calculating directional movement.

When inverting the direction using multiplication by -FP.One, the vector effectively reverses, now pointing from the target back towards the caster - potentially preparing for a facing or knockback mechanism.

The calculation reveals an interesting directional discrepancy between two methods: one computes vector from caster to target, the other from target to caster. This opposing orientation could significantly impact gameplay mechanics like targeting, positioning, or skill interactions.

The key insight is understanding how vector subtraction order fundamentally changes directional representation, which might require careful alignment across different game systems.

I'll need to ensure both methods consistently orient vectors to maintain predictable character facing and interaction logic, potentially by standardizing the direction calculation approach.

The code reveals a subtle vector orientation strategy where direction inversion depends on magnitude, ensuring the character always faces the attacker through two complementary calculation paths. By inverting the vector when HitDirection has meaningful magnitude and falling back to direct caster calculation, the system guarantees a consistent targeting orientation.

The key insight is that both calculation methods ultimately produce the same directional outcome - targeting from the victim towards the attacker, which seems intentionally designed to normalize character response during combat interactions.

The user's request suggests exploring precise moment-of-impact visual representation, specifically how character models should orient during hit reactions.

I've discovered a critical code logic issue. The current implementation inverts the hit direction vector, which seems counterintuitive. When the hit direction magnitude exceeds a small threshold, the code negates the vector - potentially causing unexpected orientation behavior.

The core problem lies in vector direction interpretation. The existing code assumes inverting the hit direction will face the character toward the attacker, but this assumption doesn't match actual game mechanics. By flipping the vector, we might inadvertently rotate the character in an unintended manner.

The solution requires carefully mapping the directional vector to ensure precise, intuitive character facing during combat interactions. I notice the method checks if the character is moving and has a valid movement direction before updating rotation. It calculates a target rotation based on the movement logic direction, comparing it with the current model rotation. The code seems designed to smoothly transition the character's facing direction when moving, using a quick interpolation method.

The approach suggests carefully managing visual rotation to match movement logic, with safeguards to prevent unnecessary rotation updates when stationary or when movement direction is negligible. 在被动位移期间，当前旋转逻辑可能会意外覆盖击退时的朝向设置。这导致角色无法正确面对攻击来源。

解决方案需要在 ApplyRotationFromLogic 方法中增加状态检查，确保被动位移时保持原有朝向。具体可以通过添加条件判断，阻止在受击状态下更新角色朝向。

关键是平衡移动逻辑与受击响应，避免不必要的旋转冲突，保持角色在不同状态下的朝向一致性。 I'll need to complete the partial thought first by copying over the next thinking:

Logic 在击退期间会覆盖 HitReactionCapability 设置的朝向。

I see the issue now. During passive displacement, the movement logic is interfering with the facing direction set by the hit reaction. I'll modify the rotation application method to prevent this unwanted override during knockback states. The goal is to preserve the character's orientation established during the hit reaction, ensuring the character remains facing the direction of the attack.</details></think>

---

现在我理解了整个逻辑。我发现了问题所在：

**问题分析：**

1. `HitReactionCapability.UpdateFacingDirection` 中的逻辑是正确的：
   - `HitDirection` = 从攻击者指向目标（击退方向）
   - 代码取反 `direction * (-FP.One)` 后得到从目标指向攻击者的方向
   - 这样角色应该面向攻击者

2. **但是**，在 `PredictedMovementViewComponent.ApplyRotationFromLogic` 中，当角色在移动时（包括被动位移/击退），会根据 `_cachedDirLogic`（移动方向）来更新角色的朝向，**覆盖了** `HitReactionCapability` 设置的朝向！

让我确认这个问题：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
确认了问题所在！`ApplyRotationFromLogic` 在每帧被调用，当 `_isMovingLogicCached` 为 true 时（包括被动位移/击退期间），会根据移动方向 `_cachedDirLogic` 更新角色朝向。

这会覆盖 `HitReactionCapability.UpdateFacingDirection` 设置的面向攻击者的朝向。

修复方案：在 `ApplyRotationFromLogic` 中，当角色处于被动位移（`MovementType.PassiveDisplacement`，即击退）状态时，不更新朝向，保持受击时设置的面向攻击者的朝向。

让我进行修复。</details></think>

---

确认了问题！`ApplyRotationFromLogic` 在每帧都会被调用，当角色在移动时（包括被动位移/击退期间），会根据移动方向更新角色朝向，这会覆盖 `HitReactionCapability` 设置的面向攻击者的朝向。

现在我来修复这个问题：

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

**Chunk 1**
Lines added: 5, lines removed: undefined

```diff
@@ -705,4 +705,9 @@
                  return;
              
+             // 被动位移（击退）期间，保持受击时设置的朝向（面向攻击者），不根据移动方向更新
+             // 受击朝向由 HitReactionCapability.UpdateFacingDirection 在逻辑层设置
+             if (_currentMovementTypeCached == MovementType.PassiveDisplacement)
+                 return;
+             
              // 如果移动方向无效，保持当前旋转
              if (_dirVisual.sqrMagnitude &lt; 1e-8f)
```

</details>

</tool-use>

---

<think><details><summary>Thought Process</summary>
修改完成。现在我需要编译项目来验证是否有编译错误。根据用户的规则，需要通过 sln 编译 Unity 项目，并获取报错信息。让我先刷新 Unity 资源，然后编译项目。</details></think>

---

现在让我刷新 Unity 并编译项目来验证修改：

---

<tool-use data-tool-type="unknown" data-tool-name="mcp">
<details>
<summary>Tool use: **mcp**</summary>


Parameters:

```json
{
  "tools": [
    {
      "name": "execute_menu_item",
      "description": "Executes a Unity Editor menu item via its path (e.g., \"File/Save Project\").\n\n        Args:\n            ctx: The MCP context.\n            menu_path: The full path of the menu item to execute.\n            action: The operation to perform (default: 'execute').\n            parameters: Optional parameters for the menu item (rarely used).\n\n        Returns:\n            A dictionary indicating success or failure, with optional message/error.\n        ",
      "parameters": "{\"menu_path\": \"Assets/Refresh\"}",
      "serverName": "unityMCP"
    }
  ]
}
```
Additional data:

```json
{
  "status": "cancelled",
  "reviewData": {
    "status": "Done",
    "selectedOption": "run",
    "isShowingInput": false,
    "approvalType": "full_auto",
    "toolName": "execute_menu_item",
    "serverId": "unityMCP"
  }
}
```
Result:

```json
{
  "selectedTool": "execute_menu_item",
  "result": "{\"skipped\":true,\"message\":\"User cancelled the MCP tool execution\"}"
}
```
Status: **completed**


</details>
</tool-use>

---

_**User (2025-12-28 03:48Z)**_

确实没按移动方向了，但也没按照受击的方向，需要再更新一下，刷新方向

---

_**Agent (model default, mode Agent)**_



---


检查逻辑层的旋转数据如何读取，并在被动位移期间同步逻辑层设置的朝向（不从移动方向更新）：


---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "TransComponent\.TryGetViewRead|transRead\.Rotation" in "D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs" • 25 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\PredictedMovementViewComponent.cs` | `if (TransComponent.TryGetViewRead(entity.World, entity.UniqueId, out var transRead) && transRead.IsValid)` | L295 |
| `.\PredictedMovementViewComponent.cs` | `TransComponent.TryGetViewRead(entity.World, entity.UniqueId, out var transReadForFwd) &&` | L324 |
| `.\PredictedMovementViewComponent.cs` | `if (!TransComponent.TryGetViewRead(entity.World, entity.UniqueId, out var transRead) \|\| !transRead.IsValid)` | L344 |
| `.\CollisionDebugViewComponent.cs` | `if (!TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L79 |
| `.\CollisionDebugViewComponent.cs` | `var logicTransform = shape.ToWorldTransform(transRead.Position, transRead.Rotation);` | L97 |
| `.\CollisionDebugViewComponent.cs` | `DrawCollisionShape(s, transRead.Position, transRead.Rotation);` | L114 |
| `.\CollisionDebugViewComponent.cs` | `var rotation = physicsRot ?? transRead.Rotation;` | L133 |
| `.\CollisionDebugViewComponent.cs` | `if (!TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L164 |
| `.\CollisionDebugViewComponent.cs` | `DrawCollisionShape(shape, transRead.Position, transRead.Rotation);` | L191 |
| `.\CollisionDebugViewComponent.cs` | `var worldTransform = shape.ToWorldTransform(transRead.Position, transRead.Rotation);` | L196 |
| `.\CollisionDebugViewComponent.cs` | `if (TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var debugTransRead) && debugTransRead.IsValid)` | L226 |
| `.\CollisionDebugViewComponent.cs` | `if (!TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid)` | L236 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid)` | L133 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid)` | L210 |
| `.\TransViewComponent.cs` | `var fixedRot = transRead.Rotation;` | L224 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L273 |
| `.\TransViewComponent.cs` | `var fixedRot = transRead.Rotation;` | L276 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L478 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L587 |
| `.\TransViewComponent.cs` | `if (!TransComponent.TryGetViewRead(ownerEntity.World, ownerEntity.UniqueId, out var transRead) \|\| !transRead.IsValid) return;` | L668 |
| `.\TransViewComponent.cs` | `var fixedRot = transRead.Rotation;` | L671 |
| `.\ProjectileViewComponent.cs` | `if (TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var _))` | L90 |
| `.\ProjectileViewComponent.cs` | `if (!TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var transRead))` | L130 |
| `.\ProjectileViewComponent.cs` | `TransComponent.TryGetViewRead(OwnerEntity.World, OwnerEntity.UniqueId, out var transRead) &&` | L504 |
| `.\ProjectileViewComponent.cs` | `var forward = transRead.Rotation * TSVector.forward;` | L507 |


</details>
</tool-use>

---



---


查看 `OnUpdate` 方法中如何使用 `transRead`，确认如何在被动位移期间同步逻辑层的旋转：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\TransViewComponent.cs</summary>

</details>
</tool-use>

---



---


修改 `ApplyRotationFromLogic`，在被动位移期间直接同步逻辑层的旋转：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---



---


更新 `ApplyRotationFromLogic`，在被动位移期间直接同步逻辑层的旋转：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

**Chunk 1**
Lines added: 27, lines removed: 3

```diff
@@ -701,11 +701,35 @@
                  return;
              
-             // 如果角色停下了，就不要改方向了
-             if (!_isMovingLogicCached)
+             var entity = OwnerEntity;
+             if (entity == null)
                  return;
              
-             // 被动位移（击退）期间，保持受击时设置的朝向（面向攻击者），不根据移动方向更新
+             // 被动位移（击退）期间，直接从逻辑层读取旋转并同步（保持受击时设置的朝向，面向攻击者）
              // 受击朝向由 HitReactionCapability.UpdateFacingDirection 在逻辑层设置
              if (_currentMovementTypeCached == MovementType.PassiveDisplacement)
+             {
+                 if (TransComponent.TryGetViewRead(entity.World, entity.UniqueId, out var transRead) &amp;&amp; transRead.IsValid)
+                 {
+                     // 从逻辑层读取旋转（定点数转浮点数）
+                     var fixedRot = transRead.Rotation;
+                     Quaternion logicRotation = new Quaternion(
+                         (float)fixedRot.x,
+                         (float)fixedRot.y,
+                         (float)fixedRot.z,
+                         (float)fixedRot.w
+                     );
+                     
+                     // 获取当前模型旋转
+                     Quaternion currentRotation = _ownerEntityView.GetWorldRotation();
+                     
+                     // 平滑同步到逻辑层旋转（使用较快的缓动速度，确保及时响应）
+                     Quaternion newRotation = Quaternion.Lerp(currentRotation, logicRotation, rotationLerpSpeed * 2f);
+                     _ownerEntityView.SetWorldRotation(newRotation);
+                 }
+                 return;
+             }
+             
+             // 如果角色停下了，就不要改方向了
+             if (!_isMovingLogicCached)
                  return;
              
```

</details>

</tool-use>

---



---


检查是否有编译错误：


---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---

Tool call errored or timed out

---

_**User (2025-12-28 03:48Z)**_

Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs(723,32): error CS0136: A local or parameter named 'currentRotation' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter


---

_**Agent (model default, mode Agent)**_



---


修复变量名冲突：`currentRotation` 在方法中被重复声明。


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---



---


修复变量名冲突：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

**Chunk 1**
Lines added: 2, lines removed: 2

```diff
@@ -721,8 +721,8 @@
                      
                      // 获取当前模型旋转
-                     Quaternion currentRotation = _ownerEntityView.GetWorldRotation();
+                     Quaternion currentRot = _ownerEntityView.GetWorldRotation();
                      
                      // 平滑同步到逻辑层旋转（使用较快的缓动速度，确保及时响应）
-                     Quaternion newRotation = Quaternion.Lerp(currentRotation, logicRotation, rotationLerpSpeed * 2f);
+                     Quaternion newRotation = Quaternion.Lerp(currentRot, logicRotation, rotationLerpSpeed * 2f);
                      _ownerEntityView.SetWorldRotation(newRotation);
                  }
```

</details>

</tool-use>

---



---



---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


编译错误已修复。

## 修复总结

已修复角色受击时朝向问题：

1. **问题分析**：
   - `HitReactionCapability.UpdateFacingDirection` 在逻辑层正确设置了面向攻击者的朝向
   - 但 `PredictedMovementViewComponent.ApplyRotationFromLogic` 在被动位移（击退）期间会根据移动方向更新朝向，覆盖了受击朝向

2. **修复方案**：
   - 在 `ApplyRotationFromLogic` 中添加对被动位移的特殊处理
   - 被动位移期间，直接从逻辑层的 `TransComponent.ViewRead` 读取旋转并同步到表现层
   - 这样保持了 `HitReactionCapability` 设置的面向攻击者的朝向

3. **代码变更**：
   - 在被动位移分支中，读取逻辑层旋转并同步到表现层
   - 使用 `rotationLerpSpeed * 2f` 加速缓动，确保及时响应
   - 修复了变量名冲突（将 `currentRotation` 改为 `currentRot`）

现在角色受击时会面向攻击者，而不是顺着击退方向。请测试验证。

---

_**User (2025-12-28 03:48Z)**_

Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs(726,32): error CS0136: A local or parameter named 'newRotation' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter


---

_**Agent (model default, mode Agent)**_



---


修复 `newRotation` 的变量名冲突：


---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---



---





---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

</details>
</tool-use>

---



---


修复变量名冲突，将被动位移分支中的 `newRotation` 改为 `newRot`：


---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs</summary>

**Chunk 1**
Lines added: 2, lines removed: 2

```diff
@@ -724,6 +724,6 @@
                      
                      // 平滑同步到逻辑层旋转（使用较快的缓动速度，确保及时响应）
-                     Quaternion newRotation = Quaternion.Lerp(currentRot, logicRotation, rotationLerpSpeed * 2f);
-                     _ownerEntityView.SetWorldRotation(newRotation);
+                     Quaternion newRot = Quaternion.Lerp(currentRot, logicRotation, rotationLerpSpeed * 2f);
+                     _ownerEntityView.SetWorldRotation(newRot);
                  }
                  return;
```

</details>

</tool-use>

---



---





---

<tool-use data-tool-type="generic" data-tool-name="read_lints">
<details>
          <summary>Tool use: **read_lints** • Read lints for 1 file</summary>
      
Lint paths:

- `d:\Develop\Projects\Astrum\AstrumProj\Assets\Script\AstrumView\Components\PredictedMovementViewComponent.cs`

Lint results


**No lint errors found**
</details>
</tool-use>

---



---


已修复变量名冲突。已将被动位移分支中的变量名改为：
- `currentRotation` → `currentRot`
- `newRotation` → `newRot`

这样可以避免与方法后续部分中的同名变量冲突。代码应可正常编译。请重新编译项目确认。

---

