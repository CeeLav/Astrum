<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 6008639c-7f3e-475c-8416-7856b2b0a582 (2025-12-27 07:24Z) -->

# 表现层位移与击退处理 (2025-12-27 07:24Z)

_**User (2025-12-27 07:27Z)**_

现在被击退以及释放位移技能的时候，表现层没有正确执行@Astrum/AstrumProj/Assets/Script/AstrumLogic/Capabilities/SkillDisplacementCapability.cs @Astrum/AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs @Astrum/AstrumProj/Assets/Script/AstrumLogic/Capabilities/KnockbackCapability.cs ，确认一下这些代码的逻辑，看一下表现层应该再加一个组件处理还是在现有的组件里加一个状态处理。

---

_**Agent (model claude-4.5-opus-high-thinking, mode Plan)**_

<think><details><summary>Thought Process</summary>
用户想要了解为什么击退和技能位移在表现层没有正确执行。让我先分析一下这三个文件的逻辑：

1. **KnockbackCapability.cs** - 击退能力逻辑层
2. **SkillDisplacementCapability.cs** - 技能位移能力逻辑层  
3. **PredictedMovementViewComponent.cs** - 预测移动表现层组件

我需要理解：
1. 逻辑层如何标记移动类型
2. 表现层如何响应这些移动类型
3. 为什么表现层没有正确处理

让我仔细看一下代码：

**KnockbackCapability.cs**:
- 在 Tick 中，设置 `movementComponent.CurrentMovementType = MovementType.PassiveDisplacement`
- 并调用 `entity.MarkComponentDirty(MovementComponent.ComponentTypeId)`

**SkillDisplacementCapability.cs**:
- 在 ApplyRootMotion 中，设置 `movementComponent.CurrentMovementType = MovementType.SkillDisplacement`
- 并调用 `entity.MarkComponentDirty(MovementComponent.ComponentTypeId)`

**PredictedMovementViewComponent.cs**:
- 在 `OnUpdate` 中检查 `_currentMovementTypeCached`
- 如果是 `MovementType.SkillDisplacement`，调用 `HandleSkillMotion`
- 否则调用 `HandleNormalMotion`

但我注意到一个问题：
- `HandleSkillMotion` 处理技能位移


- `HandleNormalMotion` 处理普通移动
- 表现层缺少对击退（`MovementType.PassiveDisplacement`）的专门处理方法

这意味着当发生击退时，表现层可能无法正确执行位移逻辑，导致击退效果未能正确呈现。需要在 `PredictedMovementViewComponent` 中为击退添加专门的处理逻辑。

关键问题是确保击退的位移行为与普通移动和技能位移有明确区分，以保证游戏体验的流畅性和准确性。

需要深入分析移动类型的具体实现细节，特别是对于特殊位移模式如击退的处理逻辑。

我将追踪 `MovementType` 的定义，探索不同移动类型的具体实现机制，并评估当前位移系统是否能满足击退的特定需求。重点关注位移的平滑度、预测性和精确性。</details></think>

---

我来分析这三个文件的逻辑，看看表现层的问题在哪里。首先让我了解一下相关的组件定义。

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "enum MovementType" in "Astrum/AstrumProj/Assets/Script" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script\AstrumLogic\Components\MovementComponent.cs` | `public enum MovementType` | L13 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "MovementType\." in "Astrum/AstrumProj/Assets/Script" • 15 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script\AstrumView\Components\PredictedMovementViewComponent.cs` | `_isMovingLogicCached = moveRead.CurrentMovementType != MovementType.None;` | L83 |
| `AstrumProj/Assets/Script\AstrumView\Components\PredictedMovementViewComponent.cs` | `_isMovingLogicCached = moveRead.CurrentMovementType != MovementType.None;` | L254 |
| `AstrumProj/Assets/Script\AstrumView\Components\PredictedMovementViewComponent.cs` | `if (_currentMovementTypeCached == MovementType.SkillDisplacement)` | L309 |
| `AstrumProj/Assets/Script\AstrumView\Components\PredictedMovementViewComponent.cs` | `_isMovingLogicCached = moveRead.CurrentMovementType != MovementType.None;` | L347 |
| `AstrumProj/Assets/Script\AstrumLogic\Components\MovementComponent.cs` | `internal MovementType CurrentMovementType \{ get; set; \} = MovementType.None;` | L94 |
| `AstrumProj/Assets/Script\AstrumLogic\Components\MovementComponent.cs` | `CurrentMovementType = MovementType.None;` | L240 |
| `AstrumProj/Assets/Script\AstrumLogic\Components\MovementComponent.ViewRead.cs` | `return new ViewRead(entityId, false, default, false, MovementType.None, default);` | L60 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\MovementCapability.cs` | `if (movementComponent.CurrentMovementType != MovementType.PlayerInput)` | L124 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\MovementCapability.cs` | `movementComponent.CurrentMovementType = MovementType.PlayerInput;` | L126 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\MovementCapability.cs` | `if (movementComponent.CurrentMovementType != MovementType.None && movementComponent.LastMoveFrame != currentFrame)` | L269 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\MovementCapability.cs` | `movementComponent.CurrentMovementType = MovementType.None;` | L271 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` | `if (movementComponent.CurrentMovementType != MovementType.PassiveDisplacement)` | L165 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` | `movementComponent.CurrentMovementType = MovementType.PassiveDisplacement;` | L167 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\SkillDisplacementCapability.cs` | `if (movementComponent.CurrentMovementType != MovementType.SkillDisplacement)` | L190 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\SkillDisplacementCapability.cs` | `movementComponent.CurrentMovementType = MovementType.SkillDisplacement;` | L192 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
让我看看 MovementType 的完整定义：</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/Components/MovementComponent.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我理解了逻辑。让我总结一下问题：

**逻辑层**:
1. `KnockbackCapability` 设置 `MovementType.PassiveDisplacement`
2. `SkillDisplacementCapability` 设置 `MovementType.SkillDisplacement`
3. `MovementCapability` 设置 `MovementType.PlayerInput`

**表现层 (PredictedMovementViewComponent)**:
```csharp
// 5. 根据移动模式处理不同逻辑
if (_currentMovementTypeCached == MovementType.SkillDisplacement)
{
    HandleSkillMotion(posLogic, logicFrame, logicFrameAdvanced, deltaTime);
}
else
{
    HandleNormalMotion(posLogic, logicFrame, logicFrameAdvanced, deltaTime);
}
```

**问题**:
- 表现层只处理了 `SkillDisplacement` 和 "其他"（默认走 `HandleNormalMotion`）
- `MovementType.PassiveDisplacement`（击退）被当作普通移动处理
- 普通移动的逻辑使用预测、纠偏等算法，可能不适合击退位移

让我看看 `HandleSkillMotion` 和 `HandleNormalMotion` 的区别：

**HandleSkillMotion**:
- 使用 RootMotion 动画位移
- 动态调整位移距离来追赶或减慢以匹配逻辑位置
- 有极端保护（hardSnapDistance）

**HandleNormalMotion**:
- 使用预测未来位置


- 使用方向混合（逻辑方向 + 纠偏方向）
- 使用速度加速过渡
- 有惯性前进逻辑

对于击退，需要特殊处理：击退作为被动位移，角色可能不播放移动动画。位移方向和速度完全由逻辑层控制，不应用预测纠偏算法。最佳方案是直接跟随逻辑位置，或者进行轻微平滑过渡，但不做复杂的预测。

我将探索击退动画和表现层处理的具体细节，重点关注角色受击时的视觉呈现。</details></think>

---

让我进一步了解击退时的动画处理和相关表现逻辑：

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "PassiveDisplacement" in "Astrum/AstrumProj/Assets/Script" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script\AstrumLogic\Components\MovementComponent.cs` | `PassiveDisplacement` | L30 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` | `if (movementComponent.CurrentMovementType != MovementType.PassiveDisplacement)` | L165 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` | `movementComponent.CurrentMovementType = MovementType.PassiveDisplacement;` | L167 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
看来表现层完全没有处理 `PassiveDisplacement`（击退）类型！这就是问题所在。

让我再看看表现层是否有其他的击退相关处理：</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "Knockback|knockback" in "Astrum/AstrumProj/Assets/Script/AstrumView" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<think><details><summary>Thought Process</summary>
表现层完全没有处理 `Knockback` 相关的逻辑！让我再确认一下 `HandleSkillMotion` 和 `HandleNormalMotion` 的具体实现差异，以及看看有没有受击动作的相关处理：</details></think>

---

让我看看受击动作和动画系统是如何处理的：

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "HitAction|HitReaction|受击" in "Astrum/AstrumProj/Assets/Script" • 75 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script\AstrumView\Components\AnimationViewComponent.cs` | `AddIfValid(actionIds, config.HitAction);` | L248 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\ActionCapability.cs` | `AddIfValid(_availableActionIdsBuffer, config.HitAction);` | L171 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\ActionCapability.cs` | `/// 外部预约动作（例如受击、硬直等）` | L923 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` | `/// 优先级：150（高于移动，低于受击反应）` | L13 |
| `AstrumProj/Assets/Script\AstrumLogic\Archetypes\Builtins\CombatArchetype.cs` | `typeof(HitReactionCapability),       // Priority 200 - 受击反应` | L33 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\DamageCapability.cs` | `/// 优先级：200（与 HitReactionCapability 同级）` | L13 |
| `AstrumProj/Assets/Script\Generated\Table\BaseUnit\BaseUnitTable.cs` | `HitAction = _buf.ReadInt();` | L29 |
| `AstrumProj/Assets/Script\Generated\Table\BaseUnit\BaseUnitTable.cs` | `/// 受击动作` | L78 |
| `AstrumProj/Assets/Script\Generated\Table\BaseUnit\BaseUnitTable.cs` | `public readonly int HitAction;` | L80 |
| `AstrumProj/Assets/Script\Generated\Table\BaseUnit\BaseUnitTable.cs` | `+ "hitAction:" + HitAction + ","` | L102 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 受击反应能力 - 处理实体受到技能效果的反馈` | L15 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `public class HitReactionCapability : Capability<HitReactionCapability>` | L18 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private const string HitReactionExternalActionSource = "HitReaction";` | L31 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private const int HitActionPriority = 900;` | L32 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private const int HitActionTransitionFrames = 2;` | L33 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private const int HitActionFreezeFrames = 0;` | L34 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `RegisterEventHandler<HitReactionEvent>(OnHitReaction);` | L63 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 受击反馈事件处理（由效果处理器发送）` | L69 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private void OnHitReaction(Entity entity, HitReactionEvent evt)` | L71 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] OnHitReaction called for entity \{entity.UniqueId\}, " +` | L73 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// 1. 播放受击动作` | L77 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.PlayHitAction"))` | L79 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `PlayHitAction(entity, evt);` | L81 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// 2. 播放受击特效` | L84 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.PlayHitVFX"))` | L85 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `using (new ProfileScope("HitReactionCapability.HandleHitSound"))` | L91 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `// ====== 受击表现方法 ======` | L97 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击动作` | L100 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private void PlayHitAction(Entity entity, HitReactionEvent evt)` | L102 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug("[HitReactionCapability] ActionComponent missing, skip hit action.");` | L106 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Warning($"[HitReactionCapability] Entity \{entity.UniqueId\} has no config, unable to resolve HitAction.");` | L113 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `if (config.HitAction <= 0)` | L117 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] Entity \{entity.UniqueId\} has no HitAction configured, skip action switch.");` | L119 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ActionId = config.HitAction,` | L127 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `Priority = HitActionPriority,` | L128 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `TransitionFrames = HitActionTransitionFrames,` | L129 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `FreezingFrames = HitActionFreezeFrames,` | L131 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `SourceTag = HitReactionExternalActionSource,` | L132 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击特效` | L140 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 播放受击特效（通过 ViewEvent 传递到视图层）` | L143 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private void PlayHitVFX(Entity entity, HitReactionEvent evt)` | L145 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug("[HitReactionCapability] 未配置受击特效路径，跳过");` | L149 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Warning("[HitReactionCapability] 实体为空，无法播放受击特效");` | L155 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 队列受击特效事件: entity=\{entity.UniqueId\}, path=\{evt.VisualEffectPath\}");` | L184 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `/// 处理受击音效` | L188 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private void HandleHitSound(Entity entity, HitReactionEvent evt)` | L190 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `ASLogger.Instance.Debug($"[HitReactionCapability] 受击音效占位: \{evt.SoundEffectPath\}");` | L198 |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\HitReactionCapability.cs` | `private void UpdateFacingDirection(Entity entity, HitReactionEvent evt)` | L201 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `// 4. 发送受击反馈事件（用于播放受击动作和特效）` | L61 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `var hitReactionEvent = new HitReactionEvent` | L63 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `TriggerWhenInactive = true // 即使 HitReactionCapability 未激活也触发（主动激活）` | L74 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `target.QueueEvent(hitReactionEvent);` | L77 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `ASLogger.Instance.Debug($"[DamageEffectHandler] Sent HitReactionEvent to target \{target.UniqueId\}");` | L78 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\DamageEffectHandler.cs` | `/// 计算受击方向` | L82 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `// 4. 发送受击反馈事件（用于播放受击动作和特效）` | L56 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `var hitReactionEvent = new HitReactionEvent` | L57 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `TriggerWhenInactive = true // 即使 HitReactionCapability 未激活也触发（主动激活）` | L68 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `target.QueueEvent(hitReactionEvent);` | L71 |
| `AstrumProj/Assets/Script\AstrumLogic\SkillSystem\EffectHandlers\KnockbackEffectHandler.cs` | `ASLogger.Instance.Debug($"[KnockbackEffectHandler] Sent HitReactionEvent to target \{target.UniqueId\}");` | L72 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\RoleDataWriter.cs` | `HitAction = r.HitAction` | L98 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\RoleDataReader.cs` | `roleData.HitAction = entityData.HitAction;` | L88 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\RoleDataReader.cs` | `roleData.HitAction = 0;` | L106 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\Mappings\BaseUnitTableData.cs` | `[TableField(10, "hitAction")]` | L40 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\Mappings\BaseUnitTableData.cs` | `public int HitAction \{ get; set; \}` | L41 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\Mappings\BaseUnitTableData.cs` | `"birthAction", "deathAction", "hitAction"` | L59 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Persistence\Mappings\BaseUnitTableData.cs` | `"出生动作", "死亡动作", "受击动作"` | L75 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Data\RoleEditorData.cs` | `[LabelText("受击动作ID")]` | L68 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Data\RoleEditorData.cs` | `public int HitAction = 0;` | L69 |
| `AstrumProj/Assets/Script\Editor\RoleEditor\Data\RoleEditorData.cs` | `clone.HitAction = this.HitAction;` | L264 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `/// 受击反馈事件（由伤害/击退等效果处理器发送给受击者）` | L6 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `public struct HitReactionEvent : IEvent` | L8 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `/// <summary>受击者ID</summary>` | L13 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `/// <summary>伤害方向（用于播放受击动作）</summary>` | L22 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `/// <summary>受击位置偏移（相对于目标）</summary>` | L34 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\HitReactionEvent.cs` | `/// 请求实体预约动作的事件（例如受击、硬直等外部系统发起）` | L46 |


</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我理解了整体架构：

1. **逻辑层**:
   - `HitReactionCapability`: 处理受击反应，播放受击动作
   - `KnockbackCapability`: 处理击退位移，设置 `MovementType.PassiveDisplacement`
   - `SkillDisplacementCapability`: 处理技能位移，设置 `MovementType.SkillDisplacement`

2. **表现层**:
   - `PredictedMovementViewComponent`: 处理移动表现
     - 对 `SkillDisplacement` 有特殊处理 (`HandleSkillMotion`)
     - 对 `PassiveDisplacement`（击退）**没有**特殊处理，走普通移动逻辑

**问题分析**:

看 `HandleSkillMotion` 和 `HandleNormalMotion` 的区别：

1. **HandleSkillMotion** (技能位移):
   - 使用 RootMotion 动画位移
   - 动态调整位移距离来追赶或减慢以匹配逻辑位置
   - 依赖 Animator 的 deltaPosition

2. **HandleNormalMotion** (普通移动):
   - 使用预测未来位置
   - 使用方向混合（逻辑方向 + 纠偏方向）
   - 有惯性前进逻辑

**击退的问题**:
- 击退被当作普通移动处理
- 普通移动的预测/纠偏逻辑不适合击退：
  - 击退方向和速度是固定的（由击退效果决定）
  - 击退可能播放受击动画（不是移动动画）
  - 预测逻辑会导致位置偏差

**技能位移的问题**:
- `HandleSkillMotion` 依赖 Animator 的 deltaPosition
- 如果动画没有正确播放或 RootMotion 数据不正确，位移会出问题

我需要设计一个更精确的处理方案，确保击退和技能位移的准确性。关键是要区分不同类型的位移，并为每种位移类型定制专门的处理逻辑。

目前最佳的实现方式是在现有组件中扩展功能，通过添加专门的击退处理方法。这种方法可以直接利用已有的移动框架，减少系统复杂度。主要优势在于可以复用现有的位移处理机制，同时针对击退效果提供更精确的控制。

我会选择直接在 `PredictedMovementViewComponent` 中实现新的位移处理分支，专门处理被动位移，确保击退效果既准确又流畅。</details></think>

---

让我查看一下 `HandleSkillMotion` 的详细逻辑，以及确认击退时的表现需求：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/Capabilities/HitReactionCapability.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我有了完整的理解：

**整体架构**:

1. **逻辑层流程**:
   - 伤害/击退效果处理器 → 发送 `HitReactionEvent` 到目标
   - `HitReactionCapability` 收到事件 → 播放受击动作、特效
   - `KnockbackCapability` 收到 `KnockbackEvent` → 设置击退数据，开始位移
   - 在 Tick 中：击退每帧更新位置，设置 `MovementType.PassiveDisplacement`

2. **表现层问题**:
   - `PredictedMovementViewComponent` 检查 `MovementType`:
     - `SkillDisplacement` → `HandleSkillMotion`（使用 RootMotion）
     - 其他类型（包括 `PassiveDisplacement`）→ `HandleNormalMotion`（预测纠偏）
   
   - **问题在于**：击退走的是 `HandleNormalMotion`，但这个方法有预测和纠偏逻辑，会导致：
     - 预测未来位置可能与击退方向不一致
     - 纠偏可能产生不自然的运动
     - 惯性前进可能导致位置偏离

**解决方案分析**:

### 方案1：在 `PredictedMovementViewComponent` 中添加击退处理
- 添加 `HandlePassiveDisplacement` 方法
- 击退使用更直接的位置跟随逻辑（类似技能位移但不依赖 RootMotion）


- 可以使用平滑插值到逻辑位置

我注意到这个方案有明确的优缺点：平滑修改现有组件，复用架构，但会增加组件复杂度。插值方法可以提供更自然的位移效果，同时保持代码结构相对简洁。

### 方案2：创建新的 `KnockbackViewComponent`
- 专门处理击退的表现
- 可以有独立的平滑和缓动逻辑

这个方案提供了更清晰的职责分离。通过独立的组件，我可以为击退效果定制更精细的表现逻辑，避免污染现有移动组件。独立组件意味着更灵活的实现和未来扩展性。

### 方案3：统一位移处理路径
我倾向于将击退视为一种特殊的被动位移，可以通过泛化现有的位移处理逻辑来实现。通过创建通用的 `HandleForcedDisplacement` 方法，可以优雅地处理不同类型的强制位移。

**推荐方案**：在 `PredictedMovementViewComponent` 中统一处理位移逻辑，将 `HandleSkillMotion` 重命名为更通用的 `HandleForcedDisplacement`，实现技能位移和击退的统一管理。

关键是识别两种位移的细微差异，如动画增量的处理。

核心实现将聚焦于直接跟随逻辑位置，并可能引入平滑插值机制。

击退需要独立的运动处理方案，不依赖 Animator 的 `deltaPosition`。

设计新方法时，需要平衡逻辑位置同步和视觉表现的流畅性，确保击退效果既精确又自然。

`SkillDisplacementCapability` 直接更新位置，而 `HandleSkillMotion` 通过 Animator 处理，两者间可能存在微妙的同步挑战。

关键是创建一个灵活的位移机制，能够精确控制位置变化，同时保持视觉连贯性。</details></think>

---

现在我对问题有了完整的理解。让我总结分析并提出解决方案：

## 问题分析

### 当前代码流程

**逻辑层**:
1. `KnockbackCapability.Tick()` 每帧更新击退位置，并设置 `MovementType.PassiveDisplacement`
2. `SkillDisplacementCapability.Tick()` 每帧应用 RootMotion 位移，并设置 `MovementType.SkillDisplacement`

**表现层** (`PredictedMovementViewComponent`):

```309:316:Astrum/AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs
            // 5. 根据移动模式处理不同逻辑
            if (_currentMovementTypeCached == MovementType.SkillDisplacement)
            {
                HandleSkillMotion(posLogic, logicFrame, logicFrameAdvanced, deltaTime);
            }
            else
            {
                HandleNormalMotion(posLogic, logicFrame, logicFrameAdvanced, deltaTime);
            }
```

### 核心问题

1. **击退 (`PassiveDisplacement`) 没有专门处理**：被当作普通移动处理，但普通移动的预测纠偏逻辑不适合击退：
   - `HandleNormalMotion` 会预测未来位置、做方向混合、惯性前进
   - 击退是被动位移，方向和速度由逻辑层决定，不应该有预测

2. **技能位移 (`SkillDisplacement`) 依赖 RootMotion**：`HandleSkillMotion` 使用 `animator.deltaPosition` 来更新位置：

```155:156:Astrum/AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs
            // 获取原始动画位移
            Vector3 animDelta = animator.deltaPosition * motionBlendWeight;
```

   - 如果动画没有 RootMotion 数据，或 Animator 未正确设置，表现层位移可能为零或不正确

在提出解决方案之前，我需要确认一个关键问题：

---

<tool-use data-tool-type="unknown" data-tool-name="ask_question">
<details>
<summary>Tool use: **ask_question**</summary>


Parameters:

```json
{
  "title": "确认表现层需求",
  "questions": [
    {
      "id": "displacement_behavior",
      "prompt": "对于击退和技能位移，表现层应该如何处理位置？",
      "options": [
        {
          "id": "direct_follow",
          "label": "直接跟随逻辑层位置（可能有轻微平滑插值）"
        },
        {
          "id": "root_motion",
          "label": "技能位移使用 RootMotion 动画驱动，击退直接跟随逻辑位置"
        },
        {
          "id": "hybrid",
          "label": "两者都使用 RootMotion（如果有的话），fallback 到跟随逻辑位置"
        }
      ]
    }
  ]
}
```
Additional data:

```json
{
  "status": "submitted",
  "currentSelections": {}
}
```
Result:

```json
{
  "answers": [
    {
      "questionId": "displacement_behavior"
    }
  ]
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

_**User (2025-12-27 07:27Z)**_

技能位移使用 RootMotion 击退应该基于预测的落点和击退曲线表现层执行自己的逻辑

---

_**Agent (model claude-4.5-opus-high-thinking, mode Plan)**_

<think><details><summary>Thought Process</summary>
用户明确了需求：
1. **技能位移**：使用 RootMotion 动画驱动（当前已实现）
2. **击退**：基于预测的落点和击退曲线，表现层执行自己的逻辑

这意味着击退需要：
- 表现层知道击退的目标落点（或可以从逻辑层获取）
- 表现层根据击退曲线（可能是线性、减速等）自己插值执行位移
- 不是简单地跟随逻辑位置，而是预测目标位置后自己平滑过渡

让我看看 KnockbackComponent 中有哪些数据可以用于表现层：
- Direction: 击退方向
- TotalDistance: 总距离
- RemainingTime: 剩余时间
- Speed: 速度
- MovedDistance: 已移动距离
- Type: 击退类型（Linear, Decelerate 等）

表现层需要通过 ViewRead 获取这些数据。让我检查一下 KnockbackComponent 是否有 ViewRead。</details></think>

---

明白了！让我检查一下 `KnockbackComponent` 的 ViewRead 以及表现层需要的数据：

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "KnockbackComponent" in "Astrum/AstrumProj/Assets/Script" • 4 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `AstrumProj/Assets/Script\AstrumLogic\Components\KnockbackComponent.cs` |
| `AstrumProj/Assets/Script\AstrumLogic\Capabilities\KnockbackCapability.cs` |
| `AstrumProj/Assets/Script\AstrumLogic\Archetypes\Builtins\CombatArchetype.cs` |
| `AstrumProj/Assets/Script\AstrumLogic\Components\BaseComponent.MemoryPack.cs` |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
让我看看 KnockbackComponent 的完整定义：</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/Components/KnockbackComponent.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
`KnockbackComponent` 没有 ViewRead。我需要：
1. 为 `KnockbackComponent` 创建 ViewRead（或者使用其他方式让表现层获取击退数据）2. 在表现层创建击退处理逻辑

让我看看其他组件的 ViewRead 是如何实现的，作为参考：</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/Components/MovementComponent.ViewRead.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "ViewRead" in "Astrum/AstrumProj/Assets/Script/AstrumLogic/Components" • 6 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `AstrumProj/Assets/Script/AstrumLogic/Components\DerivedStatsComponent.ViewRead.cs` |
| `AstrumProj/Assets/Script/AstrumLogic/Components\DynamicStatsComponent.ViewRead.cs` |
| `AstrumProj/Assets/Script/AstrumLogic/Components\TransComponent.ViewRead.cs` |
| `AstrumProj/Assets/Script/AstrumLogic/Components\ProjectileComponent.ViewRead.cs` |
| `AstrumProj/Assets/Script/AstrumLogic/Components\MovementComponent.ViewRead.cs` |
| `AstrumProj/Assets/Script/AstrumLogic/Components\ActionComponent.ViewRead.cs` |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我有足够的信息来制定计划了。让我总结：

**问题**：1. 击退（`PassiveDisplacement`）在表现层被当作普通移动处理，导致预测纠偏逻辑不适用
2. `KnockbackComponent` 没有 ViewRead，表现层无法获取击退数据
3. 表现层需要根据击退的目标落点和曲线类型，自己执行平滑位移逻辑

**解决方案**：

1. **为 `KnockbackComponent` 添加 ViewRead**：
   - 创建 `KnockbackComponent.ViewRead.cs`
   - 暴露：IsKnockingBack, Direction, TotalDistance, MovedDistance, RemainingTime, Type, Speed
   - 表现层可以计算目标落点 = 当前位置 + Direction * (TotalDistance - MovedDistance)

2. **在 `PredictedMovementViewComponent` 中添加击退处理**：
   - 添加 `HandlePassiveDisplacement` 方法
   - 根据击退类型（Linear, Decelerate）执行不同的插值曲线
   - 预测目标落点，平滑过渡到目标位置
   - 监听 `KnockbackComponent` 的 ViewRead

3. **修改移动类型分支**：
   - `SkillDisplacement` → `HandleSkillMotion`（RootMotion）
   - `PassiveDisplacement` → `HandlePassiveDisplacement`（基于落点曲线）
   - 其他 → `HandleNormalMotion`（预测纠偏）
   
我将逐步实施这个详细的技术方案。首先，需要设计接口和数据结构，确保表现层能准确获取和处理击退信息。关键是建立一个灵活的机制，能够支持不同类型的位移行为，同时保持代码的可扩展性和清晰度。</details></think>

---

现在我理解了完整需求。让我创建一个计划：

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# 击退表现层实现计划\n\n## 问题分析\n\n当前表现层 &#96;PredictedMovementViewComponent&#96; 只处理了两种情况：\n- &#96;SkillDisplacement&#96; → 使用 RootMotion 动画驱动\n- 其他类型 → 使用预测纠偏逻辑（&#96;HandleNormalMotion&#96;）\n\n击退 (&#96;PassiveDisplacement&#96;) 被错误地当作普通移动处理，而普通移动的预测纠偏逻辑不适合击退场景。\n\n## 实现方案\n\n### 1. 为 KnockbackComponent 添加 ViewRead\n\n创建 [&#96;KnockbackComponent.ViewRead.cs&#96;](AstrumProj/Assets/Script/AstrumLogic/Components/KnockbackComponent.ViewRead.cs)，暴露以下数据：\n\n| 字段 | 用途 |\n|------|------|\n| IsKnockingBack | 是否正在击退 |\n| Direction | 击退方向（归一化） |\n| TotalDistance | 总击退距离 |\n| MovedDistance | 已移动距离 |\n| Speed | 击退速度 |\n| Type | 击退类型（Linear/Decelerate） |\n\n表现层可通过这些数据计算：\n- 目标落点 = 当前位置 + Direction × (TotalDistance - MovedDistance)\n- 进度 = MovedDistance / TotalDistance\n\n### 2. 修改 PredictedMovementViewComponent\n\n在 [&#96;PredictedMovementViewComponent.cs&#96;](AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs) 中：\n\n**2.1 添加击退状态监听**\n- 在 &#96;GetWatchedComponentIds()&#96; 中添加 &#96;KnockbackComponent.ComponentTypeId&#96;\n- 在 &#96;SyncDataFromComponent()&#96; 中处理击退数据同步\n- 缓存击退相关状态（方向、速度、目标位置等）\n\n**2.2 添加击退处理方法**\n\n&#96;&#96;&#96;csharp\nprivate void HandlePassiveDisplacement(Vector3 posLogic, float deltaTime)\n{\n    // 1. 从 ViewRead 获取击退数据（方向、剩余距离、类型）\n    // 2. 计算目标落点 = posLogic + direction * remainingDistance\n    // 3. 根据击退类型选择插值曲线：\n    //    - Linear: 匀速插值\n    //    - Decelerate: 缓出曲线（如 EaseOutQuad）\n    // 4. 按曲线更新 _posVisual\n}\n&#96;&#96;&#96;\n\n**2.3 修改移动类型分支**\n\n&#96;&#96;&#96;csharp\n// 原代码\nif (_currentMovementTypeCached == MovementType.SkillDisplacement)\n    HandleSkillMotion(...);\nelse\n    HandleNormalMotion(...);\n\n// 修改后\nswitch (_currentMovementTypeCached)\n{\n    case MovementType.SkillDisplacement:\n        HandleSkillMotion(...);\n        break;\n    case MovementType.PassiveDisplacement:\n        HandlePassiveDisplacement(...);\n        break;\n    default:\n        HandleNormalMotion(...);\n        break;\n}\n&#96;&#96;&#96;\n\n### 3. 击退曲线实现\n\n| 类型 | 曲线公式 | 效果 |\n|------|----------|------|\n| Linear | &#96;t&#96; | 匀速位移 |\n| Decelerate | &#96;1 - (1-t)²&#96; | 先快后慢，自然减速 |\n\n表现层根据进度 &#96;t = elapsedTime / totalTime&#96; 计算当前位置。\n\n## 数据流\n\n&#96;&#96;&#96;mermaid\nflowchart TD\n    subgraph logic [逻辑层]\n        KB[KnockbackCapability.Tick]\n        KC[KnockbackComponent]\n        TC[TransComponent]\n    end\n    \n    subgraph sync [同步层]\n        VR[KnockbackComponent.ViewRead]\n        TR[TransComponent.ViewRead]\n    end\n    \n    subgraph view [表现层]\n        PMV[PredictedMovementViewComponent]\n        HPD[HandlePassiveDisplacement]\n    end\n    \n    KB --&gt;|更新位置| TC\n    KB --&gt;|更新状态| KC\n    KC --&gt;|导出| VR\n    TC --&gt;|导出| TR\n    VR --&gt;|读取击退数据| PMV\n    TR --&gt;|读取逻辑位置| PMV\n    PMV --&gt;|调用| HPD\n    HPD --&gt;|基于曲线插值| PMV\n&#96;&#96;&#96;\n",
  "name": "击退表现层实现",
  "todos": [
    {
      "content": "创建 KnockbackComponent.ViewRead.cs，暴露击退数据给表现层",
      "status": "pending",
      "id": "knockback-viewread"
    },
    {
      "content": "在 PredictedMovementViewComponent 中添加 HandlePassiveDisplacement 方法",
      "status": "pending",
      "id": "handle-passive-displacement",
      "dependencies": [
        "knockback-viewread"
      ]
    },
    {
      "content": "修改移动类型分支，PassiveDisplacement 调用击退处理逻辑",
      "status": "pending",
      "id": "movement-type-branch",
      "dependencies": [
        "handle-passive-displacement"
      ]
    }
  ],
  "overview": "为击退添加表现层支持：创建 KnockbackComponent.ViewRead 让表现层获取击退数据，在 PredictedMovementViewComponent 中添加击退处理逻辑，基于预测落点和击退曲线执行平滑位移。"
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///c%3A/Users/Lavender/.cursor/plans/%E5%87%BB_629084e9.plan.md",
  "hasOpenedEditor": true,
  "pinnedName": "击"
}
```
Result:

```json
{
  "accepted": {
    "finalTodos": [
      {
        "content": "创建 KnockbackComponent.ViewRead.cs，暴露击退数据给表现层",
        "status": "pending",
        "id": "knockback-viewread"
      },
      {
        "content": "在 PredictedMovementViewComponent 中添加 HandlePassiveDisplacement 方法",
        "status": "pending",
        "id": "handle-passive-displacement"
      },
      {
        "content": "修改移动类型分支，PassiveDisplacement 调用击退处理逻辑",
        "status": "pending",
        "id": "movement-type-branch"
      }
    ]
  },
  "planUri": "c:\\Users\\Lavender\\.cursor\\plans\\击_629084e9.plan.md"
}
```
Status: **completed**


</details>
</tool-use>

---

_**User (2025-12-27 07:27Z)**_

在 GetWatchedComponentIds() 中添加 KnockbackComponent.ComponentTypeId
在 SyncDataFromComponent() 中处理击退数据同步 这里的 View 层脏数据处理逻辑看下是否要更新。这个逻辑比较早写的了，现在应该设计为，当双缓冲交换，也就是逻辑层有新的数据产出时，View 层的这个接口才会触发。确认当前逻辑

---

_**Agent (model claude-4.5-opus-high-thinking, mode Plan)**_

<think><details><summary>Thought Process</summary>
用户想确认 View 层的脏数据处理逻辑。让我看看 `SyncDataFromComponent` 和相关的双缓冲交换逻辑是如何工作的。</details></think>

---

让我查看 View 层的脏数据同步机制：

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "SyncDataFromComponent|GetWatchedComponentIds" in "Astrum/AstrumProj/Assets/Script/AstrumView" • 23 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script/AstrumView\Core\Stage.cs` | `var watchedIds = viewComponent.GetWatchedComponentIds();` | L317 |
| `AstrumProj/Assets/Script/AstrumView\Core\Stage.cs` | `viewComponent.SyncDataFromComponent(componentTypeId);` | L323 |
| `AstrumProj/Assets/Script/AstrumView\Core\Stage.cs` | `/// 直接触发所有 ViewComponent 的 SyncDataFromComponent` | L330 |
| `AstrumProj/Assets/Script/AstrumView\Components\PredictedMovementViewComponent.cs` | `public override int[] GetWatchedComponentIds()` | L68 |
| `AstrumProj/Assets/Script/AstrumView\Components\PredictedMovementViewComponent.cs` | `public override void SyncDataFromComponent(int componentTypeId)` | L73 |
| `AstrumProj/Assets/Script/AstrumView\Components\PredictedMovementViewComponent.cs` | `/// 在多线程模式下，SyncDataFromComponent 不会被调用，所以需要在这里直接更新移动状态` | L337 |
| `AstrumProj/Assets/Script/AstrumView\Components\PredictedMovementViewComponent.cs` | `// （原本由 SyncDataFromComponent 负责，但多线程模式下不会被调用）` | L346 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `SyncDataFromComponent(0);` | L49 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `public override int[] GetWatchedComponentIds()` | L56 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `public override void SyncDataFromComponent(int componentTypeId)` | L70 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `ASLogger.Instance.Warning($"HUDViewComponent.SyncDataFromComponent: OwnerEntity or World is null");` | L74 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `ASLogger.Instance.Debug($"HUDViewComponent.SyncDataFromComponent: DynamicStatsComponent not found for entity \{OwnerEntity.UniqueId\}");` | L84 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `ASLogger.Instance.Debug($"HUDViewComponent.SyncDataFromComponent: DerivedStatsComponent not found for entity \{OwnerEntity.UniqueId\}");` | L90 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `ASLogger.Instance.Debug($"HUDViewComponent.SyncDataFromComponent: Entity \{OwnerEntity.UniqueId\} - CurrentHP: \{newCurrentHealth\}, MaxHP: \{newMaxHealth\}, Shield: \{newCurrentShield\}");` | L99 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `SyncDataFromComponent(0);` | L121 |
| `AstrumProj/Assets/Script/AstrumView\Components\HUDViewComponent.cs` | `// 此方法现在由 SyncDataFromComponent 调用，不再需要实现` | L134 |
| `AstrumProj/Assets/Script/AstrumView\Components\ProjectileViewComponent.cs` | `public override int[] GetWatchedComponentIds()` | L105 |
| `AstrumProj/Assets/Script/AstrumView\Components\ProjectileViewComponent.cs` | `public override void SyncDataFromComponent(int componentTypeId)` | L114 |
| `AstrumProj/Assets/Script/AstrumView\Components\ViewComponent.cs` | `public virtual int[] GetWatchedComponentIds()` | L190 |
| `AstrumProj/Assets/Script/AstrumView\Components\ViewComponent.cs` | `public virtual void SyncDataFromComponent(int componentTypeId)` | L200 |
| `AstrumProj/Assets/Script/AstrumView\Core\EntityView.cs` | `var watchedIds = viewComponent.GetWatchedComponentIds();` | L349 |
| `AstrumProj/Assets/Script/AstrumView\Core\EntityView.cs` | `var watchedIds = viewComponent.GetWatchedComponentIds();` | L373 |
| `AstrumProj/Assets/Script/AstrumView\Core\EntityView.cs` | `viewComponent.SyncDataFromComponent(componentId);` | L421 |


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<think><details><summary>Thought Process</summary>
让我继续查看脏组件同步的触发时机，特别是双缓冲交换后的调用逻辑：</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "OnDirtyComponentsChanged|NotifyDirtyComponentsToView|dirtyComponent" in "Astrum/AstrumProj/Assets/Script" • 41 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `using (new ProfileScope("Stage.SyncDirtyComponents"))` | L484 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `SyncDirtyComponents();` | L486 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `private void SyncDirtyComponents()` | L650 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `// 直接访问 Logic 层的 dirtyComponentIds 和 ClearDirtyComponents 在多线程下不安全` | L653 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `var dirtyComponentIds = entity.GetDirtyComponentIds();` | L665 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `if (dirtyComponentIds.Count > 0)` | L666 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `entityView.SyncDirtyComponents(dirtyComponentIds);` | L675 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `entity.ClearDirtyComponents();` | L680 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `var dirtyComponentIds = entity.GetDirtyComponentIds();` | L690 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `if (dirtyComponentIds.Count > 0)` | L691 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `entityView.SyncDirtyComponents(dirtyComponentIds);` | L697 |
| `AstrumProj/Assets/Script\AstrumView\Core\Stage.cs` | `entity.ClearDirtyComponents();` | L701 |
| `AstrumProj/Assets/Script\AstrumLogic\ViewRead\ViewReadFrameSync.cs` | `var dirtyIdsCopy = entity.GetDirtyComponentIdsSnapshot();` | L82 |
| `AstrumProj/Assets/Script\AstrumLogic\ViewRead\ViewReadFrameSync.cs` | `entity.ClearDirtyComponents();` | L96 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `private HashSet<int> _dirtyComponentIds = new HashSet<int>();` | L121 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `/// 脏组件锁对象（多线程模式下保护 _dirtyComponentIds）` | L124 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `_dirtyComponentIds.Add(componentTypeId);` | L559 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `public int[] GetDirtyComponentIdsSnapshot()` | L567 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `if (_dirtyComponentIds.Count == 0)` | L571 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `var result = new int[_dirtyComponentIds.Count];` | L573 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `_dirtyComponentIds.CopyTo(result);` | L574 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `[Obsolete("多线程环境下请使用 GetDirtyComponentIdsSnapshot() 获取快照")]` | L583 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `public IReadOnlyCollection<int> GetDirtyComponentIds()` | L584 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `return _dirtyComponentIds;` | L586 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `public bool HasDirtyComponents()` | L592 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `return _dirtyComponentIds.Count > 0;` | L596 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `public List<BaseComponent> GetDirtyComponents()` | L615 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `if (_dirtyComponentIds.Count == 0)` | L620 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `dirtyIdsCopy = new int[_dirtyComponentIds.Count];` | L622 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `_dirtyComponentIds.CopyTo(dirtyIdsCopy);` | L623 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `var dirtyComponents = new List<BaseComponent>(dirtyIdsCopy.Length);` | L626 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `dirtyComponents.Add(component);` | L631 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `return dirtyComponents;` | L634 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `public void ClearDirtyComponents()` | L640 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `_dirtyComponentIds.Clear();` | L644 |
| `AstrumProj/Assets/Script\AstrumLogic\Core\Entity.cs` | `_dirtyComponentIds.Clear();` | L668 |
| `AstrumProj/Assets/Script\AstrumView\Core\EntityView.cs` | `/// <param name="dirtyComponentIds">脏组件的 ComponentTypeId 集合</param>` | L395 |
| `AstrumProj/Assets/Script\AstrumView\Core\EntityView.cs` | `public void SyncDirtyComponents(IReadOnlyCollection<int> dirtyComponentIds)` | L396 |
| `AstrumProj/Assets/Script\AstrumView\Core\EntityView.cs` | `if (dirtyComponentIds == null \|\| dirtyComponentIds.Count == 0)` | L398 |
| `AstrumProj/Assets/Script\AstrumView\Core\EntityView.cs` | `foreach (var componentId in dirtyComponentIds)` | L404 |
| `AstrumProj/Assets/Script\AstrumLogic\Events\ViewEvents.cs` | `// 脏组件同步是独立机制，通过 Stage.SyncDirtyComponents() 处理` | L46 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumView/Core/EntityView.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
让我看看 Stage 中的完整逻辑，特别是 SyncDirtyComponents 的调用时机：</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumView/Core/Stage.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/ViewRead/ViewReadFrameSync.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我理解了整个机制：

**两种模式**：

1. **单线程模式**（非 IsMultiThreadMode）：
   - `Stage.SyncDirtyComponents()` 会被调用
   - 直接访问 Logic 层的 `entity.GetDirtyComponentIds()`
   - 然后调用 `entityView.SyncDirtyComponents(dirtyComponentIds)`
   - 最后调用 `entity.ClearDirtyComponents()`

2. **多线程模式**（IsMultiThreadMode）：
   - `Stage.SyncDirtyComponents()` 直接跳过（因为不安全）
   - Logic 层在帧末调用 `ViewReadFrameSync.EndOfLogicFrame()`
   - 将脏组件数据导出到 ViewRead 双缓冲
   - View 层通过 `TryGetViewRead()` 轮询获取数据
   - 注释说："多线程模式下，`SyncDataFromComponent` 不会被调用，所以需要在 `OnUpdate` 中直接更新移动状态"

**关键发现**：
从 `PredictedMovementViewComponent` 的注释可以看到：
```csharp
/// 轮询移动组件：轻量轮询速度、移动方向和移动状态
/// 在多线程模式下，SyncDataFromComponent 不会被调用，所以需要在这里直接更新移动状态
```

所以当前设计是：
- 多线程模式：View 层在 `OnUpdate` 中主动轮询 ViewRead
- 单线程模式：`SyncDataFromComponent` 在脏组件变化时被调用


- 用户的疑问是关于数据触发机制

我会解释数据同步的具体流程：在单线程环境中，每当逻辑层组件发生变化，`SyncDataFromComponent` 会立即被触发。而在多线程场景下，系统改为主动轮询模式，View 层需要在 `OnUpdate` 中检查是否有新数据可用。这种设计确保了不同线程模式下数据同步的安全性和一致性。

对于击退处理，我建议采用三个关键步骤：创建专门的视图读取组件、在更新方法中轮询数据、避免依赖不可靠的同步接口。这样可以实现更稳定的数据传输机制。</details></think>

---

现在我理解了整个脏数据同步机制。让我总结一下：

## 当前机制分析

### 两种模式的区别

**单线程模式**：
- `Stage.SyncDirtyComponents()` 会被调用
- 直接访问 Logic 层的 `entity.GetDirtyComponentIds()`
- 调用 `entityView.SyncDirtyComponents()` → `viewComponent.SyncDataFromComponent()`

**多线程模式**（`IsMultiThreadMode == true`）：

```650:656:Astrum/AstrumProj/Assets/Script/AstrumView/Core/Stage.cs
        private void SyncDirtyComponents()
        {
            // 多线程模式下跳过此方法：脏标记由逻辑线程处理，View 层通过 ViewRead 获取数据
            // 直接访问 Logic 层的 dirtyComponentIds 和 ClearDirtyComponents 在多线程下不安全
            if (_room?.IsMultiThreadMode == true)
            {
                return;
```

从 `PredictedMovementViewComponent` 的注释也可以看到：

```336:348:Astrum/AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs
        /// <summary>
        /// 轮询移动组件：轻量轮询速度、移动方向和移动状态
        /// 在多线程模式下，SyncDataFromComponent 不会被调用，所以需要在这里直接更新移动状态
        /// </summary>
        private void UpdateMoveComponentPolling(Entity entity, TransComponent.ViewRead trans)
        {
            if (MovementComponent.TryGetViewRead(entity.World, entity.UniqueId, out var moveRead) && moveRead.IsValid)
            {
                _cachedSpeedLogic = moveRead.Speed.AsFloat();
                
                // 多线程模式下，直接从 ViewRead 更新移动状态
                // （原本由 SyncDataFromComponent 负责，但多线程模式下不会被调用）
                _isMovingLogicCached = moveRead.CurrentMovementType != MovementType.None;
```

### 结论

**多线程模式下，`SyncDataFromComponent` 不会被调用**。当前 `PredictedMovementViewComponent` 已经在 `OnUpdate` 中通过 `UpdateMoveComponentPolling` 主动轮询 ViewRead 来获取移动状态。

### 对击退实现的影响

所以对于击退处理，正确的做法是：

1. **创建 `KnockbackComponent.ViewRead`** - 通过双缓冲导出击退数据
2. **在 `OnUpdate` 中轮询 ViewRead** - 不依赖 `SyncDataFromComponent`，和现有的 `MovementComponent` 轮询方式一致
3. **`GetWatchedComponentIds()` 和 `SyncDataFromComponent()` 可以保留**，但只在单线程模式下生效（作为 fallback）

需要我更新计划吗？还是你确认当前方案后直接开始实现？

---

_**User (2025-12-27 07:27Z)**_

无论是单线程还是多线程，逻辑应当保持一致。我想恢复 GetWatchedComponentIds() 和 SyncDataFromComponent() 的使用逻辑，给 View 一个监听数据变化的接口，避免在任何逻辑下都是轮询

---

_**Agent (model claude-4.5-opus-high-thinking, mode Plan)**_

<think><details><summary>Thought Process</summary>
用户希望恢复 `GetWatchedComponentIds()` 和 `SyncDataFromComponent()` 的使用逻辑，让 View 层有一个统一的监听数据变化的接口，而不是依赖轮询。

这意味着需要：
1. 在多线程模式下，也要让 `SyncDataFromComponent` 能被正确调用
2. 需要在双缓冲交换时通知 View 层哪些组件数据发生了变化

让我思考一下如何实现：

**当前问题**：
- 多线程模式下，`Stage.SyncDirtyComponents()` 被跳过，因为直接访问 Logic 层的 `dirtyComponentIds` 不安全
- 但双缓冲交换是在 Logic 线程完成的，View 线程不知道哪些数据变了

**解决方案**：
1. 在 `ViewReadFrameSync.EndOfLogicFrame()` 中，记录本帧导出了哪些 (entityId, componentTypeId) 对
2. 双缓冲交换后，这个"脏数据列表"也需要传递给 View 层
3. View 层在 `Stage.Update()` 中读取这个脏数据列表，然后调用对应的 `SyncDataFromComponent`

或者更简单的方案：
- 在 `ViewReadStore` 中维护一个"本帧更新的组件列表"
- 双缓冲交换时，这个列表也一起交换
- View 层在 `Stage.Update()` 中检查这个列表，调用对应的 `SyncDataFromComponent`
 
我将查看 `ViewReadStore` 的具体实现，以确定最佳的同步策略。需要仔细分析其内部结构和数据交换机制，找出最安全和高效的方案。</details></think>

---

明白了，用户希望统一单线程和多线程的逻辑，让 View 层通过监听机制获取数据变化通知。让我先看看 `ViewReadStore` 的实现：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/ViewRead/ViewReadStore.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
让我看看 `ViewReadDoubleBuffer` 的实现：</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/ViewRead/ViewReadDoubleBuffer.cs</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "IViewReadBuffer" in "Astrum/AstrumProj/Assets/Script/AstrumLogic/ViewRead" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `AstrumProj/Assets/Script/AstrumLogic/ViewRead\ViewReadStore.cs` | `private readonly Dictionary<int, IViewReadBuffer> _buffersByTypeId = new Dictionary<int, IViewReadBuffer>(32);` | L7 |
| `AstrumProj/Assets/Script/AstrumLogic/ViewRead\ViewReadDoubleBuffer.cs` | `internal sealed class ViewReadDoubleBuffer<TViewRead> : IViewReadBuffer` | L5 |
| `AstrumProj/Assets/Script/AstrumLogic/ViewRead\IViewReadBuffer.cs` | `internal interface IViewReadBuffer` | L3 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我理解了整个架构。让我思考如何统一单线程和多线程的脏数据通知机制：

**当前问题**：
1. 多线程模式下，Logic 线程在帧末调用 `ViewReadFrameSync.EndOfLogicFrame()`
2. 这个方法会遍历脏组件，导出到 ViewRead，然后清除脏标记
3. 但 View 层不知道哪些组件数据发生了变化

**解决方案**：
在 `ViewReadFrameSync.EndOfLogicFrame()` 执行过程中，记录本帧更新的 (entityId, componentTypeId) 对，然后 View 层在 `Stage.Update()` 中读取这个列表，调用对应的 `SyncDataFromComponent`。

具体实现：
1. 在 `ViewReadStore` 中添加一个"本帧更新的组件列表"（双缓冲，类似于 ViewRead 数据）
2. `ViewReadFrameSync.EndOfLogicFrame()` 在导出组件时，记录到这个列表
3. `SwapAllIfWritten()` 时，列表也一起交换
4. View 层在 `Stage.SyncDirtyComponents()` 中（无论单线程还是多线程）读取这个列表，调用 `SyncDataFromComponent`

或者更简单的方案：
- 在 `ViewReadStore` 中添加 `GetDirtyEntityComponents()` 方法
- 返回本帧交换后的脏组件列表
- `Stage.SyncDirtyComponents()` 统一使用这个接口
 
我将进一步完善基础设施，确保数据同步机制更加统一和高效。重点是创建一个通用的脏数据追踪和同步机制，无论是单线程还是多线程环境。这个方案将简化组件数据更新流程，提高代码的可读性和维护性。</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumLogic/ViewRead/IViewReadBuffer.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我可以设计一个统一的方案了。

**设计思路**：

1. 在 `ViewReadStore` 中添加一个脏组件追踪机制：
   - 使用双缓冲存储脏组件列表：`List<(long entityId, int componentTypeId)>`
   - Logic 线程写入 back，View 线程读取 front
   - 在 `SwapAllIfWritten()` 时一起交换

2. `ViewReadFrameSync.EndOfLogicFrame()` 在导出组件时，同时记录到脏组件列表

3. `Stage.SyncDirtyComponents()` 统一使用 `ViewReadStore.GetDirtyComponentsSnapshot()` 获取脏组件列表，然后调用 `SyncDataFromComponent`

这样无论是单线程还是多线程：
- Logic 层标记脏组件 → `ViewReadFrameSync.EndOfLogicFrame()` 导出数据并记录脏列表 → 双缓冲交换
- View 层 `Stage.SyncDirtyComponents()` 获取脏列表 → 调用 `SyncDataFromComponent`

让我更新计划：</details></think>

---

理解了，你希望统一架构。让我设计一个方案，将脏组件追踪集成到 `ViewReadStore` 中：

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: Astrum/AstrumProj/Assets/Script/AstrumView/Core/Stage.cs</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
现在我完全理解了当前架构和用户的需求。让我创建一个更新的计划，包含：1. 统一脏组件通知机制（在 ViewReadStore 中追踪脏组件）
2. Stage.SyncDirtyComponents 统一使用 ViewRead 驱动
3. 然后再实现击退的 ViewRead 和表现逻辑</details></think>

---

现在我理解了完整的上下文。让我更新计划，包含统一脏组件通知机制的改进：

---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# 击退表现层及 ViewRead 统一计划\n\n## 第一部分：统一脏组件通知机制\n\n### 问题\n\n当前单线程和多线程模式的脏组件同步逻辑不一致：\n- **单线程**：&#96;Stage.SyncDirtyComponents()&#96; 直接访问 Logic 层的 &#96;entity.GetDirtyComponentIds()&#96;\n- **多线程**：跳过 &#96;SyncDirtyComponents()&#96;，View 层需要在 &#96;OnUpdate&#96; 中轮询 ViewRead\n\n### 解决方案\n\n将脏组件追踪集成到 &#96;ViewReadStore&#96; 双缓冲中，统一两种模式的行为。\n\n### 1.1 修改 ViewReadStore\n\n在 [&#96;ViewReadStore.cs&#96;](AstrumProj/Assets/Script/AstrumLogic/ViewRead/ViewReadStore.cs) 中添加脏组件追踪：\n\n&#96;&#96;&#96;csharp\n// 脏组件双缓冲（entityId, componentTypeId 对）\nprivate List&lt;(long entityId, int componentTypeId)&gt; _dirtyFront = new();\nprivate List&lt;(long entityId, int componentTypeId)&gt; _dirtyBack = new();\n\n// Logic 线程调用：记录本帧更新的组件\ninternal void RecordDirty(long entityId, int componentTypeId)\n{\n    _dirtyBack.Add((entityId, componentTypeId));\n}\n\n// Swap 时一起交换脏列表\ninternal bool SwapAllIfWritten()\n{\n    // ... 现有逻辑 ...\n    \n    // 交换脏列表\n    (_dirtyFront, _dirtyBack) = (_dirtyBack, _dirtyFront);\n    _dirtyBack.Clear();\n    return any;\n}\n\n// View 线程调用：获取脏组件列表\npublic IReadOnlyList&lt;(long entityId, int componentTypeId)&gt; GetDirtyComponents()\n{\n    return _dirtyFront;\n}\n&#96;&#96;&#96;\n\n### 1.2 修改 ViewReadFrameSync\n\n在 [&#96;ViewReadFrameSync.cs&#96;](AstrumProj/Assets/Script/AstrumLogic/ViewRead/ViewReadFrameSync.cs) 的 &#96;EndOfLogicFrame()&#96; 中，导出组件时同时记录脏列表：\n\n&#96;&#96;&#96;csharp\nforeach (var componentTypeId in dirtyIdsCopy)\n{\n    if (_exporters.TryGetValue(componentTypeId, out var exporter))\n    {\n        exporter(entity, store);\n        store.RecordDirty(entity.UniqueId, componentTypeId);  // 新增\n    }\n}\n&#96;&#96;&#96;\n\n### 1.3 修改 Stage.SyncDirtyComponents\n\n在 [&#96;Stage.cs&#96;](AstrumProj/Assets/Script/AstrumView/Core/Stage.cs) 中统一使用 ViewReadStore：\n\n&#96;&#96;&#96;csharp\nprivate void SyncDirtyComponents()\n{\n    var store = _room?.MainWorld?.ViewReads;\n    if (store == null) return;\n    \n    // 统一：从 ViewReadStore 获取脏组件列表\n    var dirtyList = store.GetDirtyComponents();\n    foreach (var (entityId, componentTypeId) in dirtyList)\n    {\n        if (_entityViews.TryGetValue(entityId, out var entityView))\n        {\n            entityView.SyncDirtyComponent(componentTypeId);\n        }\n    }\n}\n&#96;&#96;&#96;\n\n### 数据流（统一后）\n\n&#96;&#96;&#96;mermaid\nsequenceDiagram\n    participant Logic as Logic线程\n    participant VRF as ViewReadFrameSync\n    participant Store as ViewReadStore\n    participant Stage as Stage\n    participant EV as EntityView\n    participant VC as ViewComponent\n\n    Logic-&gt;&gt;Logic: entity.MarkComponentDirty()\n    Logic-&gt;&gt;VRF: EndOfLogicFrame()\n    VRF-&gt;&gt;Store: WriteBack() + RecordDirty()\n    VRF-&gt;&gt;Store: SwapAllIfWritten()\n    Note over Store: front/back 交换\n    \n    Stage-&gt;&gt;Store: GetDirtyComponents()\n    Store--&gt;&gt;Stage: [(entityId, componentTypeId), ...]\n    Stage-&gt;&gt;EV: SyncDirtyComponent(componentTypeId)\n    EV-&gt;&gt;VC: SyncDataFromComponent(componentTypeId)\n    VC-&gt;&gt;Store: TryGetViewRead()\n    Store--&gt;&gt;VC: ViewRead 数据\n&#96;&#96;&#96;\n\n---\n\n## 第二部分：击退表现层实现\n\n### 2.1 创建 KnockbackComponent.ViewRead\n\n创建 [&#96;KnockbackComponent.ViewRead.cs&#96;](AstrumProj/Assets/Script/AstrumLogic/Components/KnockbackComponent.ViewRead.cs)：\n\n| 字段 | 类型 | 用途 |\n|------|------|------|\n| IsKnockingBack | bool | 是否正在击退 |\n| Direction | TSVector | 击退方向（归一化） |\n| TotalDistance | FP | 总击退距离 |\n| MovedDistance | FP | 已移动距离 |\n| Speed | FP | 击退速度 |\n| Type | KnockbackType | 击退类型 |\n\n### 2.2 修改 PredictedMovementViewComponent\n\n在 [&#96;PredictedMovementViewComponent.cs&#96;](AstrumProj/Assets/Script/AstrumView/Components/PredictedMovementViewComponent.cs) 中：\n\n**添加监听**：\n&#96;&#96;&#96;csharp\npublic override int[] GetWatchedComponentIds()\n{\n    return new[] { \n        MovementComponent.ComponentTypeId,\n        KnockbackComponent.ComponentTypeId  // 新增\n    };\n}\n&#96;&#96;&#96;\n\n**添加击退处理**：\n&#96;&#96;&#96;csharp\nprivate void HandlePassiveDisplacement(Vector3 posLogic, float deltaTime)\n{\n    // 1. 获取击退 ViewRead\n    // 2. 计算目标落点 = posLogic + direction * remainingDistance\n    // 3. 根据击退类型选择插值曲线（Linear/Decelerate）\n    // 4. 平滑更新 _posVisual\n}\n&#96;&#96;&#96;\n\n**修改分支**：\n&#96;&#96;&#96;csharp\nswitch (_currentMovementTypeCached)\n{\n    case MovementType.SkillDisplacement:\n        HandleSkillMotion(...);\n        break;\n    case MovementType.PassiveDisplacement:\n        HandlePassiveDisplacement(...);\n        break;\n    default:\n        HandleNormalMotion(...);\n        break;\n}\n&#96;&#96;&#96;\n\n---\n\n## 实现顺序\n\n1. 先完成第一部分（ViewRead 统一机制），确保基础设施正确\n2. 再实现第二部分（击退 ViewRead 和表现逻辑）\n",
  "name": "击退表现层及ViewRead统一",
  "todos": [
    {
      "content": "ViewReadStore 添加脏组件双缓冲追踪机制",
      "status": "pending",
      "id": "viewread-dirty-tracking"
    },
    {
      "content": "ViewReadFrameSync.EndOfLogicFrame 导出时记录脏组件",
      "status": "pending",
      "id": "viewread-framesync-record",
      "dependencies": [
        "viewread-dirty-tracking"
      ]
    },
    {
      "content": "Stage.SyncDirtyComponents 统一使用 ViewReadStore 获取脏列表",
      "status": "pending",
      "id": "stage-unified-sync",
      "dependencies": [
        "viewread-framesync-record"
      ]
    },
    {
      "content": "创建 KnockbackComponent.ViewRead.cs",
      "status": "pending",
      "id": "knockback-viewread",
      "dependencies": [
        "stage-unified-sync"
      ]
    },
    {
      "content": "PredictedMovementViewComponent 添加击退处理逻辑",
      "status": "pending",
      "id": "handle-passive-displacement",
      "dependencies": [
        "knockback-viewread"
      ]
    }
  ],
  "overview": "统一单线程和多线程模式下的脏组件通知机制，将脏组件追踪集成到 ViewReadStore 双缓冲中，让 View 层通过监听接口获取数据变化通知，避免轮询。然后为击退添加 ViewRead 和表现层处理逻辑。"
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///c%3A/Users/Lavender/.cursor/plans/%E5%87%BB_4431f8d5.plan.md",
  "hasOpenedEditor": true,
  "pinnedName": "击"
}
```
Result:

```json
{
  "accepted": {
    "finalTodos": [
      {
        "content": "ViewReadStore 添加脏组件双缓冲追踪机制",
        "status": "pending",
        "id": "viewread-dirty-tracking"
      },
      {
        "content": "ViewReadFrameSync.EndOfLogicFrame 导出时记录脏组件",
        "status": "pending",
        "id": "viewread-framesync-record"
      },
      {
        "content": "Stage.SyncDirtyComponents 统一使用 ViewReadStore 获取脏列表",
        "status": "pending",
        "id": "stage-unified-sync"
      },
      {
        "content": "创建 KnockbackComponent.ViewRead.cs",
        "status": "pending",
        "id": "knockback-viewread"
      },
      {
        "content": "PredictedMovementViewComponent 添加击退处理逻辑",
        "status": "pending",
        "id": "handle-passive-displacement"
      }
    ]
  },
  "planUri": "c:\\Users\\Lavender\\.cursor\\plans\\击_4431f8d5.plan.md"
}
```
Status: **completed**


</details>
</tool-use>

---

