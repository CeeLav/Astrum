# 战斗系统策划案

## 1. 系统概述

战斗系统是Astrum项目中负责攻击判定、受击判定和打击感效果的核心系统。该系统与动作系统紧密配合，负责处理战斗中的各种判定和效果。

**设计理念**：
- 基于帧同步的精确判定
- 攻击盒与受击盒的分离管理
- 丰富的打击感效果支持
- 与动作系统的事件驱动集成

## 2. 核心概念

### 2.1 攻击判定
- **攻击盒**：攻击方的判定区域
- **攻击阶段**：攻击过程中的不同判定阶段
- **攻击信息**：包含伤害、推力、硬直等战斗数据

### 2.2 受击判定
- **受击盒**：受击方的判定区域
- **受击阶段**：受击过程中的不同判定阶段
- **受击效果**：受击时的视觉和逻辑效果

### 2.3 打击感系统
- **卡帧**：攻击命中时的暂停效果
- **抖动**：受击时的屏幕或角色抖动
- **硬直**：受击后的无法行动时间

## 3. 数据结构设计

### 3.1 攻击信息 (AttackInfo)

```csharp
/// <summary>
/// 攻击信息 - 一段攻击的详细信息
/// </summary>
[MemoryPackable]
public partial class AttackInfo
{
    /// <summary>攻击阶段ID</summary>
    public int Phase { get; set; }
    
    /// <summary>攻击力倍数</summary>
    public float Attack { get; set; }
    
    /// <summary>力的方向</summary>
    public ForceDirection ForceDir { get; set; }
    
    /// <summary>推力信息</summary>
    public MoveInfo PushPower { get; set; }
    
    /// <summary>硬直时间</summary>
    public float HitStun { get; set; }
    
    /// <summary>卡帧时间</summary>
    public float Freeze { get; set; }
    
    /// <summary>可命中同一目标次数</summary>
    public int CanHitSameTarget { get; set; }
    
    /// <summary>命中同一目标间隔时间</summary>
    public float HitSameTargetDelay { get; set; }
    
    /// <summary>自身动作变化信息</summary>
    public ActionChangeInfo SelfActionChange { get; set; }
    
    /// <summary>目标动作变化信息</summary>
    public ActionChangeInfo TargetActionChange { get; set; }
    
    /// <summary>临时开启的BeCancelledTag ID列表</summary>
    public List<string> TempBeCancelledTagTurnOn { get; set; } = new();
}
```

### 3.2 攻击盒激活信息 (AttackBoxTurnOnInfo)

```csharp
/// <summary>
/// 攻击盒激活信息 - 控制攻击盒的开启和关闭
/// </summary>
[MemoryPackable]
public partial class AttackBoxTurnOnInfo
{
    /// <summary>时间范围（百分比）</summary>
    public Vector2 Range { get; set; }
    
    /// <summary>攻击盒标签列表</summary>
    public List<string> Tags { get; set; } = new();
    
    /// <summary>攻击阶段</summary>
    public int AttackPhase { get; set; }
    
    /// <summary>攻击盒优先级调整</summary>
    public int Priority { get; set; }
}
```

### 3.3 受击盒激活信息 (BeHitBoxTurnOnInfo)

```csharp
/// <summary>
/// 受击盒激活信息 - 控制受击盒的开启和关闭
/// </summary>
[MemoryPackable]
public partial class BeHitBoxTurnOnInfo
{
    /// <summary>时间范围（百分比）</summary>
    public Vector2 Range { get; set; }
    
    /// <summary>受击盒标签列表</summary>
    public List<string> Tags { get; set; } = new();
    
    /// <summary>优先级</summary>
    public int Priority { get; set; }
    
    /// <summary>临时开启的BeCancelledTag ID列表</summary>
    public List<string> TempBeCancelledTagTurnOn { get; set; } = new();
    
    /// <summary>攻击者动作变化信息</summary>
    public ActionChangeInfo AttackerActionChange { get; set; }
    
    /// <summary>自身动作变化信息</summary>
    public ActionChangeInfo SelfActionChange { get; set; }
}
```

## 4. 核心类设计

### 4.1 攻击盒管理器 (AttackBoxManager)

```csharp
/// <summary>
/// 攻击盒管理器 - 管理攻击判定
/// </summary>
public class AttackBoxManager
{
    /// <summary>攻击盒列表</summary>
    public List<AttackBox> AttackBoxes { get; private set; } = new();
    
    /// <summary>命中记录</summary>
    public Dictionary<int, List<HitRecord>> HitRecords { get; private set; } = new();
    
    /// <summary>初始化攻击盒管理器</summary>
    public void Initialize()
    {
        // 初始化攻击盒
        AttackBoxes.Clear();
        HitRecords.Clear();
    }
    
    /// <summary>更新攻击盒</summary>
    public void UpdateAttackBoxes(ActionInfo actionInfo, float progress)
    {
        if (actionInfo == null) return;
        
        // 根据动作进度更新攻击盒状态
        foreach (var attackPhase in actionInfo.AttackPhase)
        {
            if (IsInTimeRange(attackPhase.Range, progress))
            {
                ActivateAttackBoxes(attackPhase);
            }
            else
            {
                DeactivateAttackBoxes(attackPhase);
            }
        }
    }
    
    /// <summary>激活攻击盒</summary>
    private void ActivateAttackBoxes(AttackBoxTurnOnInfo attackPhase)
    {
        foreach (var attackBox in AttackBoxes)
        {
            if (attackPhase.Tags.Contains(attackBox.Tag))
            {
                attackBox.SetActive(true);
                attackBox.SetPriority(attackPhase.Priority);
            }
        }
    }
    
    /// <summary>停用攻击盒</summary>
    private void DeactivateAttackBoxes(AttackBoxTurnOnInfo attackPhase)
    {
        foreach (var attackBox in AttackBoxes)
        {
            if (attackPhase.Tags.Contains(attackBox.Tag))
            {
                attackBox.SetActive(false);
            }
        }
    }
    
    /// <summary>检查是否在时间范围内</summary>
    private bool IsInTimeRange(Vector2 range, float progress)
    {
        return progress >= range.x && progress <= range.y;
    }
}
```

### 4.2 受击盒管理器 (BeHitBoxManager)

```csharp
/// <summary>
/// 受击盒管理器 - 管理受击判定
/// </summary>
public class BeHitBoxManager
{
    /// <summary>受击盒列表</summary>
    public List<BeHitBox> BeHitBoxes { get; private set; } = new();
    
    /// <summary>初始化受击盒管理器</summary>
    public void Initialize()
    {
        // 初始化受击盒
        BeHitBoxes.Clear();
    }
    
    /// <summary>更新受击盒</summary>
    public void UpdateBeHitBoxes(ActionInfo actionInfo, float progress)
    {
        if (actionInfo == null) return;
        
        // 根据动作进度更新受击盒状态
        foreach (var defensePhase in actionInfo.DefensePhase)
        {
            if (IsInTimeRange(defensePhase.Range, progress))
            {
                ActivateBeHitBoxes(defensePhase);
            }
            else
            {
                DeactivateBeHitBoxes(defensePhase);
            }
        }
    }
    
    /// <summary>激活受击盒</summary>
    private void ActivateBeHitBoxes(BeHitBoxTurnOnInfo defensePhase)
    {
        foreach (var beHitBox in BeHitBoxes)
        {
            if (defensePhase.Tags.Contains(beHitBox.Tag))
            {
                beHitBox.SetActive(true);
                beHitBox.SetPriority(defensePhase.Priority);
            }
        }
    }
    
    /// <summary>停用受击盒</summary>
    private void DeactivateBeHitBoxes(BeHitBoxTurnOnInfo defensePhase)
    {
        foreach (var beHitBox in BeHitBoxes)
        {
            if (defensePhase.Tags.Contains(beHitBox.Tag))
            {
                beHitBox.SetActive(false);
            }
        }
    }
    
    /// <summary>检查是否在时间范围内</summary>
    private bool IsInTimeRange(Vector2 range, float progress)
    {
        return progress >= range.x && progress <= range.y;
    }
}
```

## 5. 打击感系统

### 5.1 硬直与卡帧

```csharp
/// <summary>
/// 卡帧管理器 - 处理打击感中的卡帧效果
/// </summary>
public class FreezeFrameManager
{
    /// <summary>是否正在卡帧</summary>
    public bool IsFreezing { get; private set; }
    
    /// <summary>卡帧剩余时间</summary>
    public float FreezeTimeLeft { get; private set; }
    
    /// <summary>卡帧开始时间</summary>
    private float _freezeStartTime;
    
    /// <summary>卡帧持续时间</summary>
    private float _freezeDuration;
    
    /// <summary>时间缩放接口</summary>
    private ITimeScaler _timeScaler;
    
    /// <summary>初始化卡帧管理器</summary>
    public void Initialize(ITimeScaler timeScaler = null)
    {
        _timeScaler = timeScaler;
    }
    
    /// <summary>开始卡帧</summary>
    public void StartFreeze(float duration)
    {
        IsFreezing = true;
        FreezeTimeLeft = duration;
        _freezeStartTime = GetCurrentTime();
        _freezeDuration = duration;
        
        // 暂停逻辑时间，但保持动画缓慢播放
        _timeScaler?.SetTimeScale(0.1f); // 减慢时间流逝
    }
    
    /// <summary>更新卡帧</summary>
    public void UpdateFreeze(float deltaTime)
    {
        if (!IsFreezing) return;
        
        FreezeTimeLeft -= deltaTime;
        
        if (FreezeTimeLeft <= 0)
        {
            EndFreeze();
        }
    }
    
    /// <summary>结束卡帧</summary>
    private void EndFreeze()
    {
        IsFreezing = false;
        FreezeTimeLeft = 0;
        _timeScaler?.SetTimeScale(1.0f); // 恢复正常时间流逝
    }
    
    /// <summary>获取当前时间</summary>
    private float GetCurrentTime()
    {
        // 这里需要根据实际的时间系统实现
        return 0f; // 占位符
    }
}
```

### 5.2 受击与抖动

```csharp
/// <summary>
/// 受击效果管理器 - 处理受击时的抖动效果
/// </summary>
public class HitEffectManager
{
    /// <summary>原始位置</summary>
    private Vector3 _originalPosition;
    
    /// <summary>抖动强度</summary>
    public float ShakeIntensity = 0.1f;
    
    /// <summary>抖动持续时间</summary>
    public float ShakeDuration = 0.2f;
    
    /// <summary>位置更新接口</summary>
    private IPositionUpdater _positionUpdater;
    
    /// <summary>初始化受击效果管理器</summary>
    public void Initialize(IPositionUpdater positionUpdater = null)
    {
        _positionUpdater = positionUpdater;
    }
    
    /// <summary>开始受击抖动</summary>
    public void StartHitShake(Vector3 currentPosition)
    {
        _originalPosition = currentPosition;
        // 启动抖动效果
        StartHitShakeEffect();
    }
    
    /// <summary>更新受击抖动</summary>
    public void UpdateHitShake(float deltaTime, ref Vector3 currentPosition)
    {
        if (!IsShaking()) return;
        
        float progress = GetShakeProgress();
        float shakeAmount = ShakeIntensity * (1f - progress); // 逐渐减弱
        
        Vector3 randomOffset = new Vector3(
            GetRandomValue(-shakeAmount, shakeAmount),
            GetRandomValue(-shakeAmount, shakeAmount),
            0f
        );
        
        currentPosition = _originalPosition + randomOffset;
        
        // 更新抖动进度
        UpdateShakeProgress(deltaTime);
    }
    
    /// <summary>是否正在抖动</summary>
    private bool IsShaking()
    {
        // 实现抖动状态检查
        return false; // 占位符
    }
    
    /// <summary>获取抖动进度</summary>
    private float GetShakeProgress()
    {
        // 实现抖动进度计算
        return 0f; // 占位符
    }
    
    /// <summary>更新抖动进度</summary>
    private void UpdateShakeProgress(float deltaTime)
    {
        // 实现抖动进度更新
    }
    
    /// <summary>获取随机值</summary>
    private float GetRandomValue(float min, float max)
    {
        // 实现随机值生成
        return 0f; // 占位符
    }
}
```

## 6. 配置系统

### 6.1 战斗配置文件格式

```json
{
  "attackBoxes": [
    {
      "id": "attack_light_box",
      "tag": "attack_light",
      "shape": "box",
      "size": [1.0, 1.0, 0.5],
      "offset": [0.5, 0.0, 0.0]
    }
  ],
  "beHitBoxes": [
    {
      "id": "body_hitbox",
      "tag": "body",
      "shape": "box",
      "size": [0.8, 1.8, 0.4],
      "offset": [0.0, 0.9, 0.0]
    }
  ],
  "hitEffects": [
    {
      "id": "light_hit",
      "freezeTime": 0.1,
      "shakeIntensity": 0.1,
      "shakeDuration": 0.2
    }
  ]
}
```

## 7. 与动作系统集成

战斗系统通过以下方式与动作系统集成：

1. **事件驱动**：通过动作事件触发战斗判定
2. **数据共享**：共享ActionInfo中的攻击和受击信息
3. **状态同步**：战斗状态与动作状态保持同步

## 8. 总结

本战斗系统策划案专注于攻击判定、受击判定和打击感效果，与动作系统紧密配合，为Astrum项目提供完整的战斗体验。

---

*文档版本：v1.0*  
*创建时间：2025-01-22*  
*最后更新：2025-01-22*  
*状态：策划案完成，待实现*


