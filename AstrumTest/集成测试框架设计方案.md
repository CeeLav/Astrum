# AstrumLogic 集成测试框架设计方案

> 📅 创建时间: 2025-10-11  
> 🎯 目标: 设计通用的逻辑层集成测试框架，完全贴近真实运行环境

---

## 一、设计原则

### 1.1 核心原则

**完全真实环境**
- ✅ 使用真实的 `Room`, `World`, `Entity`, `LSController`
- ✅ 使用真实的 `EntityFactory`, `SkillEffectManager`, `HitManager`
- ❌ 不创建任何测试专用包装类（如 `TestEntity`, `TestRoom`）
- ❌ 不创建测试专用的简化版本

**通用性**
- ✅ 核心测试引擎与具体场景无关
- ✅ 可以测试任何逻辑：战斗、移动、AI、物理交互、技能系统等
- ✅ 通过数据驱动支持各种测试场景

**贴近单人模式**
- ✅ 完全模拟单人模式的逻辑部分
- ✅ 包含 Room + World + LSController + Entity
- ❌ 不包含表现层（Stage, EntityView, UI）

---

## 二、架构设计

### 2.1 三层架构

```plaintext
┌─────────────────────────────────────────────────────────────┐
│ 层次1: 核心测试引擎（Core）                                │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│ 职责：                                                      │
│ - 搭建真实的 Room + World 环境                             │
│ - 提供通用的帧驱动和输入模拟                               │
│ - 提供通用的断言和验证工具                                 │
│ - 可选：记录测试过程数据                                   │
│                                                             │
│ 设计要求：                                                  │
│ ✅ 场景无关，完全通用                                      │
│ ✅ 最小化，只提供必要的工具                                │
│ ❌ 不包装或替换任何生产代码                                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 层次2: 测试用例（Cases）                                   │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│ 类型：                                                      │
│ - 战斗逻辑测试（CombatLogicTests.cs）                      │
│ - 移动逻辑测试（MovementLogicTests.cs）                    │
│ - 技能系统测试（SkillSystemFlowTests.cs）                  │
│ - 物理交互测试（PhysicsInteractionTests.cs）               │
│ - AI行为测试（AIBehaviorTests.cs）                         │
│                                                             │
│ 设计要求：                                                  │
│ ✅ 直接使用真实类（Room, World, Entity）                   │
│ ✅ 使用核心引擎提供的工具                                  │
│ ✅ 可以从数据加载，也可以硬编码                            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 层次3: 测试数据（Data）                                    │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│ 类型：                                                      │
│ - 场景配置（Scenarios/*.json）                             │
│ - 实体配置（Entities/*.json）                              │
│ - 输入序列（Inputs/*.json）                                │
│ - 预期结果（Expected/*.json）                              │
│                                                             │
│ 设计要求：                                                  │
│ ✅ JSON 格式，易于编辑                                     │
│ ✅ 可选使用（也支持代码硬编码）                            │
│ ✅ 便于复用和组合                                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、详细设计

### 3.1 层次1：核心测试引擎（固定流程）

**设计思想**：
核心引擎封装完整的测试执行流程，用户只传 JSON 文件名。
从读取用例到输出报告，全自动化，用户无法绕过核心流程。

**核心流程**：
```plaintext
RunTestCase("TwoKnightsFight.json")
  ↓
[1] 读取 JSON 用例文件 + 加载实体模板
  ↓
[2] 初始化所有 Manager
  ↓
[3] 创建 Room + World + LSController
  ↓
[4] 逐帧执行测试（实体通过 CreateEntity 指令创建）
  ↓
    for each frame:
      [4.1] 执行输入指令（包括 CreateEntity）
      [4.2] 更新游戏逻辑一帧
      [4.3] 执行查询指令
      [4.4] 验证预期输出
  ↓
返回 TestResult（Success/Fail）
```

#### 目录结构

```plaintext
Integration/Core/
├── LogicTestExecutor.cs          # 测试执行引擎（核心！）
│                                  # RunTestCase(jsonFile)
│                                  # ↓
│                                  # 读取JSON → 初始化 → 执行 → 验证 → 报告
│
├── TestCaseData.cs               # JSON 数据结构定义
├── TestResult.cs                 # 测试结果数据结构
└── Assertions/                   # 断言工具（内部使用）
    ├── EntityAssert.cs
    └── SkillAssert.cs
```

#### 核心类设计

##### LogicTestExecutor.cs（核心！）

```csharp
/// <summary>
/// 逻辑测试执行引擎 - 固定流程封装
/// 
/// 用户只需调用：RunTestCase("scenarioName.json")
/// 引擎自动完成：读取 → 初始化 → 执行 → 验证 → 报告
/// </summary>
public class LogicTestExecutor : IDisposable
{
    // 真实的游戏逻辑对象
    public Room Room { get; private set; }
    public World World => Room?.MainWorld;
    public LSController LSController => Room?.LSController;
    
    private readonly ITestOutputHelper _output;
    private readonly string _dataDirectory;  // 测试数据目录
    private readonly Dictionary<string, EntityTemplate> _entityTemplates = new();  // 实体模板
    private readonly Dictionary<string, Entity> _entities = new();  // 实体映射表（entityId → Entity）
    private bool _isInitialized = false;
    
    public LogicTestExecutor(ITestOutputHelper output, ConfigFixture configFixture)
    {
        _output = output;
        
        // 测试数据目录：AstrumTest.Shared/Data/Scenarios/
        _dataDirectory = Path.Combine(
            AppContext.BaseDirectory,
            "Data", "Scenarios"
        );
    }
    
    /// <summary>
    /// 运行测试用例（完整固定流程）
    /// 用户只传文件名，引擎自动完成所有步骤
    /// </summary>
    public TestResult RunTestCase(string jsonFileName)
    {
        _output.WriteLine($"========================================");
        _output.WriteLine($"运行测试用例: {jsonFileName}");
        _output.WriteLine($"========================================");
        
        try
        {
            // ===== 步骤1: 读取 JSON 用例文件 =====
            var testCase = LoadTestCaseFromJson(jsonFileName);
            _output.WriteLine($"[1/7] ✓ 读取测试用例: {testCase.Name}");
            
            // ===== 步骤2: 初始化所有 Manager =====
            if (!_isInitialized)
            {
                InitializeManagers();
                _isInitialized = true;
            }
            _output.WriteLine($"[2/7] ✓ Manager 初始化完成");
            
            // ===== 步骤3: 创建 Room + World =====
            CreateRoomAndWorld();
            _output.WriteLine($"[3/7] ✓ Room + World 创建完成");
            
            // ===== 步骤4: 逐帧执行测试（核心流程）=====
            // 注意：实体现在通过 CreateEntity 输入指令创建，不再预先创建
            var success = ExecuteFrames(testCase.Frames);
            _output.WriteLine($"[4/4] ✓ 所有帧执行完成");
            
            // 生成测试报告
            var result = GenerateReport(testCase, success);
            
            _output.WriteLine($"========================================");
            _output.WriteLine($"{(success ? "✅ 测试通过" : "❌ 测试失败")}: {testCase.Name}");
            _output.WriteLine($"========================================");
            
            return result;
        }
        catch (Exception ex)
        {
            _output.WriteLine($"❌ 测试执行异常: {ex.Message}");
            _output.WriteLine(ex.StackTrace);
            throw;
        }
    }
    
    // ========== 固定流程实现 ==========
    
    /// <summary>
    /// 步骤1: 读取 JSON 用例文件
    /// </summary>
    private TestCaseData LoadTestCaseFromJson(string jsonFileName)
    {
        var filePath = Path.Combine(_dataDirectory, jsonFileName);
        
        if (!File.Exists(filePath))
        {
            throw new FileNotFoundException($"测试用例文件不存在: {filePath}");
        }
        
        var json = File.ReadAllText(filePath);
        var testCase = JsonConvert.DeserializeObject<TestCaseData>(json);
        
        _output.WriteLine($"  测试用例: {testCase.Name}");
        _output.WriteLine($"  实体模板数量: {testCase.EntityTemplates.Count}");
        _output.WriteLine($"  测试帧数: {testCase.Frames.Count}");
        
        // 加载实体模板到字典
        _entityTemplates.Clear();
        foreach (var template in testCase.EntityTemplates)
        {
            _entityTemplates[template.TemplateId] = template;
            _output.WriteLine($"    模板: {template.TemplateId} (RoleId={template.RoleId})");
        }
        
        return testCase;
    }
    
    /// <summary>
    /// 步骤2: 初始化所有 Manager（模拟游戏启动）
    /// </summary>
    private void InitializeManagers()
    {
        _output.WriteLine("[流程1] 初始化 Managers...");
        
        // 初始化 ArchetypeManager
        Astrum.LogicCore.Archetypes.ArchetypeManager.Instance.Initialize();
        _output.WriteLine("  ✓ ArchetypeManager initialized");
        
        // ConfigManager 已在 ConfigFixture 中初始化
        _output.WriteLine("  ✓ ConfigManager already initialized");
        
        // 初始化 SkillEffectManager
        SkillEffectManager.Instance.ClearQueue();
        SkillEffectManager.Instance.RegisterHandler(1, new DamageEffectHandler());
        SkillEffectManager.Instance.RegisterHandler(2, new HealEffectHandler());
        _output.WriteLine("  ✓ SkillEffectManager initialized");
        
        // HitManager 使用单例，自动初始化
        _output.WriteLine("  ✓ HitManager ready");
        
        _output.WriteLine("✅ 所有 Manager 初始化完成");
    }
    
    /// <summary>
    /// 流程2: 创建 Room + World（模拟单人模式创建）
    /// </summary>
    private void CreateRoomAndWorld()
    {
        _output.WriteLine("[流程2] 创建 Room + World...");
        
        // 创建 Room（真实环境）
        Room = new Room(1, "TestRoom");
        
        // 创建 World（真实环境）
        var world = new World { WorldId = 1, Name = "TestWorld" };
        Room.MainWorld = world;
        
        // 初始化 Room（会创建 LSController）
        Room.Initialize();
        
        _output.WriteLine($"  ✓ Room created: ID={Room.RoomId}, Name={Room.Name}");
        _output.WriteLine($"  ✓ World created: ID={world.WorldId}, Name={world.Name}");
        _output.WriteLine($"  ✓ LSController created");
        _output.WriteLine("✅ Room + World 创建完成");
    }
    
    /// <summary>
    /// 步骤5: 逐帧执行测试（核心流程）
    /// 每一帧：执行输入 → 更新逻辑 → 执行查询 → 验证预期
    /// </summary>
    private bool ExecuteFrames(List<FrameData> frames)
    {
        _output.WriteLine("========== 开始逐帧执行 ==========");
        
        // 启动帧同步
        LSController.Start();
        _output.WriteLine("  ✓ LSController 已启动\n");
        
        int currentFrame = 0;
        bool allSuccess = true;
        
        foreach (var frameData in frames)
        {
            // 推进到目标帧
            while (currentFrame < frameData.FrameNumber)
            {
                UpdateLogicFrame();
                currentFrame++;
            }
            
            _output.WriteLine($"========== Frame {frameData.FrameNumber} ==========");
            _output.WriteLine($"  {frameData.Comment}");
            
            // [1] 执行输入指令
            if (frameData.Inputs != null && frameData.Inputs.Count > 0)
            {
                _output.WriteLine($"  [输入] 执行 {frameData.Inputs.Count} 个输入指令");
                foreach (var input in frameData.Inputs)
                {
                    ExecuteInput(input);
                }
            }
            
            // [2] 更新游戏逻辑一帧
            UpdateLogicFrame();
            currentFrame++;
            
            // [3] 执行查询指令
            var queryResults = new Dictionary<string, object>();
            if (frameData.Queries != null && frameData.Queries.Count > 0)
            {
                _output.WriteLine($"  [查询] 执行 {frameData.Queries.Count} 个查询指令");
                foreach (var query in frameData.Queries)
                {
                    var result = ExecuteQuery(query);
                    queryResults[query.ResultKey] = result;
                    _output.WriteLine($"    {query.ResultKey} = {result}");
                }
            }
            
            // [4] 验证预期输出
            if (frameData.ExpectedOutputs != null && frameData.ExpectedOutputs.Count > 0)
            {
                _output.WriteLine($"  [验证] 验证 {frameData.ExpectedOutputs.Count} 个预期结果");
                bool frameSuccess = VerifyExpectedOutputs(queryResults, frameData.ExpectedOutputs);
                
                if (!frameSuccess)
                {
                    _output.WriteLine($"  ❌ Frame {frameData.FrameNumber} 验证失败");
                    allSuccess = false;
                }
                else
                {
                    _output.WriteLine($"  ✅ Frame {frameData.FrameNumber} 验证通过");
                }
            }
            
            _output.WriteLine();
        }
        
        _output.WriteLine("========== 逐帧执行完成 ==========\n");
        
        return allSuccess;
    }
    
    /// <summary>
    /// 执行输入指令（包括创建实体、玩家操作、AI指令等）
    /// </summary>
    private void ExecuteInput(InputCommand input)
    {
        switch (input.Type)
        {
            case "CreateEntity":
                // 创建新实体
                if (!_entityTemplates.ContainsKey(input.TemplateId))
                {
                    throw new Exception($"实体模板不存在: {input.TemplateId}");
                }
                
                var template = _entityTemplates[input.TemplateId];
                var entity = EntityFactory.Instance.CreateEntity(template.RoleId, World);
                
                // 设置位置
                entity.GetComponent<TransComponent>().Position = input.Position.Value;
                
                // 设置自定义血量
                if (template.CustomHealth.HasValue)
                {
                    var health = entity.GetComponent<HealthComponent>();
                    health.MaxHealth = template.CustomHealth.Value;
                    health.CurrentHealth = template.CustomHealth.Value;
                }
                
                // 添加到 Room
                Room.Players.Add(entity.UniqueId);
                
                // 注册到物理世界
                HitManager.Instance.RegisterEntity(entity);
                
                // 保存到映射表
                _entities[input.EntityId] = entity;
                
                _output.WriteLine($"      创建实体: {input.EntityId} (模板={input.TemplateId}, Pos={input.Position})");
                break;
                
            case "DestroyEntity":
                if (_entities.ContainsKey(input.EntityId))
                {
                    var entityToDestroy = _entities[input.EntityId];
                    Room.Players.Remove(entityToDestroy.UniqueId);
                    HitManager.Instance.UnregisterEntity(entityToDestroy);
                    _entities.Remove(input.EntityId);
                    _output.WriteLine($"      销毁实体: {input.EntityId}");
                }
                break;
                
            case "CastSkill":
                if (!_entities.ContainsKey(input.EntityId))
                {
                    throw new Exception($"实体不存在: {input.EntityId}");
                }
                
                var caster = _entities[input.EntityId];
                var actionComp = caster.GetComponent<ActionComponent>();
                actionComp.CurrentAction = SkillConfigManager.Instance
                    .CreateSkillActionInstance(input.SkillId.Value, 1);
                actionComp.CurrentFrame = 0;
                _output.WriteLine($"      {input.EntityId} 施放技能 {input.SkillId} → {input.TargetId}");
                break;
                
            case "Move":
                if (!_entities.ContainsKey(input.EntityId))
                {
                    throw new Exception($"实体不存在: {input.EntityId}");
                }
                
                var mover = _entities[input.EntityId];
                mover.GetComponent<TransComponent>().Position = input.TargetPosition.Value;
                _output.WriteLine($"      {input.EntityId} 移动到 {input.TargetPosition}");
                break;
                
            case "Teleport":
                if (!_entities.ContainsKey(input.EntityId))
                {
                    throw new Exception($"实体不存在: {input.EntityId}");
                }
                
                var teleporter = _entities[input.EntityId];
                teleporter.GetComponent<TransComponent>().Position = input.TargetPosition.Value;
                _output.WriteLine($"      {input.EntityId} 传送到 {input.TargetPosition}");
                break;
                
            case "Wait":
                _output.WriteLine($"      等待");
                break;
        }
    }
    
    /// <summary>
    /// 执行查询指令（查询实体状态）
    /// </summary>
    private object ExecuteQuery(QueryCommand query)
    {
        if (!_entities.ContainsKey(query.EntityId))
        {
            throw new Exception($"查询的实体不存在: {query.EntityId}");
        }
        
        var entity = _entities[query.EntityId];
        
        switch (query.Type)
        {
            case "EntityHealth":
                return entity.GetComponent<HealthComponent>().CurrentHealth;
                
            case "EntityPosition":
                var pos = entity.GetComponent<TransComponent>().Position;
                return new { x = (float)pos.x, y = (float)pos.y, z = (float)pos.z };
                
            case "EntityIsAlive":
                return entity.GetComponent<HealthComponent>().CurrentHealth > 0;
                
            case "EntityAction":
                var actionComp = entity.GetComponent<ActionComponent>();
                return actionComp.CurrentAction != null ? "CastingSkill" : "Idle";
                
            case "EntityDistance":
                if (!string.IsNullOrEmpty(query.TargetId))
                {
                    if (!_entities.ContainsKey(query.TargetId))
                    {
                        throw new Exception($"目标实体不存在: {query.TargetId}");
                    }
                    
                    var targetEntity = _entities[query.TargetId];
                    var pos1 = entity.GetComponent<TransComponent>().Position;
                    var pos2 = targetEntity.GetComponent<TransComponent>().Position;
                    return (float)TSVector.Distance(pos1, pos2);
                }
                return 0f;
                
            default:
                throw new NotImplementedException($"查询类型未实现: {query.Type}");
        }
    }
    
    /// <summary>
    /// 验证预期输出
    /// </summary>
    private bool VerifyExpectedOutputs(Dictionary<string, object> queryResults, Dictionary<string, object> expectedOutputs)
    {
        bool allMatch = true;
        
        foreach (var expected in expectedOutputs)
        {
            var key = expected.Key;
            var expectedValue = expected.Value;
            
            if (!queryResults.ContainsKey(key))
            {
                _output.WriteLine($"      ❌ 缺少查询结果: {key}");
                allMatch = false;
                continue;
            }
            
            var actualValue = queryResults[key];
            
            // 支持范围验证（min/max）
            if (expectedValue is Dictionary<string, object> range && range.ContainsKey("min"))
            {
                int actual = Convert.ToInt32(actualValue);
                int min = Convert.ToInt32(range["min"]);
                int max = range.ContainsKey("max") ? Convert.ToInt32(range["max"]) : int.MaxValue;
                
                if (actual < min || actual > max)
                {
                    _output.WriteLine($"      ❌ {key}: 期望 [{min}, {max}], 实际 {actual}");
                    allMatch = false;
                }
                else
                {
                    _output.WriteLine($"      ✓ {key}: {actual} (在范围内)");
                }
            }
            // 精确匹配
            else
            {
                if (!actualValue.Equals(expectedValue))
                {
                    _output.WriteLine($"      ❌ {key}: 期望 {expectedValue}, 实际 {actualValue}");
                    allMatch = false;
                }
                else
                {
                    _output.WriteLine($"      ✓ {key}: {actualValue}");
                }
            }
        }
        
        return allMatch;
    }
    
    /// <summary>
    /// 旧方法（废弃，保留用于参考）
    /// </summary>
    private void OldExecuteLogicSequence()
    {
        // foreach (var action in sequence)
        // {
            // 等待到指定帧
            while (LSController.PredictionFrame < action.Frame)
            {
                UpdateLogicFrame();
            }
            
            _output.WriteLine($"  Frame {action.Frame}: {action.Comment}");
            
            // 执行动作（使用真实的 Entity）
            var entity = _entities[action.EntityIndex];
            ExecuteAction(entity, action);
            
            // 更新几帧让动作生效
            UpdateLogicFrames(10);
        }
        
        _output.WriteLine("✅ 逻辑序列执行完成");
    }
    
    /// <summary>
    /// 执行单个动作（真实的游戏逻辑）
    /// </summary>
    private void ExecuteAction(Entity entity, LogicAction action)
    {
        switch (action.Action)
        {
            case "CastSkill":
                var actionComp = entity.GetComponent<ActionComponent>();
                actionComp.CurrentAction = SkillConfigManager.Instance
                    .CreateSkillActionInstance(action.ActionId, 1);
                actionComp.CurrentFrame = 0;
                
                // 触发技能执行器
                for (int frame = 0; frame < 20; frame++)
                {
                    actionComp.CurrentFrame = frame;
                    var executor = entity.Capabilities.Find(c => c is SkillExecutorCapability) as SkillExecutorCapability;
                    executor?.Tick();
                    UpdateLogicFrame();
                }
                break;
                
            case "Move":
                entity.GetComponent<TransComponent>().Position = action.TargetPosition;
                break;
        }
    }
    
    /// <summary>
    /// 流程6: 收集测试结果
    /// </summary>
    private TestResult CollectResult(TestCaseData testCase)
    {
        _output.WriteLine("[流程6] 收集测试结果...");
        
        var result = new TestResult
        {
            TestCaseName = testCase.Name,
            Entities = _entities,
            FinalFrame = LSController.PredictionFrame
        };
        
        // 收集所有实体的最终状态
        foreach (var entity in _entities)
        {
            var health = entity.GetComponent<HealthComponent>();
            result.EntityStates.Add(new EntityState
            {
                Entity = entity,
                FinalHealth = health.CurrentHealth,
                Position = entity.GetComponent<TransComponent>().Position
            });
            
            _output.WriteLine($"  Entity {entity.UniqueId}: HP={health.CurrentHealth}, Pos={entity.GetComponent<TransComponent>().Position}");
        }
        
        _output.WriteLine("✅ 结果收集完成");
        
        return result;
    }
    
    // ========== 辅助方法 ==========
    
    /// <summary>
    /// 更新单帧逻辑（模拟单人模式 Update）
    /// </summary>
    private void UpdateLogicFrame()
    {
        // 模拟单人模式：AuthorityFrame = PredictionFrame
        if (LSController != null && LSController.IsRunning)
        {
            LSController.AuthorityFrame = LSController.PredictionFrame;
        }
        
        // Room.Update() → LSController.Tick() → World.Update()
        Room.Update(0.016f);  // 60FPS
    }
    
    /// <summary>
    /// 更新多帧
    /// </summary>
    private void UpdateLogicFrames(int count)
    {
        for (int i = 0; i < count; i++)
        {
            UpdateLogicFrame();
        }
    }
    
    public void Dispose()
    {
        SkillEffectManager.Instance?.ClearQueue();
        _entities.Clear();
        _output.WriteLine("✅ 测试执行引擎已清理");
    }
}
```

##### LogicTestFixture.cs（简化版）

```csharp
/// <summary>
/// 逻辑测试 Fixture - 提供真实的游戏逻辑环境
/// 完全模拟单人模式的 Room + World + LSController
/// </summary>
public class LogicTestFixture : IDisposable
{
    public Room Room { get; private set; }
    public World World => Room.MainWorld;
    public LSController LSController => Room.LSController;
    public ITestOutputHelper Output { get; }
    
    public LogicTestFixture(ITestOutputHelper output, ConfigFixture configFixture)
    {
        Output = output;
        InitializeLogicEnvironment();
    }
    
    /// <summary>
    /// 初始化逻辑环境（模拟单人模式启动）
    /// </summary>
    private void InitializeLogicEnvironment()
    {
        // 1. 初始化必要的管理器
        Astrum.LogicCore.Archetypes.ArchetypeManager.Instance.Initialize();
        
        // 2. 创建 Room（真实环境）
        Room = new Room(1, "TestRoom");
        
        // 3. 创建 World（真实环境）
        var world = new World { WorldId = 1, Name = "TestWorld" };
        Room.MainWorld = world;
        
        // 4. 初始化 Room（创建 LSController）
        Room.Initialize();
        
        // 5. 初始化技能效果系统
        SkillEffectManager.Instance.ClearQueue();
        RegisterSkillHandlers();
        
        Output.WriteLine("✅ 逻辑测试环境初始化完成");
    }
    
    private void RegisterSkillHandlers()
    {
        SkillEffectManager.Instance.RegisterHandler(1, new DamageEffectHandler());
        SkillEffectManager.Instance.RegisterHandler(2, new HealEffectHandler());
    }
    
    public void Dispose()
    {
        SkillEffectManager.Instance?.ClearQueue();
        Output.WriteLine("✅ 逻辑测试环境清理完成");
    }
}

/// <summary>
/// 逻辑测试集合定义
/// </summary>
[CollectionDefinition("Logic Test Collection")]
public class LogicTestCollection : ICollectionFixture<ConfigFixture>, ICollectionFixture<LogicTestFixture>
{
}
```

##### LogicFrameDriver.cs

```csharp
/// <summary>
/// 逻辑帧驱动器 - 模拟真实的游戏帧循环
/// 完全复制单人模式的 Update 逻辑
/// </summary>
public static class LogicFrameDriver
{
    /// <summary>
    /// 更新逻辑帧（模拟 SinglePlayerGameMode.Update + Room.Update）
    /// </summary>
    public static void UpdateFrame(Room room, float deltaTime = 0.016f)
    {
        // 模拟单人模式：AuthorityFrame = PredictionFrame
        if (room.LSController != null && room.LSController.IsRunning)
        {
            room.LSController.AuthorityFrame = room.LSController.PredictionFrame;
        }
        
        // Room.Update() → LSController.Tick() → World.Update()
        room.Update(deltaTime);
    }
    
    /// <summary>
    /// 更新多帧
    /// </summary>
    public static void UpdateFrames(Room room, int frameCount)
    {
        for (int i = 0; i < frameCount; i++)
        {
            UpdateFrame(room);
        }
    }
    
    /// <summary>
    /// 模拟玩家输入（通过 Room.FrameTick）
    /// </summary>
    public static void SimulateInput(Room room, long playerId, LSInput input)
    {
        var frameInputs = new OneFrameInputs
        {
            Frame = room.LSController.PredictionFrame,
            Inputs = new Dictionary<long, LSInput>
            {
                { playerId, input }
            }
        };
        
        room.FrameTick(frameInputs);
    }
}
```

##### DataLoader.cs

```csharp
/// <summary>
/// 测试数据加载器 - 从 JSON 加载测试场景
/// </summary>
public static class DataLoader
{
    /// <summary>
    /// 加载测试场景配置
    /// </summary>
    public static ScenarioData LoadScenario(string scenarioName)
    {
        var path = Path.Combine(
            AppContext.BaseDirectory,
            "Data", "Scenarios", $"{scenarioName}.json"
        );
        
        var json = File.ReadAllText(path);
        return JsonConvert.DeserializeObject<ScenarioData>(json);
    }
    
    /// <summary>
    /// 从场景数据创建实体（使用真实的 EntityFactory）
    /// </summary>
    public static List<Entity> CreateEntitiesFromScenario(
        ScenarioData scenario, 
        World world,
        ITestOutputHelper output)
    {
        var entities = new List<Entity>();
        
        foreach (var entityConfig in scenario.Entities)
        {
            // 使用真实的 EntityFactory
            var entity = EntityFactory.Instance.CreateEntity(entityConfig.RoleId, world);
            
            // 设置真实的组件
            entity.GetComponent<TransComponent>().Position = entityConfig.Position;
            
            // 如果有自定义血量
            if (entityConfig.CustomHealth.HasValue)
            {
                var health = entity.GetComponent<HealthComponent>();
                health.MaxHealth = entityConfig.CustomHealth.Value;
                health.CurrentHealth = entityConfig.CustomHealth.Value;
            }
            
            // 注册到真实的物理管理器
            HitManager.Instance.RegisterEntity(entity);
            
            entities.Add(entity);
            
            output.WriteLine($"创建实体: RoleId={entityConfig.RoleId}, Pos={entityConfig.Position}");
        }
        
        return entities;
    }
}
```

##### Assertions/EntityAssert.cs

```csharp
/// <summary>
/// 实体断言工具 - 接受真实的 Entity 对象
/// </summary>
public static class EntityAssert
{
    /// <summary>
    /// 断言实体血量减少
    /// </summary>
    public static void HealthDecreased(Entity entity, int initialHealth, int minDamage = 1)
    {
        var currentHealth = entity.GetComponent<HealthComponent>().CurrentHealth;
        var damageTaken = initialHealth - currentHealth;
        
        Assert.True(
            damageTaken >= minDamage,
            $"实体 {entity.UniqueId} 应该受到至少 {minDamage} 点伤害，实际: {damageTaken}"
        );
    }
    
    /// <summary>
    /// 断言实体死亡
    /// </summary>
    public static void IsDead(Entity entity)
    {
        var health = entity.GetComponent<HealthComponent>().CurrentHealth;
        Assert.True(health <= 0, $"实体 {entity.UniqueId} 应该已死亡，当前血量: {health}");
    }
    
    /// <summary>
    /// 断言实体存活
    /// </summary>
    public static void IsAlive(Entity entity)
    {
        var health = entity.GetComponent<HealthComponent>().CurrentHealth;
        Assert.True(health > 0, $"实体 {entity.UniqueId} 应该存活，当前血量: {health}");
    }
    
    /// <summary>
    /// 断言实体在范围内
    /// </summary>
    public static void InRange(Entity entity, TSVector center, FP radius)
    {
        var pos = entity.GetComponent<TransComponent>().Position;
        var distance = TSVector.Distance(pos, center);
        
        Assert.True(
            distance <= radius,
            $"实体 {entity.UniqueId} 应该在 {center} 的 {radius} 范围内，实际距离: {distance}"
        );
    }
}
```

---

## 四、目录结构

### 4.1 完整目录结构

```plaintext
AstrumTest.Shared/
│
├── Unit/                          # 单元测试 + 组件测试
│   ├── Physics/
│   │   ├── TypeConverterTests.cs         [TestLevel=Unit]
│   │   └── HitManagerTests.cs            [TestLevel=Component]
│   ├── Serialization/
│   │   └── ProtocolSerializationTests.cs [TestLevel=Unit]
│   └── ...
│
├── Integration/                   # 集成测试
│   │
│   ├── Core/                     # 层次1: 核心测试引擎（通用）
│   │   ├── LogicTestFixture.cs           # 逻辑测试 Fixture
│   │   ├── LogicFrameDriver.cs           # 帧驱动器（通用）
│   │   ├── DataLoader.cs                 # 数据加载器（通用）
│   │   ├── LogicRecorder.cs              # 逻辑记录器（可选）
│   │   └── Assertions/                   # 断言工具（通用）
│   │       ├── EntityAssert.cs
│   │       ├── ComponentAssert.cs
│   │       ├── SkillAssert.cs
│   │       ├── PhysicsAssert.cs
│   │       └── WorldAssert.cs
│   │
│   ├── Cases/                    # 层次2: 测试用例（具体场景）
│   │   ├── CombatLogicTests.cs           # 战斗逻辑测试
│   │   ├── MovementLogicTests.cs         # 移动逻辑测试
│   │   ├── SkillSystemFlowTests.cs       # 技能系统流程测试
│   │   ├── PhysicsInteractionTests.cs    # 物理交互测试
│   │   └── MultiEntityTests.cs           # 多实体交互测试
│   │
│   └── Data/                     # 层次3: 测试数据
│       ├── Scenarios/            # 场景配置
│       │   ├── TwoKnightsFight.json
│       │   ├── MageVsArcher.json
│       │   └── MultiPlayerBattle.json
│       ├── Inputs/               # 输入序列
│       │   ├── BasicAttackSequence.json
│       │   └── SkillComboSequence.json
│       └── Expected/             # 预期结果
│           ├── TwoKnightsFight_Expected.json
│           └── SkillCombo_Expected.json
│
└── Fixtures/
    ├── ConfigFixture.cs          # 配置 Fixture
    └── SharedTestScenario.cs     # 共享测试场景（单元/组件测试用）
```

---

## 五、使用示例

### 5.1 使用测试执行引擎（数据驱动）

**核心优势：用户只传 JSON 文件名，完全不写初始化代码**

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
[Trait("Module", "Combat")]
public class CombatLogicTests
{
    private readonly ITestOutputHelper _output;
    private readonly ConfigFixture _configFixture;
    
    public CombatLogicTests(ITestOutputHelper output, ConfigFixture configFixture)
    {
        _output = output;
        _configFixture = configFixture;
    }
    
    [Theory]
    [InlineData("TwoKnightsFight.json")]
    [InlineData("KnightVsMage.json")]
    [InlineData("MultiTargetSkill.json")]
    public void RunCombatScenario(string scenarioFile)
    {
        // 创建执行引擎
        using var executor = new LogicTestExecutor(_output, _configFixture);
        
        // 核心流程自动完成：读取 → 初始化 → 执行 → 验证 → 报告
        var result = executor.RunTestCase(scenarioFile);
        
        // 结果已自动验证（根据 JSON 中的 ExpectedResults）
        Assert.True(result.Success, result.FailureMessage);
    }
    
    [Fact]
    public void TwoKnights_BasicAttack()
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        
        // 只需要传文件名！
        var result = executor.RunTestCase("TwoKnights_BasicAttack.json");
        
        Assert.True(result.Success);
    }
}
```

**执行流程自动化（完全数据驱动）：**
```plaintext
executor.RunTestCase("TwoKnightsFight.json") 自动执行：

========================================
运行测试用例: TwoKnightsFight.json
========================================
[1/7] ✓ 读取测试用例: 两个骑士战斗
  测试用例: 两个骑士战斗
  实体数量: 2
  逻辑步骤: 3
  
[2/7] ✓ Manager 初始化完成
  ✓ ArchetypeManager initialized
  ✓ SkillEffectManager initialized
  ✓ HitManager ready
  
[3/7] ✓ Room + World 创建完成
  ✓ Room created: ID=1
  ✓ World created: ID=1
  ✓ LSController created
  
[4/7] ✓ 创建了 2 个实体
  ✓ Entity 0: RoleId=1001, HP=500
  ✓ Entity 1: RoleId=1001, HP=500
  
[5/7] ✓ 逻辑序列执行完成
  Frame 10: 骑士1 施放技能 3001
  Frame 50: 等待技能结束
  Frame 60: 验证伤害
  
[6/7] ✓ 结果验证完成
  ✓ Entity 1 血量减少: 500 → 450
  ✓ Entity 1 存活: true
  
[7/7] ✓ 测试报告生成
========================================
✅ 测试通过: 两个骑士战斗
========================================
```

### 5.2 批量测试场景

**一个测试方法运行多个场景**

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
public class IntegrationTests
{
    private readonly ITestOutputHelper _output;
    private readonly ConfigFixture _configFixture;
    
    public IntegrationTests(ITestOutputHelper output, ConfigFixture configFixture)
    {
        _output = output;
        _configFixture = configFixture;
    }
    
    /// <summary>
    /// 战斗场景测试
    /// </summary>
    [Theory]
    [InlineData("Combat_TwoKnights.json")]
    [InlineData("Combat_MageVsArcher.json")]
    [InlineData("Combat_MultiTarget.json")]
    [InlineData("Combat_AoESkill.json")]
    public void Combat_Scenarios(string scenarioFile)
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        var result = executor.RunTestCase(scenarioFile);
        Assert.True(result.Success, result.FailureMessage);
    }
    
    /// <summary>
    /// 移动场景测试
    /// </summary>
    [Theory]
    [InlineData("Movement_BasicMove.json")]
    [InlineData("Movement_Teleport.json")]
    [InlineData("Movement_Dash.json")]
    public void Movement_Scenarios(string scenarioFile)
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        var result = executor.RunTestCase(scenarioFile);
        Assert.True(result.Success);
    }
    
    /// <summary>
    /// 物理交互测试
    /// </summary>
    [Theory]
    [InlineData("Physics_Collision.json")]
    [InlineData("Physics_Knockback.json")]
    public void Physics_Scenarios(string scenarioFile)
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        var result = executor.RunTestCase(scenarioFile);
        Assert.True(result.Success);
    }
}
```

**对比：核心流程封装 vs 手动编写**

```csharp
// ❌ 旧方式：用户可以绕过核心流程，每次都重写初始化
[Fact]
public void Test1()
{
    // 用户自己初始化（50+ 行重复代码）
    ArchetypeManager.Instance.Initialize();
    SkillEffectManager.Instance.ClearQueue();
    
    Room room = new Room(1, "Test");
    World world = new World();
    room.MainWorld = world;
    room.Initialize();
    
    var e1 = EntityFactory.Instance.CreateEntity(1001, world);
    e1.GetComponent<TransComponent>().Position = TSVector.zero;
    room.Players.Add(e1.UniqueId);
    HitManager.Instance.RegisterEntity(e1);
    
    room.LSController.Start();
    
    // 执行测试逻辑...
    // 验证结果...
}

[Fact]
public void Test2()
{
    // 又要写一遍所有初始化代码（50+ 行）！
    ArchetypeManager.Instance.Initialize();
    // ...
}

// ✅ 新方式：核心流程完全封装，用户只传文件名
[Fact]
public void Test1()
{
    using var executor = new LogicTestExecutor(_output, _configFixture);
    
    // 只传文件名，核心流程自动完成：
    // 读取JSON → 初始化 → 创建实体 → 执行 → 验证 → 报告
    var result = executor.RunTestCase("Scenario1.json");
    
    Assert.True(result.Success);  // ← 1 行
}

[Fact]
public void Test2()
{
    using var executor = new LogicTestExecutor(_output, _configFixture);
    var result = executor.RunTestCase("Scenario2.json");  // ← 1 行
    Assert.True(result.Success);  // ← 1 行
}

// 对比：
// 旧方式：每个测试 50+ 行（重复初始化）
// 新方式：每个测试 3 行（只传文件名）
// 节省：~95% 代码量，用户无法绕过核心流程
```

---

## 六、数据格式定义（以帧为单位）

### 6.1 核心设计思想

**以帧为核心单位组织测试**
```plaintext
每一帧的执行流程：
  1. 执行输入指令（inputs）      ← 玩家操作、AI指令等
  2. 更新游戏逻辑一帧            ← Room.Update() / LSController.Tick()
  3. 执行查询指令（queries）     ← 查询实体状态
  4. 验证预期输出（expectedOutputs）← 断言验证

优势：
  ✓ 逐帧验证，精确定位问题
  ✓ 可以在任意帧进行断言
  ✓ 贴近真实游戏循环
  ✓ 更细粒度的测试控制
```

### 6.2 场景配置格式（Frame-Based）

```json
// Data/Scenarios/TwoKnightsFight.json
{
  "name": "两个骑士对战",
  "description": "测试基础战斗逻辑 - 逐帧验证",
  
  "entityTemplates": [
    {
      "templateId": "knight1",
      "roleId": 1001,
      "team": 1,
      "customHealth": 500
    },
    {
      "templateId": "knight2",
      "roleId": 1001,
      "team": 2,
      "customHealth": 500
    }
  ],
  
  "frames": [
    {
      "frameNumber": 0,
      "comment": "创建两个骑士",
      "inputs": [
        {
          "type": "CreateEntity",
          "templateId": "knight1",
          "position": {"x": 0, "y": 0, "z": 0},
          "entityId": "entity_0"
        },
        {
          "type": "CreateEntity",
          "templateId": "knight2",
          "position": {"x": 1.2, "y": 0, "z": 0},
          "entityId": "entity_1"
        }
      ],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "entity_0",
          "resultKey": "knight1_hp"
        },
        {
          "type": "EntityHealth",
          "entityId": "entity_1",
          "resultKey": "knight2_hp"
        }
      ],
      "expectedOutputs": {
        "knight1_hp": 500,
        "knight2_hp": 500
      }
    },
    {
      "frameNumber": 10,
      "comment": "骑士1开始攻击",
      "inputs": [
        {
          "type": "CastSkill",
          "entityId": "entity_0",
          "skillId": 3001,
          "targetId": "entity_1"
        }
      ],
      "queries": [
        {
          "type": "EntityAction",
          "entityId": "entity_0",
          "resultKey": "knight1_action"
        }
      ],
      "expectedOutputs": {
        "knight1_action": "CastingSkill"
      }
    },
    {
      "frameNumber": 30,
      "comment": "技能命中，验证伤害",
      "inputs": [],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "entity_1",
          "resultKey": "knight2_hp"
        },
        {
          "type": "EntityIsAlive",
          "entityId": "entity_1",
          "resultKey": "knight2_alive"
        }
      ],
      "expectedOutputs": {
        "knight2_hp": {"min": 400, "max": 470},
        "knight2_alive": true
      }
    },
    {
      "frameNumber": 60,
      "comment": "骑士2反击",
      "inputs": [
        {
          "type": "CastSkill",
          "entityId": "entity_1",
          "skillId": 3001,
          "targetId": "entity_0"
        }
      ],
      "queries": [
        {
          "type": "EntityAction",
          "entityId": "entity_1",
          "resultKey": "knight2_action"
        }
      ],
      "expectedOutputs": {
        "knight2_action": "CastingSkill"
      }
    },
    {
      "frameNumber": 80,
      "comment": "反击命中，验证双方血量",
      "inputs": [],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "entity_0",
          "resultKey": "knight1_hp"
        },
        {
          "type": "EntityHealth",
          "entityId": "entity_1",
          "resultKey": "knight2_hp"
        },
        {
          "type": "EntityIsAlive",
          "entityId": "entity_0",
          "resultKey": "knight1_alive"
        },
        {
          "type": "EntityIsAlive",
          "entityId": "entity_1",
          "resultKey": "knight2_alive"
        }
      ],
      "expectedOutputs": {
        "knight1_hp": {"min": 400, "max": 470},
        "knight2_hp": {"min": 400, "max": 470},
        "knight1_alive": true,
        "knight2_alive": true
      }
    },
    {
      "frameNumber": 100,
      "comment": "运行时动态召唤怪物（演示）",
      "inputs": [
        {
          "type": "CreateEntity",
          "templateId": "knight1",
          "position": {"x": 5, "y": 0, "z": 0},
          "entityId": "summoned_1"
        }
      ],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "summoned_1",
          "resultKey": "summoned_hp"
        }
      ],
      "expectedOutputs": {
        "summoned_hp": 500
      }
    }
  ]
}
```

### 6.3 支持的查询类型（Queries）

```csharp
// 查询类型枚举
public enum QueryType
{
    EntityHealth,       // 查询实体血量
    EntityPosition,     // 查询实体位置
    EntityIsAlive,      // 查询实体是否存活
    EntityAction,       // 查询实体当前动作
    EntityVelocity,     // 查询实体速度
    EntityBuffCount,    // 查询实体Buff数量
    EntityDistance,     // 查询两个实体距离
    // 可扩展...
}
```

### 6.4 支持的输入类型（Inputs）

```csharp
// 输入类型枚举
public enum InputType
{
    CreateEntity,       // 创建实体（新增！）
    DestroyEntity,      // 销毁实体
    CastSkill,          // 释放技能
    Move,               // 移动
    Teleport,           // 传送
    UseItem,            // 使用物品
    Wait,               // 等待（无操作）
    // 可扩展...
}
```

**核心改动：实体创建也是输入指令**
- 不再在测试开始时预创建所有实体
- 实体通过 `CreateEntity` 输入指令在指定帧创建
- 支持运行时动态创建（召唤物、怪物刷新等）
- 每个实体有唯一的 `entityId`（字符串标识符）

### 6.5 数据类定义

```csharp
// Core/TestCaseData.cs
public class TestCaseData
{
    public string Name { get; set; }
    public string Description { get; set; }
    public List<EntityTemplate> EntityTemplates { get; set; }  // ← 实体模板定义
    public List<FrameData> Frames { get; set; }                // ← 核心：以帧为单位
}

/// <summary>
/// 实体模板 - 定义实体的配置模板
/// 通过 CreateEntity 输入指令创建实例
/// </summary>
public class EntityTemplate
{
    public string TemplateId { get; set; }  // 模板ID（如 "knight1", "boss1"）
    public int RoleId { get; set; }
    public int Team { get; set; }
    public int? CustomHealth { get; set; }
    // 可扩展其他属性...
}

/// <summary>
/// 帧数据 - 测试的核心单位
/// 每一帧包含：输入 → 查询 → 预期输出
/// </summary>
public class FrameData
{
    public int FrameNumber { get; set; }             // 帧号
    public string Comment { get; set; }              // 注释（用于说明这一帧做什么）
    public List<InputCommand> Inputs { get; set; }   // 输入指令（这一帧要执行的操作）
    public List<QueryCommand> Queries { get; set; }  // 查询指令（帧执行完后查询数据）
    public Dictionary<string, object> ExpectedOutputs { get; set; }  // 预期输出（验证）
}

/// <summary>
/// 输入指令（玩家操作、AI指令、实体创建等）
/// </summary>
public class InputCommand
{
    public string Type { get; set; }  // "CreateEntity", "CastSkill", "Move", etc.
    
    // 实体标识（字符串ID，如 "entity_0", "boss_1"）
    public string EntityId { get; set; }
    
    // 创建实体相关
    public string TemplateId { get; set; }  // 引用 EntityTemplate 的 TemplateId
    public TSVector? Position { get; set; }
    
    // 技能相关
    public int? SkillId { get; set; }
    public string TargetId { get; set; }  // 目标实体ID
    
    // 移动相关
    public TSVector? TargetPosition { get; set; }
    public TSVector? Direction { get; set; }
    
    // 物品相关
    public int? ItemId { get; set; }
}

/// <summary>
/// 查询指令（查询实体状态）
/// </summary>
public class QueryCommand
{
    public string Type { get; set; }       // "EntityHealth", "EntityPosition", "EntityIsAlive", etc.
    public string EntityId { get; set; }   // 查询哪个实体（字符串ID）
    public string TargetId { get; set; }   // 可选：第二个实体（用于距离查询等）
    public string ResultKey { get; set; }  // 结果键（用于匹配 ExpectedOutputs）
}
```

---

## 七、测试用例示例

### 7.1 战斗逻辑测试

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
public class CombatLogicTests
{
    private readonly LogicTestFixture _fixture;
    
    [Fact]
    public void Combat_TwoKnights_FullFlow()
    {
        // 完全使用真实环境
        Room room = _fixture.Room;
        World world = _fixture.World;
        
        // 创建实体
        Entity k1 = EntityFactory.Instance.CreateEntity(1001, world);
        Entity k2 = EntityFactory.Instance.CreateEntity(1001, world);
        
        // ... 测试逻辑
    }
}
```

### 7.2 移动逻辑测试

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
public class MovementLogicTests
{
    [Fact]
    public void Movement_PathFollowing()
    {
        // 测试移动系统
    }
}
```

### 7.3 技能系统测试

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
public class SkillSystemFlowTests
{
    [Fact]
    public void SkillChain_Execution()
    {
        // 测试技能链执行
    }
}
```

---

## 八、核心设计要点

### 8.1 固定流程引擎设计（数据驱动）

**核心：RunTestCase(jsonFile) - 用户无法绕过**

```plaintext
┌──────────────────────────────────────────────┐
│ LogicTestExecutor.RunTestCase(jsonFile)      │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │ [1] 读取 JSON 用例文件               │ │ ← 固定流程
│  │  - LoadTestCaseFromJson()            │ │   用户只传文件名
│  │  - 解析 TestCaseData                 │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [2] 初始化所有 Manager               │ │ ← 固定流程
│  │  - ArchetypeManager                  │ │   只执行一次
│  │  - SkillEffectManager                │ │
│  │  - HitManager                        │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [3] 创建 Room + World                │ │ ← 固定流程
│  │  - new Room()                        │ │   每次测试都执行
│  │  - new World()                       │ │
│  │  - room.Initialize()                 │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [4] 根据 JSON 创建实体               │ │ ← JSON 数据驱动
│  │  - CreateEntitiesFromJson()          │ │
│  │  - EntityFactory.CreateEntity()      │ │
│  │  - 设置组件、注册物理                │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [5] 根据 JSON 执行逻辑序列           │ │ ← JSON 数据驱动
│  │  - ExecuteLogicSequenceFromJson()    │ │
│  │  - CastSkill / Move / Wait           │ │
│  │  - 帧更新                            │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [6] 根据 JSON 验证结果               │ │ ← JSON 数据驱动
│  │  - VerifyResultsFromJson()           │ │
│  │  - 自动断言（血量、位置等）          │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│  ┌────────────────────────────────────────┐ │
│  │ [7] 生成测试报告                     │ │ ← 固定流程
│  │  - GenerateReport()                  │ │
│  │  - Success / Failure                 │ │
│  └────────────────────────────────────────┘ │
│            ↓                                 │
│       返回 TestResult                        │
└──────────────────────────────────────────────┘

用户代码：
  executor.RunTestCase("Scenario.json");  // ← 只需 1 行
  
引擎自动完成所有步骤，用户无法跳过或绕过核心流程
```

### 8.2 通用性保证

**核心引擎场景无关**
- ✅ `LogicTestExecutor` - 可测试任何逻辑场景
  - 战斗测试 - 提供战斗数据
  - 移动测试 - 提供移动数据
  - AI测试 - 提供AI行为数据
  - 物理测试 - 提供物理交互数据

**测试用例只提供数据**
- 实体配置（EntityConfigs）
- 逻辑序列（LogicSequence）
- 预期结果（ExpectedResults）

### 8.3 核心价值：完全数据驱动

**用户维护 JSON，不维护测试代码**

```plaintext
❌ 传统方式（用户可以绕过核心流程）：
   每个测试方法都要写：
   1. 初始化 4-5 个 Manager     (~10行)
   2. 创建 Room + World          (~8行)
   3. 创建 Entity                (~10行/实体)
   4. 注册物理、设置组件         (~5行/实体)
   5. 启动 LSController          (~2行)
   6. 帧更新循环                 (~10行)
   7. 验证结果                   (~5行)
   
   总计：每个测试 50+ 行代码
   问题：用户容易跳过某些步骤，导致不一致
   
✅ 数据驱动方式（用户无法绕过核心流程）：
   每个测试方法只要写：
   1. executor.RunTestCase("File.json")   (1行)
   2. Assert.True(result.Success)         (1行)
   
   总计：每个测试 2 行代码
   
   测试数据在 JSON 文件中：
   {
     "name": "两个骑士战斗",
     "entities": [...],
     "logicSequence": [...],
     "expectedResults": [...]
   }
   
优势：
  - 节省 ~96% 代码量（50+ 行 → 2 行）
  - 用户无法跳过核心流程
  - 测试用例由 JSON 管理，易于维护和复用
  - 非程序员也能编写测试用例
```

### 8.4 真实性保证

**LogicTestExecutor 内部 100% 使用生产代码**

```csharp
// LogicTestExecutor 内部实现：
Room room = new Room(1, "TestRoom");              // ← 真实 Room
World world = new World();                        // ← 真实 World
room.MainWorld = world;
room.Initialize();                                // ← 真实初始化

Entity entity = EntityFactory.Instance            // ← 真实 EntityFactory
    .CreateEntity(roleId, world);
    
entity.GetComponent<HealthComponent>()            // ← 真实 Component

room.Update(0.016f);                              // ← 真实游戏循环
```

### 8.5 可扩展性

**轻松添加新测试场景**

```csharp
// 战斗测试
[Fact]
public void Combat_Test()
{
    using var executor = new LogicTestExecutor(_output, _configFixture);
    var testCase = new TestCaseData { /* 战斗数据 */ };
    var result = executor.Execute(testCase);
}

// 移动测试（复用同一个引擎）
[Fact]
public void Movement_Test()
{
    using var executor = new LogicTestExecutor(_output, _configFixture);
    var testCase = new TestCaseData { /* 移动数据 */ };
    var result = executor.Execute(testCase);
}

// AI测试（复用同一个引擎）
[Fact]
public void AI_Test()
{
    using var executor = new LogicTestExecutor(_output, _configFixture);
    var testCase = new TestCaseData { /* AI数据 */ };
    var result = executor.Execute(testCase);
}
```

---

## 九、实施计划

### 第一阶段：核心引擎（优先）

1. ✅ 创建 `Integration/Core/LogicTestFixture.cs`
2. ✅ 创建 `Integration/Core/LogicFrameDriver.cs`
3. ✅ 创建 `Integration/Core/Assertions/EntityAssert.cs`

### 第二阶段：第一个测试用例

4. ✅ 创建 `Integration/Cases/CombatLogicTests.cs`
5. ✅ 编写第一个真实环境测试

### 第三阶段：数据驱动

6. ⭕ 创建 `Integration/Core/DataLoader.cs`
7. ⭕ 定义数据格式
8. ⭕ 创建示例数据文件

### 第四阶段：扩展

9. ⭕ 添加更多断言工具
10. ⭕ 添加 LogicRecorder（可选）
11. ⭕ 添加更多测试用例

---

## 十、关键优势

### 10.1 与单人模式的对应关系

| 单人模式 | 集成测试 | 说明 |
|---------|---------|------|
| `SinglePlayerGameMode.CreateRoom()` | `LogicTestFixture.Initialize()` | 创建 Room + World |
| `Room.Update(deltaTime)` | `LogicFrameDriver.UpdateFrame(room)` | 逻辑更新 |
| `Room.AddPlayer()` | `room.Players.Add(entity.UniqueId)` | 添加玩家 |
| `EntityFactory.CreateEntity()` | `EntityFactory.CreateEntity()` | 完全相同 |
| `LSController.Start()` | `fixture.LSController.Start()` | 完全相同 |

### 10.2 通用性

**核心引擎可以测试任何逻辑场景：**
- ✅ 战斗系统
- ✅ 移动系统
- ✅ AI系统
- ✅ 技能系统
- ✅ 物理交互
- ✅ 多玩家协同
- ✅ 帧同步逻辑

**只需要：**
- 使用 `LogicTestFixture` 初始化环境
- 使用 `LogicFrameDriver` 驱动帧更新
- 使用 `Assertions/*` 验证结果

---

## 十一、与单元测试的区别

| 维度 | 单元/组件测试 | 集成测试 |
|------|--------------|----------|
| **范围** | 单个类/模块 | Room + World + 所有系统 |
| **环境** | 最小化依赖 | 完整的游戏逻辑环境 |
| **示例** | `HitManagerTests` | `CombatLogicTests` |
| **速度** | 快（<100ms） | 慢（>100ms） |
| **目的** | 验证单个功能 | 验证完整流程 |

---

**设计完成，等待审批和实施！** 📋

