# AstrumTest 项目改进方案

## 📋 问题总结

### 当前存在的问题
1. **测试框架混用** - 同时使用 Xunit 和 NUnit
2. **单例状态污染** - ConfigManager、ArchetypeManager 等单例在测试间共享
3. **测试文件管理混乱** - 大量 .bak 文件，测试散落在不同目录
4. **缺少隔离机制** - 测试间相互影响，一个失败导致连锁失败
5. **项目结构重复** - 存在两个 AstrumTest.csproj

---

## 🎯 推荐方案：按领域拆分 + 统一框架

### 方案架构

```
AstrumTest/
├── AstrumTest.Common/              # 通用测试基础设施
│   ├── TestBase.cs                 # 测试基类
│   ├── TestFixture.cs              # Fixture 模式
│   └── Mocks/                      # Mock 对象
│
├── AstrumTest.Logic/               # 逻辑层测试（独立项目）
│   ├── SkillSystemTests.cs
│   ├── EntitySystemTests.cs
│   └── PhysicsTests/
│       ├── TypeConverterTests.cs
│       └── HitManagerTests.cs
│
├── AstrumTest.Network/             # 网络层测试（独立项目）
│   ├── ProtocolSerializationTests.cs
│   └── NetworkCommunicationTests.cs
│
└── AstrumTest.Integration/         # 集成测试（独立项目）
    ├── ServerIntegrationTests.cs
    └── RoomSystemTests.cs
```

### 优势
✅ **完全隔离** - 每个测试项目独立运行，互不干扰  
✅ **清晰分类** - 按功能领域划分，易于维护  
✅ **独立依赖** - 各项目只引用需要的依赖  
✅ **并行执行** - 可以并行运行不同测试项目  

---

## 🔧 实施步骤

### Step 1: 统一测试框架（选择 Xunit）

**理由**：
- Xunit 是 .NET 现代测试框架标准
- 更好的并行支持
- 更清晰的测试隔离机制

**操作**：
```bash
# 移除 NUnit 依赖
dotnet remove package NUnit
dotnet remove package NUnit.Analyzers
dotnet remove package NUnit3TestAdapter

# 已有 Xunit，无需额外安装
```

### Step 2: 创建测试基类（解决单例污染）

**创建**: `AstrumTest.Common/TestBase.cs`

```csharp
using System;
using System.IO;
using Xunit;
using Astrum.LogicCore.Managers;

namespace AstrumTest.Common
{
    /// <summary>
    /// 测试基类 - 提供隔离的测试环境
    /// </summary>
    public abstract class TestBase : IDisposable
    {
        protected string TestConfigPath { get; private set; }
        
        protected TestBase()
        {
            // 每个测试创建独立的配置路径
            TestConfigPath = Path.Combine(
                Path.GetTempPath(), 
                $"AstrumTest_{Guid.NewGuid()}"
            );
            
            SetupTestEnvironment();
        }
        
        /// <summary>
        /// 设置测试环境（子类可覆盖）
        /// </summary>
        protected virtual void SetupTestEnvironment()
        {
            // 初始化配置管理器（使用临时路径）
            var configPath = GetConfigPath();
            if (!string.IsNullOrEmpty(configPath))
            {
                ConfigManager.Instance.Initialize(configPath);
            }
        }
        
        /// <summary>
        /// 获取配置路径（子类可覆盖）
        /// </summary>
        protected virtual string GetConfigPath()
        {
            var root = Path.GetFullPath(
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "..")
            );
            return Path.Combine(root, "AstrumConfig", "Tables", "output", "Client");
        }
        
        /// <summary>
        /// 清理测试环境
        /// </summary>
        public virtual void Dispose()
        {
            CleanupTestEnvironment();
            
            // 清理临时目录
            if (Directory.Exists(TestConfigPath))
            {
                try
                {
                    Directory.Delete(TestConfigPath, true);
                }
                catch
                {
                    // 忽略清理失败
                }
            }
        }
        
        /// <summary>
        /// 清理测试环境（子类可覆盖）
        /// </summary>
        protected virtual void CleanupTestEnvironment()
        {
            // 重置单例状态（如果可能）
            // 注意：某些单例可能需要特殊处理
        }
    }
}
```

### Step 3: 使用 Collection Fixture 隔离测试

**创建**: `AstrumTest.Common/DatabaseFixture.cs`

```csharp
using System;
using System.IO;
using Astrum.LogicCore.Managers;

namespace AstrumTest.Common
{
    /// <summary>
    /// 数据库/配置 Fixture - 在测试集合间共享，但不跨集合
    /// </summary>
    public class ConfigFixture : IDisposable
    {
        public string ConfigPath { get; private set; }
        
        public ConfigFixture()
        {
            // 一次性初始化配置
            var root = Path.GetFullPath(
                Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "..")
            );
            ConfigPath = Path.Combine(root, "AstrumConfig", "Tables", "output", "Client");
            
            ConfigManager.Instance.Initialize(ConfigPath);
        }
        
        public void Dispose()
        {
            // 清理共享资源
        }
    }
    
    /// <summary>
    /// 标记测试集合 - 同一集合的测试共享 Fixture，但串行执行
    /// </summary>
    [CollectionDefinition("Config Collection")]
    public class ConfigCollection : ICollectionFixture<ConfigFixture>
    {
        // 这个类仅用于标记，无需实现
    }
}
```

**使用**：

```csharp
using Xunit;
using AstrumTest.Common;

namespace AstrumTest.Logic
{
    /// <summary>
    /// 技能系统测试 - 使用共享 ConfigFixture
    /// </summary>
    [Collection("Config Collection")]  // 标记为集合成员
    public class SkillSystemTests
    {
        private readonly ConfigFixture _fixture;
        
        public SkillSystemTests(ConfigFixture fixture)
        {
            _fixture = fixture;
        }
        
        [Fact]
        public void GetSkillInfo_Level1_ShouldReturnSkillInfo()
        {
            // 使用 _fixture.ConfigPath
            // 测试代码...
        }
    }
}
```

### Step 4: 重构现有测试

#### 4.1 修改 SkillSystemTests.cs

```csharp
using Xunit;
using AstrumTest.Common;
using Astrum.LogicCore.Managers;

namespace AstrumTest.Logic
{
    [Collection("Config Collection")]
    public class SkillSystemTests
    {
        private readonly ConfigFixture _fixture;
        
        public SkillSystemTests(ConfigFixture fixture)
        {
            _fixture = fixture;
            // 不需要在构造函数中初始化 ConfigManager
            // Fixture 已经做了
        }
        
        // 移除 IDisposable，改为使用 Fixture
        
        [Fact]
        public void GetSkillInfo_Level1_ShouldReturnSkillInfo()
        {
            // Arrange
            int skillId = 2001;
            int level = 1;
            
            // Act
            var skillInfo = SkillConfigManager.Instance.GetSkillInfo(skillId, level);
            
            // Assert
            Assert.NotNull(skillInfo);
            Assert.Equal(2001, skillInfo.SkillId);
            // ... 其他断言
        }
    }
}
```

#### 4.2 物理测试（无需共享状态）

```csharp
using Xunit;
using TrueSync;
using Astrum.LogicCore.Physics;

namespace AstrumTest.Physics
{
    /// <summary>
    /// 类型转换测试 - 无状态，可并行执行
    /// </summary>
    public class TypeConverterTests
    {
        // 无需 Fixture 或 Collection
        // 每个测试独立执行，无副作用
        
        [Fact]
        public void Test_FP_To_Fix64_Basic()
        {
            // Arrange
            var fp = FP.One;

            // Act
            var fix64 = fp.ToFix64();

            // Assert
            Assert.Equal(fp._serializedValue, fix64.RawValue);
        }
        
        // ... 其他测试
    }
}
```

### Step 5: 清理项目结构

**删除冗余文件**：
```bash
# 删除 .bak 文件
rm AstrumTest/AstrumTest/*.bak

# 删除重复的 csproj（保留正确的那个）
# 确认 AstrumTest/AstrumTest/AstrumTest.csproj 是主项目
```

**移除 Skip 标记**：
```csharp
// 从这样：
[Fact(Skip = "Temporarily disabled for robustness tests")]

// 改为这样（修复后重新启用）：
[Fact]
```

### Step 6: 更新 .csproj 文件

**AstrumTest.csproj** (统一框架)：

```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <!-- Xunit 测试框架 -->
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.0" />
    <PackageReference Include="xunit" Version="2.9.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.4">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    
    <!-- 移除 NUnit -->
    <!-- <PackageReference Include="NUnit" Version="4.3.2" /> -->
    <!-- <PackageReference Include="NUnit3TestAdapter" Version="5.0.0" /> -->
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AstrumProj\AstrumLogic.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Using Include="Xunit" />
  </ItemGroup>

</Project>
```

---

## 🎨 最佳实践

### 1. **测试命名规范**
```csharp
// 格式：MethodName_Scenario_ExpectedBehavior
[Fact]
public void GetSkillInfo_ValidSkillId_ShouldReturnSkillInfo()

[Fact]
public void GetSkillInfo_InvalidSkillId_ShouldReturnNull()

[Theory]
[InlineData(2001, 1)]
[InlineData(2002, 5)]
public void GetSkillInfo_VariousLevels_ShouldReturnCorrectLevel(int skillId, int level)
```

### 2. **测试分类**
```csharp
// 使用 Trait 标记测试类别
[Trait("Category", "Unit")]
public class TypeConverterTests { }

[Trait("Category", "Integration")]
public class ServerIntegrationTests { }

// 运行时过滤
// dotnet test --filter "Category=Unit"
```

### 3. **测试数据管理**
```csharp
// 使用 Theory + InlineData 减少重复
[Theory]
[InlineData(0.0)]
[InlineData(1.0)]
[InlineData(-1.0)]
public void Test_FP_Fix64_Values(double value)
{
    var fp = (FP)(decimal)value;
    var fix64 = fp.ToFix64();
    var back = fix64.ToFP();
    Assert.Equal(fp._serializedValue, back._serializedValue);
}

// 使用 MemberData 处理复杂数据
public static IEnumerable<object[]> SkillTestData()
{
    yield return new object[] { 2001, 1, "Rush Slash" };
    yield return new object[] { 2002, 1, "Power Strike" };
}

[Theory]
[MemberData(nameof(SkillTestData))]
public void GetSkillInfo_ValidData_ShouldMatch(int skillId, int level, string name)
{
    var skill = SkillConfigManager.Instance.GetSkillInfo(skillId, level);
    Assert.Equal(name, skill.Name);
}
```

### 4. **Mock 依赖**
```csharp
// 对于难以测试的依赖，使用 Moq
// dotnet add package Moq

[Fact]
public void ProcessEntity_WithMockedDependency_ShouldWork()
{
    // Arrange
    var mockConfig = new Mock<IConfigManager>();
    mockConfig.Setup(m => m.GetConfig(It.IsAny<int>()))
              .Returns(new SomeConfig());
    
    // Act
    // ...
}
```

---

## 📊 执行测试

### 运行所有测试
```bash
dotnet test
```

### 运行特定项目
```bash
dotnet test AstrumTest/AstrumTest.csproj
dotnet test AstrumTest/PhysicsTests/PhysicsTests.csproj
```

### 运行特定类别
```bash
dotnet test --filter "Category=Unit"
dotnet test --filter "Category=Integration"
```

### 并行执行（Xunit 默认支持）
```bash
# Xunit 会自动并行执行不同类的测试
# Collection 内的测试会串行执行
dotnet test --parallel
```

### 生成测试报告
```bash
dotnet test --logger "trx;LogFileName=TestResults.trx"
dotnet test --logger "html;LogFileName=TestResults.html"
```

---

## 🔍 常见问题解决

### Q1: 测试仍然相互干扰怎么办？
**A**: 检查是否有以下情况：
1. 静态变量/单例未重置
2. 文件系统操作未清理
3. 数据库连接未关闭
4. 事件订阅未取消

**解决**：在 Dispose 中彻底清理

### Q2: ConfigManager 无法重置怎么办？
**A**: 为单例添加重置方法
```csharp
public class ConfigManager
{
    // 添加测试专用重置方法
    #if DEBUG
    internal void ResetForTesting()
    {
        _tables = null;
        _initialized = false;
    }
    #endif
}
```

### Q3: 测试运行很慢怎么办？
**A**: 
1. 使用 Collection Fixture 减少重复初始化
2. 将慢速测试标记为 Integration
3. 使用并行执行
4. 考虑使用 in-memory 数据库

---

## 📈 迁移计划

### 阶段 1: 统一框架（1 天）
- [ ] 移除 NUnit 依赖
- [ ] 转换 NUnit 测试为 Xunit
- [ ] 更新 csproj 文件

### 阶段 2: 建立基础设施（1 天）
- [ ] 创建 TestBase 基类
- [ ] 创建 Fixture 类
- [ ] 添加通用测试工具

### 阶段 3: 重构现有测试（2-3 天）
- [ ] 重构 SkillSystemTests
- [ ] 重构 PhysicsTests
- [ ] 重新启用 .bak 测试

### 阶段 4: 拆分项目（可选，1-2 天）
- [ ] 创建独立测试项目
- [ ] 迁移测试代码
- [ ] 验证隔离效果

---

## 🎯 预期效果

实施后应该达到：
✅ **零干扰** - 测试可以任意顺序执行  
✅ **高速度** - 并行执行，减少等待  
✅ **易维护** - 清晰的结构和命名  
✅ **高可靠** - 测试结果稳定可重复  

---

**更新日期**: 2025-10-10  
**状态**: 待实施 📋

