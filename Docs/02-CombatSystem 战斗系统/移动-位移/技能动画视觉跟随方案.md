# 帧同步游戏中的技能动画视觉跟随方案

## 1. 方案概述

本方案实现了逻辑层与视觉层的完全分离，确保逻辑位置（定点数）的权威性，同时通过视觉平滑跟随机制，使技能动画在视觉上流畅自然，避免长期误差累积。

### 1.1 核心目标

- **逻辑层负责权威位置**：使用定点数（TrueSync）控制实体的真实位置，支持帧同步
- **视觉层平滑展示**：在30-60 FPS的渲染帧中，通过逻辑帧间插值算法，使角色动画连续自然
- **避免误差累积**：通过逻辑帧插值自动消除误差，无需额外回归算法

### 1.2 项目集成点

- **逻辑层**：`TransComponent`（定点位置）、`SkillExecutorCapability`（技能位移）
- **视图层**：`EntityView`（视觉根节点）、`TransViewComponent`（移动表现）、`AnimationViewComponent`（动画播放）

## 2. 架构设计

### 2.1 三层架构

```
┌─────────────────────────────────────────────────────────┐
│                    逻辑层 (20 FPS)                       │
│  TransComponent.Position (TSVector 定点数)               │
│  SkillExecutorCapability (技能位移曲线)                  │
└─────────────────────────────────────────────────────────┘
                         │ 每逻辑帧更新
                         ↓
┌─────────────────────────────────────────────────────────┐
│                 LogicRoot (EntityView)                   │
│  对应逻辑位置的权威世界坐标（浮点数转换）                │
└─────────────────────────────────────────────────────────┘
                         │ 每渲染帧更新
                         ↓
┌─────────────────────────────────────────────────────────┐
│              VisualRoot (EntityView.Transform)          │
│  LogicRoot.position + visualOffset                      │
└─────────────────────────────────────────────────────────┘
                         │
                         ↓
┌─────────────────────────────────────────────────────────┐
│          Animator (关闭RootMotion，手动采样)             │
│  animator.deltaPosition 提供动画局部位移感              │
└─────────────────────────────────────────────────────────┘
```

### 2.2 层级职责

| 层级                 | 更新频率            | 职责                                                | 项目对应                               |
| -------------------- | ------------------- | --------------------------------------------------- | -------------------------------------- |
| **LogicRoot**  | 20 FPS（逻辑帧）    | 定点位置权威控制（含技能位移曲线）                  | `EntityView` 对应逻辑位置            |
| **VisualRoot** | 30-60 FPS（渲染帧） | 用于渲染表现，平滑追随 LogicRoot                    | `EntityView.Transform`               |
| **Animator**   | 每渲染帧            | 负责播放动画并提供 deltaPosition（关闭 RootMotion） | `AnimationViewComponent` 的 Animator |

### 2.3 核心原则

1. **逻辑位置为权威**：逻辑位置（`TransComponent.Position`）是定点模拟结果，**不可被视觉修改**
2. **视觉层平滑跟随**：视觉层通过插值和平滑算法，使角色动画连续自然
3. **动画局部位移**：视觉层允许动画的局部位移感（`animator.deltaPosition`），但不改变逻辑结果

## 3. 数据结构设计

### 3.1 视觉同步数据结构

```csharp
/// <summary>
/// 视觉同步数据 - 存储视觉层跟随逻辑所需的临时状态
/// 作为 ViewComponent 的私有字段，不序列化
/// </summary>
private struct VisualSyncData
{
    /// <summary>
    /// 上一逻辑帧的逻辑位置（浮点数）
    /// </summary>
    public Vector3 lastLogicPos;
    
    /// <summary>
    /// 上上一逻辑帧的逻辑位置（用于插值）
    /// </summary>
    public Vector3 previousLogicPos;
  
    /// <summary>
    /// 当前视觉偏移（动画带来的临时偏移）
    /// </summary>
    public Vector3 visualOffset;
    
    /// <summary>
    /// 自上次逻辑更新以来的累积时间
    /// </summary>
    public float timeSinceLastLogicUpdate;
}
```

**存储位置**：

- 建议在 `TransViewComponent` 或新建 `VisualFollowerComponent` 中作为私有字段
- 不需要序列化，仅在运行时使用

### 3.2 组件扩展方案

#### 方案A：扩展 TransViewComponent（推荐）

在现有的 `TransViewComponent` 中添加视觉跟随逻辑，复用现有组件。

#### 方案B：新建 VisualFollowerComponent

创建独立的 `VisualFollowerComponent`，专门处理视觉跟随逻辑，职责更清晰。

**推荐使用方案A**，因为视觉跟随本质上是移动表现的一部分。

## 4. 实现方案

### 4.1 逻辑帧阶段（20 FPS）

逻辑层更新权威位置（含技能位移曲线）：

```csharp
// 在 SkillExecutorCapability 或 MovementCapability 中
// 逻辑系统内部更新位置
var transComponent = entity.GetComponent<TransComponent>();
transComponent.Position = new TSVector(...); // 定点数更新

// 技能位移应用（如果有根节点位移数据）
if (actionConfig?.RootMotionData != null)
{
    var frameData = actionConfig.RootMotionData.Frames[currentFrame];
    TSVector worldDelta = TransformDeltaToWorld(frameData.DeltaPosition, transComponent.Rotation);
    transComponent.Position = transComponent.Position + worldDelta;
}
```

**关键点**：

- 逻辑层直接更新定点数位置
- 不进行插值或平滑处理
- 位置更新是离散的（每50ms一次）

### 4.2 渲染帧阶段（30-60 FPS）

在视图组件中每帧执行视觉跟随逻辑：

```csharp
// 在 TransViewComponent 的 OnUpdate 方法中
protected override void OnUpdate(float deltaTime)
{
    if (!_isEnabled || _ownerEntityView == null) return;
  
    var ownerEntity = _ownerEntityView.OwnerEntity;
    if (ownerEntity == null) return;
  
    var transComponent = ownerEntity.GetComponent<TransComponent>();
    if (transComponent == null) return;
  
    // 1️⃣ 获取当前逻辑位置（定点数转浮点数）
    var fixedPos = transComponent.Position;
    Vector3 currentLogicPos = new Vector3(
        (float)fixedPos.x,
        (float)fixedPos.y,
        (float)fixedPos.z
    );
  
    // 2️⃣ 获取动画根骨骼本帧位移
    Vector3 animDelta = Vector3.zero;
    Animator animator = GetAnimator();
    if (animator != null && animator.enabled)
    {
        animDelta = animator.deltaPosition;
    }
  
    // 3️⃣ 检测 LogicRoot 是否发生逻辑跳变
    Vector3 logicDelta = currentLogicPos - _visualSync.lastLogicPos;
    bool logicUpdated = logicDelta.sqrMagnitude > 0.0001f;
    
    if (logicUpdated)
    {
        // 逻辑帧更新：使用插值计算视觉偏移
        // 计算插值因子（当前渲染帧在两个逻辑帧之间的位置）
        const float logicFrameInterval = 0.05f; // 20 FPS = 50ms
        float t = Mathf.Clamp01(_visualSync.timeSinceLastLogicUpdate / logicFrameInterval);
        
        // 在上一逻辑帧和当前逻辑帧之间插值
        Vector3 interpolatedPos = Vector3.Lerp(_visualSync.lastLogicPos, currentLogicPos, t);
        
        // 计算新的视觉偏移（插值位置相对于当前逻辑位置的偏移）
        _visualSync.visualOffset = interpolatedPos - currentLogicPos;
        
        // 更新逻辑位置记录
        _visualSync.previousLogicPos = _visualSync.lastLogicPos;
        _visualSync.lastLogicPos = currentLogicPos;
        _visualSync.timeSinceLastLogicUpdate = 0f;
    }
    else
    {
        // 逻辑帧未更新：累积时间
        _visualSync.timeSinceLastLogicUpdate += deltaTime;
    }
  
    // 4️⃣ 累积动画偏移（可带权重控制Root感）
    _visualSync.visualOffset += animDelta * motionBlendWeight; // 0~1
  
    // 5️⃣ 误差钳制防护（避免浮点长时间漂移）
    if (_visualSync.visualOffset.magnitude > maxVisualOffset)
    {
        _visualSync.visualOffset = Vector3.zero;
    }
  
    // 6️⃣ 应用最终视觉位置
    Vector3 finalVisualPos = currentLogicPos + _visualSync.visualOffset;
    _ownerEntityView.SetWorldPosition(finalVisualPos);
}

// 辅助方法：获取 Animator 引用
private Animator GetAnimator()
{
    // 方式1：从 AnimationViewComponent 获取
    var animViewComponent = _ownerEntityView.ViewComponents
        .FirstOrDefault(c => c is AnimationViewComponent) as AnimationViewComponent;
  
    if (animViewComponent != null)
    {
        // AnimationViewComponent 需要暴露 Animator 引用
        return animViewComponent.GetAnimator();
    }
  
    // 方式2：直接从 GameObject 获取
    if (_ownerEntityView.GameObject != null)
    {
        return _ownerEntityView.GameObject.GetComponent<Animator>();
    }
  
    return null;
}
```

**参数配置**（Inspector 可调）：

```csharp
[Header("视觉跟随设置")]
[SerializeField] private float motionBlendWeight = 0.5f;  // 动画Root感强度（0-1）
[SerializeField] private float maxVisualOffset = 0.5f;    // 最大视觉偏移阈值（米）
[SerializeField] private const float logicFrameInterval = 0.05f; // 逻辑帧间隔（20 FPS = 50ms）
```

**参数建议值**：

- `motionBlendWeight = 0.5f`：平衡动画感和逻辑准确性
- `maxVisualOffset = 0.5f`：防止极端情况下的大幅漂移
- `logicFrameInterval = 0.05f`：匹配逻辑层的20 FPS更新频率

### 4.3 AnimationViewComponent 集成

需要修改 `AnimationViewComponent` 以支持获取 Animator：

```csharp
// 在 AnimationViewComponent 中添加
private Animator _animator;

protected override void OnInitialize()
{
    // ... 现有代码 ...
  
    // 获取 Animator 引用（如果存在）
    if (_ownerEntityView?.GameObject != null)
    {
        _animator = _ownerEntityView.GameObject.GetComponent<Animator>();
      
        // 确保关闭 RootMotion（逻辑层控制位移）
        if (_animator != null)
        {
            _animator.applyRootMotion = false;
        }
    }
}

/// <summary>
/// 获取 Animator 引用（供其他组件使用）
/// </summary>
public Animator GetAnimator()
{
    return _animator;
}
```

## 5. 关键机制详解

### 5.1 视觉偏移（visualOffset）

**作用**：

- 记录模型相对逻辑根节点的临时偏移
- 在动画播放过程中，会累积少量偏移用于表现角色身体的"跟随"与"惯性"

**生命周期**：

- 每帧通过 `Lerp` 回归到 0，确保不会漂移
- 逻辑跳变时立即清空
- 超过阈值时强制清空

### 5.2 逻辑权威

**原则**：

- 所有物理、技能、位移计算均来自逻辑层（`TransComponent`）
- `TransComponent.Position` 永远代表实体的真实、可同步位置
- 视觉位置永远是 `逻辑位置 + visualOffset`

**实现**：

- 逻辑层直接更新 `TransComponent.Position`（定点数）
- 视觉层**只读**逻辑位置，不修改
- 视觉层只能通过 `visualOffset` 添加临时偏移

### 5.3 RootMotion 替代

**Unity 的 RootMotion 问题**：

- Unity 的 `applyRootMotion` 会直接修改 Transform 位置
- 在帧同步架构中，这会导致逻辑位置和视觉位置不一致

**解决方案**：

- 关闭 `Animator.applyRootMotion`
- 使用 `animator.deltaPosition` 手动采样根骨位移
- 自定义混合程度（`motionBlendWeight`）
- 确保动画能表现出惯性感，但不改变逻辑坐标

### 5.4 防误差累积机制

**双层防护**：

1. **逻辑帧插值自动消除误差**：

   ```csharp
   // 当逻辑帧更新时，使用插值计算新的偏移
   float t = Mathf.Clamp01(timeSinceLastLogicUpdate / logicFrameInterval);
   Vector3 interpolatedPos = Vector3.Lerp(lastLogicPos, currentLogicPos, t);
   visualOffset = interpolatedPos - currentLogicPos;
   ```
   
   **优势**：
   - 考虑了渲染帧和逻辑帧之间的时间关系
   - 插值会自然地让 visualOffset 逐渐趋近于零
   - 不会产生额外的平滑延迟
   - 每个逻辑帧更新都会重新计算偏移，自动纠正累积误差

2. **偏移超过阈值立即清空**：

   ```csharp
   if (visualOffset.magnitude > maxVisualOffset)
       visualOffset = Vector3.zero;
   ```
   
   **作用**：防止极端情况下的大幅漂移（如传送、强制位移等）

**效果**：通过逻辑帧插值机制，视觉位置会自然地跟随逻辑位置，同时保持平滑性，无需额外的回归算法。

### 5.5 逻辑帧插值原理详解

**问题背景**：
- 逻辑层以 20 FPS 更新（每 50ms 一次）
- 渲染层以 30-60 FPS 更新（每 16-33ms 一次）
- 当逻辑帧更新时，渲染帧可能在两个逻辑帧之间的任意时刻

**插值计算过程**：

```
时间轴示例：
逻辑帧:     L0-------L1-------L2-------L3
              ↑                 ↑
渲染帧: R0--R1--R2--R3--R4--R5--R6--R7--R8
                    ↑
                 当前帧
```

1. **检测到逻辑更新**（从 L0 更新到 L1）：
   - `lastLogicPos` = L0 的位置
   - `currentLogicPos` = L1 的位置
   - `timeSinceLastLogicUpdate` = 自 L0 以来经过的时间（例如 35ms）

2. **计算插值因子**：
   ```csharp
   t = timeSinceLastLogicUpdate / logicFrameInterval
   t = 35ms / 50ms = 0.7
   ```

3. **计算插值位置**：
   ```csharp
   interpolatedPos = Lerp(L0, L1, 0.7)
   // 表示当前渲染帧应该在 L0 和 L1 之间 70% 的位置
   ```

4. **计算视觉偏移**：
   ```csharp
   visualOffset = interpolatedPos - currentLogicPos
   visualOffset = interpolatedPos - L1
   // 这个偏移量是负值，表示视觉位置稍微落后于逻辑位置
   ```

5. **应用最终位置**：
   ```csharp
   finalVisualPos = currentLogicPos + visualOffset
   finalVisualPos = L1 + (interpolatedPos - L1) = interpolatedPos
   ```

**优势说明**：

- **时间精确性**：考虑了渲染帧和逻辑帧之间的实际时间关系
- **自动收敛**：随着时间推移，`timeSinceLastLogicUpdate` 增大，`t` 趋近于 1，`visualOffset` 趋近于 0
- **无延迟**：不需要额外的平滑时间，直接根据时间比例计算
- **无累积误差**：每次逻辑更新都重新计算，不会累积误差
- **平滑过渡**：即使逻辑帧跳变，视觉也会平滑地从插值位置过渡到新的逻辑位置

## 6. 技能位移配合逻辑层曲线

### 6.1 逻辑层已有完整位移曲线

当逻辑层已有完整的位移曲线控制技能动作时（参考 [动画根节点位移提取方案](../04-EditorTools%20编辑器工具/技能动作编辑器/动画根节点位移提取方案.md)）：

- **视觉层无需再驱动位移**：动画只需表现动作，不需要产生位移
- **视觉层自动追随逻辑结果**：通过本方案的视觉跟随机制，自动平滑跟随逻辑位置

### 6.2 优势

- **技能位移的真实落点始终与逻辑一致**：逻辑层控制位移，确保同步准确
- **动画仍然流畅平滑**：视觉层通过平滑算法，消除离散更新的突兀感
- **无论技能多复杂都不会出现漂移或错位**：回归机制确保长期稳定

## 7. 代码实现示例

### 7.1 TransViewComponent 完整扩展

```csharp
using UnityEngine;
using System.Linq;
using Astrum.CommonBase;
using Astrum.LogicCore.Components;

namespace Astrum.View.Components
{
    /// <summary>
    /// 移动视图组件 - 处理实体的移动表现（扩展视觉跟随）
    /// </summary>
    public class TransViewComponent : ViewComponent
    {
        [Header("移动设置")]
        [SerializeField] private float moveSpeed = 5f;
        [SerializeField] private float rotationSpeed = 720f;
        [SerializeField] private bool smoothMovement = true;
        [SerializeField] private float smoothTime = 0.1f;
      
        [Header("视觉跟随设置")]
        [SerializeField] private float motionBlendWeight = 0.5f;  // 动画Root感强度
        [SerializeField] private float maxVisualOffset = 0.5f;   // 最大视觉偏移
        [SerializeField] private bool enableVisualFollow = true; // 是否启用视觉跟随
        
        // 逻辑帧间隔（20 FPS = 50ms）
        private const float LogicFrameInterval = 0.05f;
      
        // 移动状态
        private Vector3 _targetPosition;
        private Quaternion _targetRotation;
        private Vector3 _currentVelocity;
      
        // 视觉同步数据
        private VisualSyncData _visualSync;
      
        private struct VisualSyncData
        {
            public Vector3 lastLogicPos;
            public Vector3 previousLogicPos;
            public Vector3 visualOffset;
            public float timeSinceLastLogicUpdate;
        }
      
        protected override void OnUpdate(float deltaTime)
        {
            if (!_isEnabled || _ownerEntityView == null) return;
          
            var ownerEntity = _ownerEntityView.OwnerEntity;
            if (ownerEntity == null) return;
          
            var transComponent = ownerEntity.GetComponent<TransComponent>();
            if (transComponent == null) return;
          
            // 获取逻辑位置
            var fixedPos = transComponent.Position;
            Vector3 currentLogicPos = new Vector3(
                (float)fixedPos.x,
                (float)fixedPos.y,
                (float)fixedPos.z
            );
          
            if (enableVisualFollow)
            {
                // 使用视觉跟随模式
                UpdateVisualFollow(currentLogicPos, deltaTime);
            }
            else
            {
                // 使用传统平滑移动模式
                UpdateSmoothMovement(currentLogicPos, deltaTime);
            }
          
            // 更新旋转（保持不变）
            UpdateRotation(transComponent, deltaTime);
        }
      
        /// <summary>
        /// 视觉跟随更新（新方案）
        /// </summary>
        private void UpdateVisualFollow(Vector3 currentLogicPos, float deltaTime)
        {
            // 获取动画位移
            Vector3 animDelta = Vector3.zero;
            Animator animator = GetAnimator();
            if (animator != null && animator.enabled)
            {
                animDelta = animator.deltaPosition;
            }
          
            // 检测逻辑跳变
            Vector3 logicDelta = currentLogicPos - _visualSync.lastLogicPos;
            bool logicUpdated = logicDelta.sqrMagnitude > 0.0001f;
            
            if (logicUpdated)
            {
                // 逻辑帧更新：使用插值计算视觉偏移
                float t = Mathf.Clamp01(_visualSync.timeSinceLastLogicUpdate / LogicFrameInterval);
                Vector3 interpolatedPos = Vector3.Lerp(_visualSync.lastLogicPos, currentLogicPos, t);
                _visualSync.visualOffset = interpolatedPos - currentLogicPos;
                
                // 更新逻辑位置记录
                _visualSync.previousLogicPos = _visualSync.lastLogicPos;
                _visualSync.lastLogicPos = currentLogicPos;
                _visualSync.timeSinceLastLogicUpdate = 0f;
            }
            else
            {
                // 逻辑帧未更新：累积时间
                _visualSync.timeSinceLastLogicUpdate += deltaTime;
            }
          
            // 累积动画偏移
            _visualSync.visualOffset += animDelta * motionBlendWeight;
          
            // 误差钳制
            if (_visualSync.visualOffset.magnitude > maxVisualOffset)
            {
                _visualSync.visualOffset = Vector3.zero;
            }
          
            // 应用最终位置
            Vector3 finalPos = currentLogicPos + _visualSync.visualOffset;
            _ownerEntityView.SetWorldPosition(finalPos);
        }
      
        /// <summary>
        /// 传统平滑移动更新（保留兼容性）
        /// </summary>
        private void UpdateSmoothMovement(Vector3 currentLogicPos, float deltaTime)
        {
            _targetPosition = currentLogicPos;
          
            Vector3 currentPosition = _ownerEntityView.GetWorldPosition();
          
            if (smoothMovement)
            {
                Vector3 newPosition = Vector3.SmoothDamp(
                    currentPosition, 
                    _targetPosition, 
                    ref _currentVelocity, 
                    smoothTime, 
                    moveSpeed
                );
                _ownerEntityView.SetWorldPosition(newPosition);
            }
            else
            {
                _ownerEntityView.SetWorldPosition(_targetPosition);
            }
        }
      
        /// <summary>
        /// 获取 Animator 引用
        /// </summary>
        private Animator GetAnimator()
        {
            // 从 AnimationViewComponent 获取
            var animViewComponent = _ownerEntityView.ViewComponents
                .FirstOrDefault(c => c is AnimationViewComponent) as AnimationViewComponent;
          
            if (animViewComponent != null)
            {
                return animViewComponent.GetAnimator();
            }
          
            // 备用：直接从 GameObject 获取
            if (_ownerEntityView.GameObject != null)
            {
                return _ownerEntityView.GameObject.GetComponent<Animator>();
            }
          
            return null;
        }
      
        // ... 其他现有方法保持不变 ...
    }
}
```

### 7.2 AnimationViewComponent 扩展

```csharp
// 在 AnimationViewComponent 中添加

private Animator _animator;

protected override void OnInitialize()
{
    // ... 现有初始化代码 ...
  
    // 获取 Animator 引用
    if (_ownerEntityView?.GameObject != null)
    {
        _animator = _ownerEntityView.GameObject.GetComponent<Animator>();
      
        // 确保关闭 RootMotion
        if (_animator != null)
        {
            _animator.applyRootMotion = false;
        }
    }
}

/// <summary>
/// 获取 Animator 引用（供其他组件使用）
/// </summary>
public Animator GetAnimator()
{
    return _animator;
}
```

## 8. 测试与调试

### 8.1 调试可视化

```csharp
// 在 TransViewComponent 中添加 Gizmos 绘制（Editor Only）
#if UNITY_EDITOR
private void OnDrawGizmos()
{
    if (!enableVisualFollow) return;
  
    // 绘制逻辑位置
    Gizmos.color = Color.green;
    Gizmos.DrawWireSphere(_visualSync.lastLogicPos, 0.1f);
  
    // 绘制视觉位置
    Vector3 visualPos = _visualSync.lastLogicPos + _visualSync.visualOffset;
    Gizmos.color = Color.yellow;
    Gizmos.DrawWireSphere(visualPos, 0.1f);
  
    // 绘制偏移向量
    Gizmos.color = Color.red;
    Gizmos.DrawLine(_visualSync.lastLogicPos, visualPos);
}
#endif
```

### 8.2 性能监控

- 监控 `visualOffset` 的幅度，确保不会异常累积
- 监控逻辑跳变频率，优化平滑参数
- 监控每帧的位移计算开销

## 9. 注意事项

### 9.1 初始化

在组件初始化时，需要设置初始值：

```csharp
protected override void OnInitialize()
{
    // ... 现有初始化 ...
  
    var transComponent = OwnerEntity?.GetComponent<TransComponent>();
    if (transComponent != null)
    {
        var fixedPos = transComponent.Position;
        Vector3 initialPos = new Vector3(
            (float)fixedPos.x,
            (float)fixedPos.y,
            (float)fixedPos.z
        );
        
        _visualSync.lastLogicPos = initialPos;
        _visualSync.previousLogicPos = initialPos;
        _visualSync.visualOffset = Vector3.zero;
        _visualSync.timeSinceLastLogicUpdate = 0f;
    }
}
```

### 9.2 网络同步

- 逻辑位置通过帧同步系统同步（`TransComponent` 使用定点数）
- 视觉位置仅在本地计算，不需要同步
- 所有客户端基于相同的逻辑位置计算视觉位置，结果应一致

### 9.3 性能考虑

- `visualOffset` 计算每帧执行，但开销很小（几个向量运算）
- `GetAnimator()` 建议缓存结果，避免每帧查找
- 如果不需要视觉跟随，可以关闭 `enableVisualFollow`

## 10. 与现有系统的集成

### 10.1 与技能系统集成

- **技能位移**：逻辑层通过 `SkillExecutorCapability` 应用技能位移曲线
- **视觉跟随**：视觉层自动平滑跟随逻辑位置变化
- **动画表现**：`AnimationViewComponent` 播放技能动画，提供 `deltaPosition`

### 10.2 与移动系统集成

- **普通移动**：逻辑层通过 `MovementCapability` 更新位置
- **视觉表现**：通过本方案的视觉跟随，平滑显示移动效果
- **动画同步**：行走/跑步动画的位移感通过 `motionBlendWeight` 控制

### 10.3 与物理系统集成

- **碰撞检测**：逻辑层通过物理系统处理碰撞，更新 `TransComponent`
- **视觉跟随**：视觉层自动跟随逻辑位置的碰撞结果
- **平滑显示**：避免碰撞后位置的突兀跳变

## 11. 后续优化方向

### 11.1 参数自动调优

- 根据动画类型自动调整 `motionBlendWeight`
- 根据网络延迟动态调整 `logicFrameInterval`
- 自适应误差阈值调整

### 11.2 高级功能

- **预测插值**：在帧同步基础上，添加客户端预测和回滚
- **多层级平滑**：不同身体部位使用不同的平滑参数
- **动画混合**：多个动画的位移混合计算

### 11.3 性能优化

- **对象池**：重用向量计算对象
- **批量更新**：对多个实体统一处理视觉跟随
- **LOD 系统**：根据距离简化视觉跟随计算

---

*文档版本：v1.1*
*创建时间：2025-01-16*
*更新时间：2025-01-16*
*状态：方案设计完成，待实现*

**更新日志**：
- v1.1 (2025-01-16)：优化逻辑跳变处理，使用逻辑帧间插值替代直接清空和平滑回归，消除渲染帧与逻辑帧时间间隔的影响
- v1.0 (2025-01-16)：初始版本，基于平滑回归的视觉跟随方案

## 相关文档

- [动画根节点位移提取方案](../04-EditorTools%20编辑器工具/技能动作编辑器/动画根节点位移提取方案.md) - 逻辑层技能位移数据提取
- [动作系统策划案](./技能系统/Action-System%20动作系统.md) - 动作系统架构
- [动画系统实现总结](./技能系统/Animation-System%20动画系统.md) - 动画系统详细实现
