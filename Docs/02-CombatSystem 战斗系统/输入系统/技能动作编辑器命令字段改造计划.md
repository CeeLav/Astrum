# 技能动作编辑器命令字段改造计划

## 文档信息

- **创建日期**：2025-11-09
- **版本**：v1.0
- **状态**：设计阶段

## 一、背景与问题

### 1.1 当前实现

**位置**：`AstrumProj/Assets/Script/Editor/RoleEditor/Data/ActionEditorData.cs`

```csharp
[TitleGroup("动作配置")]
[LabelText("命令")]
[ValueDropdown("GetCommandOptions")]
public string Command = "";

private IEnumerable<string> GetCommandOptions()
{
    return new[] { "", "Move", "NormalAttack", "HeavyAttack", "Skill1", "Skill2", "Jump", "Interact" };
}
```

### 1.2 存在的问题

1. **硬编码命令列表**：命令选项硬编码在代码中，与 `ActionCommandMappingTable.csv` 不一致
2. **单一命令限制**：一个动作只能绑定一个命令，但实际上某些动作可能需要多个命令组合才能触发
3. **命令不匹配**：
   - 代码中：`NormalAttack`, `HeavyAttack`, `Jump`, `Interact`
   - 配置表中：`move`, `attack`, `skill1`, `skill2`, `roll`, `dash`
4. **维护困难**：添加新命令需要同时修改代码和配置表

### 1.3 实际需求

**示例场景**：
- **普通攻击**：只需 `attack` 命令
- **跳跃攻击**：需要 `roll` + `attack` 命令同时满足
- **冲刺攻击**：需要 `dash` + `attack` 命令同时满足
- **技能连招**：需要 `skill1` + `move` 命令组合

## 二、设计方案

### 2.1 核心改动

#### 改动1：从配置表读取命令列表

**目标**：命令选项从 `ActionCommandMappingTable.csv` 动态加载

**实现**：
```csharp
private IEnumerable<string> GetCommandOptions()
{
    // 从配置表加载
    var tables = ConfigManager.Instance.Tables;
    var commands = new List<string> { "" }; // 空选项表示无命令
    
    foreach (var mapping in tables.ActionCommandMappingTable.DataList)
    {
        commands.Add(mapping.CommandName);
    }
    
    return commands;
}
```

**优点**：
- 配置表和编辑器自动同步
- 添加新命令只需修改CSV，无需改代码
- 避免命令名称不一致

#### 改动2：单命令改为命令列表

**目标**：支持一个动作绑定多个命令

**数据结构改动**：

```csharp
// 旧实现
[TitleGroup("动作配置")]
[LabelText("命令")]
[ValueDropdown("GetCommandOptions")]
public string Command = "";

// 新实现
[TitleGroup("动作配置")]
[LabelText("触发命令列表")]
[InfoBox("动作需要满足的命令列表（多个命令需同时满足）", InfoMessageType.Info)]
[ValueDropdown("GetCommandOptions")]
[ListDrawerSettings(ShowIndexLabels = true, ListElementLabelName = "CommandName")]
public List<string> Commands = new List<string>();
```

**UI展示**：
```
触发命令列表
┌─────────────────────────────┐
│ [0] attack                  │ [X]
│ [1] dash                    │ [X]
│                             │
│ [+ 添加命令]                 │
└─────────────────────────────┘
```

### 2.2 命令匹配逻辑

#### 当前逻辑（ActionCapability）

```csharp
// ActionCapability.HasValidCommand()
// 检查 actionInfo.Commands 中的任意一个命令是否在 InputCommands 中
foreach (var command in actionInfo.Commands)
{
    foreach (var input in inputCommands)
    {
        if (string.Equals(input.CommandName, command.CommandName, ...))
            return true; // 任意一个匹配即可
    }
}
```

#### 新逻辑（支持多命令组合）

**方案A：全部满足（AND逻辑）**
```csharp
// 所有命令都必须在 InputCommands 中
bool HasValidCommand(ActionInfo actionInfo, List<ActionCommand> inputCommands)
{
    if (actionInfo.Commands == null || actionInfo.Commands.Count == 0)
        return false;
    
    // 检查每个命令是否都满足
    foreach (var command in actionInfo.Commands)
    {
        bool found = false;
        foreach (var input in inputCommands)
        {
            if (string.Equals(input.CommandName, command.CommandName, ...))
            {
                found = true;
                break;
            }
        }
        if (!found) return false; // 有一个不满足就失败
    }
    
    return true; // 所有命令都满足
}
```

**方案B：任意满足（OR逻辑，保持兼容）**
```csharp
// 任意一个命令满足即可（当前逻辑）
// 保持不变
```

**推荐**：使用方案A（AND逻辑），因为：
- 支持组合技（如冲刺攻击 = dash + attack）
- 单命令场景仍然有效（列表只有一个元素）
- 更符合"触发条件"的语义

### 2.3 配置表字段说明更新

更新 `ActionCommandMappingTable.csv` 的描述字段：

```csv
##desc,命令名称,LSInput字段名(|分隔表示OR关系),触发条件(NonZero/True/Always),有效帧数,优先级,说明
```

添加使用说明：
- 单个命令：动作只需一个命令即可触发
- 多个命令：动作需要所有命令同时满足才能触发（AND逻辑）

### 2.4 数据持久化

#### ActionTable.csv 字段变更

**旧字段**：
```csv
##var,actionId,actionName,actionType,duration,AnimationName,autoNextActionId,keepPlayingAnim,AutoTerminate,Command,Priority,CancelTags,BeCancelledTags
##type,int,string,string,int,string,int,bool,bool,string,int,string,string
```

**新字段**（使用Luban数组类型）：
```csv
##var,actionId,actionName,actionType,duration,AnimationName,autoNextActionId,keepPlayingAnim,AutoTerminate,Commands,Priority,CancelTags,BeCancelledTags
##type,int,string,string,int,string,int,bool,bool,"(array#sep=,),string",int,string,string
##desc,动作ID,动作名称,动作类型,帧数,动画路径,自动下一动作ID,保持播放动画,自动终止,触发命令列表,优先级,取消标签,被取消标签
```

**Luban数组类型说明**：
- 格式：`(array#sep=分隔符),类型`
- `(array#sep=,),string` 表示逗号分隔的字符串数组
- `(array#sep=|),int` 表示竖线分隔的整数数组（如现有的 rootMotionData）

**数据格式**：
```csv
# 单命令
,3001,普通攻击,skill,43,Assets/...,1001,False,False,attack,30,...,...

# 多命令（逗号分隔）
,3002,冲刺攻击,skill,60,Assets/...,1001,False,False,"dash,attack",15,...,...

# 三个命令
,3003,连招,skill,80,Assets/...,1001,False,False,"move,dash,attack",20,...,...
```

**优势**：
- 与现有的 `rootMotionData` 格式一致（都使用 array 类型）
- 简洁直观，易于编辑
- Luban自动解析为 `List<string>`

#### ActionTableData.cs 映射类修改

**旧实现**：
```csharp
[TableField(8, "Command")]
public string Command { get; set; }
```

**新实现**（使用Luban List类型）：
```csharp
[TableField(8, "Commands")]
public List<string> Commands { get; set; } = new List<string>();
```

**LubanTableConfig 更新**：
```csharp
public static LubanTableConfig GetTableConfig()
{
    return new LubanTableConfig
    {
        FilePath = "AstrumConfig/Tables/Datas/Entity/#ActionTable.csv",
        HeaderLines = 4,
        HasEmptyFirstColumn = true,
        Header = new TableHeader
        {
            VarNames = new List<string>
            {
                "actionId", "actionName", "actionType", "duration", "AnimationName",
                "autoNextActionId", "keepPlayingAnim", "AutoTerminate", "Commands", "Priority",
                "CancelTags", "BeCancelledTags"
            },
            Types = new List<string>
            {
                "int", "string", "string", "int", "string",
                "int", "bool", "bool", "(array#sep=,),string", "int",  // 注意这里
                "string", "string"
            },
            // ... 其他配置
        }
    };
}
```

**LubanCSVReader 自动处理**：
- Luban的CSV读取器会自动将逗号分隔字符串解析为 `List<string>`
- 例如：`"dash,attack"` → `List<string> { "dash", "attack" }`
- 单个值：`attack` → `List<string> { "attack" }`
- 空值：`` → `List<string> { }`

**无需手动序列化/反序列化**！

## 三、实施步骤

### 阶段1：数据结构改造（1天）

**文件修改**：
1. `ActionEditorData.cs`
   - 将 `string Command` 改为 `List<string> Commands`
   - 修改 `GetCommandOptions()` 从配置表读取
   - 添加序列化/反序列化方法

2. `SkillActionEditorData.cs`
   - 继承自 `ActionEditorData`，自动获得新字段

3. `MoveActionEditorData.cs`（如果存在）
   - 同上

**测试**：
- 打开技能动作编辑器
- 验证命令列表UI正常显示
- 验证可以添加/删除多个命令

### 阶段2：配置表和映射类更新（1天）

**文件修改**：

1. **ActionTableData.cs** (`AstrumProj/Assets/Script/Editor/RoleEditor/Persistence/Mappings/`)
   ```csharp
   // 修改字段
   [TableField(8, "Commands")]
   public List<string> Commands { get; set; } = new List<string>();
   
   // 更新 GetTableConfig()
   VarNames: "Command" → "Commands"
   Types: "string" → "(array#sep=,),string"
   Descriptions: "命令" → "触发命令列表"
   ```

2. **ActionTable.csv** (`AstrumConfig/Tables/Datas/Entity/`)
   ```csv
   # 修改表头
   ##var,...,Commands,...
   ##type,...,"(array#sep=,),string",...
   ##desc,...,触发命令列表,...
   
   # 修改数据（示例）
   ,3001,...,attack,...              # 单命令
   ,3002,...,"dash,attack",...       # 多命令（逗号分隔）
   ```

3. **ActionDataAssembler.cs** (`AstrumProj/Assets/Script/Editor/RoleEditor/Persistence/`)
   ```csharp
   // ConvertToEditorData() 方法中
   // 旧代码：
   editorData.Command = tableData.Command;
   
   // 新代码：
   editorData.Commands = tableData.Commands ?? new List<string>();
   ```

4. **ActionDataWriter.cs** (`AstrumProj/Assets/Script/Editor/RoleEditor/Persistence/`)
   ```csharp
   // BuildActionTableRow() 方法中
   // 旧代码：
   row.Command = editorData.Command;
   
   // 新代码：
   row.Commands = editorData.Commands ?? new List<string>();
   ```

**测试**：
- 读取现有CSV数据，验证 `Commands` 字段正确解析
- 保存数据，验证 `Commands` 字段正确写入
- 验证单命令和多命令都能正确处理

### 阶段3：CSV写入逻辑修改（0.5天）

**文件修改**：

1. **ActionDataWriter.cs** - `WriteActionTableRow()` 方法
   ```csharp
   private static string WriteActionTableRow(ActionEditorData data)
   {
       var row = new StringBuilder();
       
       // ... 其他字段 ...
       
       // Commands 字段写入（Luban array 格式，逗号分隔）
       if (data.Commands == null || data.Commands.Count == 0)
       {
           row.Append(",");  // 空值
       }
       else if (data.Commands.Count == 1)
       {
           row.Append($",{data.Commands[0]}");  // 单个值
       }
       else
       {
           // 多个值，使用逗号分隔（需要用引号包裹）
           var commandsStr = string.Join(",", data.Commands);
           row.Append($",\"{commandsStr}\"");
       }
       
       // ... 其他字段 ...
       
       return row.ToString();
   }
   ```

2. **LubanCSVWriter.cs** - 通用写入方法（如果有）
   ```csharp
   public static string FormatArrayField<T>(List<T> list, string separator = ",")
   {
       if (list == null || list.Count == 0)
           return "";
       
       if (list.Count == 1)
           return list[0].ToString();
       
       // 多个值，使用指定分隔符连接
       var result = string.Join(separator, list);
       
       // 如果包含分隔符，需要用引号包裹
       if (result.Contains(separator))
           return $"\"{result}\"";
       
       return result;
   }
   ```

**注意事项**：
- Luban读取时自动解析逗号分隔字符串，无需手动反序列化
- 写入时使用逗号连接，多个值时用引号包裹
- 单个值可以直接写，不需要引号
- 空值直接留空
- 与 `rootMotionData` 的 `(array#sep=|),int` 格式一致

**测试**：
- 保存单命令动作，验证CSV格式：`attack`
- 保存多命令动作，验证CSV格式：`"dash,attack"`
- 重新加载，验证命令列表完整

### 阶段4：Action系统适配（1-2天）

**文件修改**：
1. `ActionInfo.cs`
   - 将 `List<ActionCommand> Commands` 保持不变
   - 这个字段已经是列表，无需修改

2. `ActionCapability.cs`
   - 修改 `HasValidCommand()` 使用AND逻辑
   - 所有命令都必须在 `InputCommands` 中

**测试**：
- 测试单命令动作（如普通攻击）
- 测试多命令动作（如冲刺攻击）
- 验证命令匹配逻辑正确

### 阶段5：文档和示例（0.5天）

**文档更新**：
1. 更新 `Action-System 动作系统.md`
2. 添加多命令使用示例
3. 更新配置表说明

**示例数据**：
```csv
# ActionTable.csv 示例
,1001,待机,idle,Assets/Animations/Idle.anim,60,0,0,false,false,,...
,2001,行走,move,Assets/Animations/Walk.anim,40,0,0,false,false,move,...
,3001,普通攻击,skill,Assets/Animations/Attack.anim,45,10,0,false,false,attack,...
,3002,冲刺攻击,skill,Assets/Animations/DashAttack.anim,60,15,0,false,false,"dash,attack",...
,3003,翻滚,skill,Assets/Animations/Roll.anim,30,15,0,false,false,roll,...
```

## 四、兼容性处理

### 4.1 旧数据迁移

**场景**：现有动作数据使用 `string Command` 字段

**迁移脚本**：
```csharp
[MenuItem("Astrum/Tools/Migrate Action Commands")]
public static void MigrateActionCommands()
{
    // 查找所有 ActionEditorData 资源
    var guids = AssetDatabase.FindAssets("t:ActionEditorData");
    
    foreach (var guid in guids)
    {
        var path = AssetDatabase.GUIDToAssetPath(guid);
        var data = AssetDatabase.LoadAssetAtPath<ActionEditorData>(path);
        
        if (data != null)
        {
            // 如果 Commands 为空且 Command 不为空，迁移数据
            if ((data.Commands == null || data.Commands.Count == 0) 
                && !string.IsNullOrEmpty(data.Command))
            {
                data.Commands = new List<string> { data.Command };
                data.Command = ""; // 清空旧字段
                
                EditorUtility.SetDirty(data);
                Debug.Log($"Migrated: {path}");
            }
        }
    }
    
    AssetDatabase.SaveAssets();
    Debug.Log("Migration completed!");
}
```

### 4.2 CSV数据迁移

**旧格式**：
```csv
,3001,普通攻击,skill,...,attack,...
```

**新格式**：
```csv
,3001,普通攻击,skill,...,attack,...
```

**处理**：
- 单个命令：直接兼容，无需修改
- 如需多命令：手动添加逗号分隔

## 五、测试用例

### 5.1 单命令测试

| 动作 | 命令列表 | 输入命令 | 预期结果 |
|------|---------|---------|---------|
| 普通攻击 | [attack] | attack | ✅ 触发 |
| 普通攻击 | [attack] | skill1 | ❌ 不触发 |
| 移动 | [move] | move | ✅ 触发 |

### 5.2 多命令测试

| 动作 | 命令列表 | 输入命令 | 预期结果 |
|------|---------|---------|---------|
| 冲刺攻击 | [dash, attack] | dash, attack | ✅ 触发 |
| 冲刺攻击 | [dash, attack] | dash | ❌ 不触发（缺少attack） |
| 冲刺攻击 | [dash, attack] | attack | ❌ 不触发（缺少dash） |
| 翻滚攻击 | [roll, attack] | roll, attack | ✅ 触发 |

### 5.3 优先级测试

| 场景 | 动作A | 动作B | 输入命令 | 预期结果 |
|------|-------|-------|---------|---------|
| 优先级对比 | 普通攻击(优先级10, [attack]) | 冲刺攻击(优先级15, [dash,attack]) | dash, attack | ✅ 冲刺攻击（优先级更高） |
| 命令不足 | 普通攻击(优先级10, [attack]) | 冲刺攻击(优先级15, [dash,attack]) | attack | ✅ 普通攻击（冲刺攻击命令不足） |

## 六、注意事项

### 6.1 性能考虑

**命令匹配复杂度**：
- 旧逻辑：O(n*m)，n=动作命令数，m=输入命令数
- 新逻辑：O(n*m)，相同复杂度
- 实际影响：可忽略（命令数量很小，通常<10）

**优化建议**（可选）：
```csharp
// 使用 HashSet 加速查找
var inputCommandSet = new HashSet<string>(
    inputCommands.Select(c => c.CommandName),
    StringComparer.OrdinalIgnoreCase
);

foreach (var command in actionInfo.Commands)
{
    if (!inputCommandSet.Contains(command.CommandName))
        return false;
}
return true;
```

### 6.2 UI/UX考虑

**命令列表UI优化**：
1. 显示命令描述（从配置表读取）
2. 命令去重（不允许添加重复命令）
3. 命令排序（按优先级或字母序）
4. 实时预览（显示当前输入是否满足条件）

**示例UI**：
```
触发命令列表 (所有命令需同时满足)
┌─────────────────────────────────────┐
│ [0] dash     - 冲刺 (优先级15)      │ [X]
│ [1] attack   - 普通攻击 (优先级10)  │ [X]
│                                     │
│ [+ 添加命令 ▼]                      │
│   ├─ move    - 移动命令             │
│   ├─ attack  - 普通攻击             │
│   ├─ skill1  - 技能1                │
│   └─ ...                            │
└─────────────────────────────────────┘

当前输入命令: dash, attack, move
✅ 满足触发条件
```

### 6.3 向后兼容

**保留旧字段**（可选）：
```csharp
[HideInInspector]
[Obsolete("Use Commands instead")]
public string Command = "";
```

**运行时检查**：
```csharp
void OnEnable()
{
    // 自动迁移
    if ((Commands == null || Commands.Count == 0) && !string.IsNullOrEmpty(Command))
    {
        Commands = new List<string> { Command };
        Command = "";
    }
}
```

## 七、未来扩展

### 7.1 复杂逻辑支持

**OR逻辑**：
```csharp
// 支持 (attack OR skill1) AND dash
public List<List<string>> CommandGroups; // [[attack, skill1], [dash]]
```

**条件表达式**：
```csharp
// 支持 "attack AND (dash OR roll)"
public string CommandExpression = "attack & (dash | roll)";
```

### 7.2 可视化编辑器

**命令组合编辑器**：
- 拖拽式命令组合
- 实时预览触发条件
- 命令冲突检测

## 八、总结

### 改动范围

| 文件类型 | 文件数量 | 改动程度 | 关键文件 |
|---------|---------|---------|---------|
| 数据模型 | 1个 | 中等（字段类型变更） | ActionEditorData.cs |
| 配置表 | 1个 | 小（字段名和类型变更） | #ActionTable.csv |
| 映射类 | 1个 | 小（字段类型变更） | ActionTableData.cs |
| 读取逻辑 | 1个 | 小（字段赋值） | ActionDataAssembler.cs |
| 写入逻辑 | 1个 | 中等（JSON数组格式化） | ActionDataWriter.cs |
| 逻辑层 | 1个 | 小（匹配逻辑调整） | ActionCapability.cs |
| 文档 | 2个 | 小（说明更新） | Action-System.md等 |

**关键变更点**：
1. ✅ **Luban自动处理读取**：`(list),string` 类型自动解析JSON数组
2. ⚠️ **需要手动处理写入**：生成符合Luban格式的JSON数组字符串
3. ✅ **无需序列化/反序列化**：Luban内置支持

### 预计工时

- **总计**：3.5-4天
- **阶段1**：数据结构改造（1天）
- **阶段2**：配置表和映射类更新（1天）
- **阶段3**：CSV写入逻辑修改（0.5天）
- **阶段4**：Action系统适配（1天）
- **阶段5**：文档和示例（0.5天）
- **测试验证**：0.5天

### 风险评估

| 风险 | 等级 | 应对措施 |
|------|------|---------|
| 数据迁移失败 | 中 | 提供迁移脚本和备份 |
| UI显示异常 | 低 | Odin Inspector自动处理 |
| 命令匹配错误 | 中 | 完整测试用例覆盖 |
| 性能下降 | 低 | 命令数量少，影响可忽略 |

---

**文档状态**：✅ 设计完成，待审批

**下一步**：审批通过后进入实施阶段

