# 鼠标位置处理技术设计

## 文档信息
- **文档名称**：鼠标位置处理技术设计
- **所属模块**：战斗系统 / 输入系统
- **创建日期**：2025-11-13
- **版本**：v1.0
- **撰写人**：输入系统小组
- **适用范围**：俯视角射击、指向性技能、角色朝向
- **依赖系统**：三层输入架构（Raw → LSInput → ActionCommand）、帧同步机制、Action系统
- **当前状态**：设计完成，待实现

---

## 一、背景与需求分析

### 1.1 业务需求
在俯视角带射击要素的游戏场景中，攻击、技能和发射类行为通常以鼠标所指向的位置作为目标方向。因此需要支持：
1. **角色朝向鼠标**：攻击或技能施放时，角色身体朝向鼠标所在方向。
2. **子弹沿鼠标方向发射**：弹道类技能需要沿着角色→鼠标的方向运行。
3. **技能瞄准显示**：指向性技能需要显示瞄准辅助线或区域，鼠标位置即技能落点。

### 1.2 技术挑战
1. **坐标系转换**：Unity 鼠标位置为屏幕坐标，需要通过摄像机和场景平面转换为角色所在平面上的世界坐标。
2. **帧同步一致性**：鼠标位置必须在帧同步系统中同步，确保不同客户端计算一致。
3. **配置驱动扩展**：遵循既定输入系统设计，不应硬编码映射关系，应通过配置表控制。
4. **数据类型统一**：与现有 `LSInput.MoveX/MoveY` 保持一致，使用 Q31.32 定点数表示世界坐标。

### 1.3 既有架构回顾
输入系统采用三层架构：
```
物理输入层 (Raw Input)
  → 逻辑动作层 (Logical Action)
    → 帧同步输入层 (LSInput)
      → 动作指令层 (ActionCommand)
```
- Raw 层通过 `IRawInputProvider` 采集硬件输入（键盘、鼠标）。
- LSInput 层通过 `LSInputAssembler` 将逻辑动作映射为具体的帧同步字段。
- ActionCommand 层在 `ActionCapability` 中根据配置生成命令，供 Action 系统消费。

当前 `IRawInputProvider` 已提供 `GetMousePosition()`（屏幕坐标），但 `LSInput` 与 `ActionCommand` 未携带鼠标世界坐标信息。

---

## 二、设计目标

1. **无缝集成**：在现有三层架构上扩展鼠标位置支持，不破坏既有功能。
2. **配置驱动**：通过 CSV 配置表扩展 LSInput 字段和命令映射，杜绝硬编码。
3. **帧同步一致性**：将鼠标世界坐标写入 `LSInput` 并同步至服务器/其他客户端。
4. **类型统一**：沿用 Q31.32 定点数（`long` 类型）表示世界坐标信息。
5. **易用性**：为 Action 系统提供便捷的方向信息，支持多种技能/攻击动作复用。

---

## 三、整体方案概述（方案A）

### 3.1 数据流
```
Unity.mousePosition (屏幕坐标)
  ↓ ConfigurableInputProvider.GetMousePosition()
LSInputAssembler.AssembleFromRawInput()
  - 使用 Camera.ScreenPointToRay()
  - 与角色平面求交，得到世界坐标 (worldX, worldZ)
  - 转 Q31.32 定点数写入 LSInput
LSInput (MouseWorldX/MouseWorldZ)
  ↓ 同步到服务器/其他客户端
ActionCapability.SyncInputCommands()
  - 根据配置生成 attack_with_target 命令
ActionCommand.TargetPositionX/TargetPositionZ
  ↓ 动作（Action）执行
  - 角色朝向计算
  - 弹道方向计算
  - 技能落点判定
```

### 3.2 架构拓扑
```
┌─────────────────────────────────────┐
│  Raw Input 层                       │
│  - UnityEngine.Input.mousePosition │
└─────────────┬──────────────────────┘
              │ ConfigurableInputProvider
              ↓
┌─────────────────────────────────────┐
│  逻辑动作层                         │
│  - MousePosition (逻辑动作ID)       │
└─────────────┬──────────────────────┘
              │ LSInputAssembler (新增鼠标转换)
              ↓
┌─────────────────────────────────────┐
│  LSInput (帧同步层)                 │
│  - MouseWorldX / MouseWorldZ (Q31.32)
└─────────────┬──────────────────────┘
              │ ActionCapability.SyncInputCommands()
              ↓
┌─────────────────────────────────────┐
│  ActionCommand 层                  │
│  - TargetPositionX / TargetPositionZ (Q31.32)
└─────────────┬──────────────────────┘
              │ 具体 Action 执行（角色朝向/发射）
              ↓
┌─────────────────────────────────────┐
│  业务逻辑层（Battle/Projectile）   │
└─────────────────────────────────────┘
```

---

## 四、数据结构设计

### 4.1 Proto 定义扩展
路径：`AstrumConfig/Proto/gamemessages_C_2000.proto`
> 注意：修改 .proto 后需运行生成工具，更新客户端/服务器的 Generated 代码。

```protobuf
message LSInput
{
    int64 PlayerId = 1;
    int32 Frame = 2;
    int64 MoveX = 3;       // Q31.32
    int64 MoveY = 4;       // Q31.32
    bool Attack = 5;
    bool Skill1 = 6;
    bool Skill2 = 7;
    int64 Timestamp = 8;
    int BornInfo = 9;
    bool Roll = 10;
    bool Dash = 11;

    // 新增：鼠标位置（世界坐标，Q31.32）
    int64 MouseWorldX = 12;  // X 轴坐标，对应世界 X
    int64 MouseWorldZ = 13;  // Z 轴坐标，对应世界 Z（水平面）
}
```

### 4.2 ActionCommand 扩展
路径：`AstrumProj/Assets/Script/AstrumLogic/ActionSystem/ActionCommand.cs`

```csharp
[MemoryPackable]
public partial class ActionCommand
{
    public string CommandName { get; set; } = string.Empty;
    public int ValidFrames { get; set; } = 0;

    // 新增：目标位置（Q31.32 定点数）
    public long TargetPositionX { get; set; } = 0;
    public long TargetPositionZ { get; set; } = 0;

    [MemoryPackConstructor]
    public ActionCommand(string commandName, int validFrames, long targetPositionX, long targetPositionZ)
    {
        CommandName = commandName ?? string.Empty;
        ValidFrames = validFrames;
        TargetPositionX = targetPositionX;
        TargetPositionZ = targetPositionZ;
    }
}
```

### 4.3 配置表扩展
所有配置表位于 `AstrumConfig/Tables/Datas/Input/`

#### 4.3.1 #InputBindingTable.csv
新增 MousePosition 逻辑动作（用于启用鼠标位置采集）：
```csv
##var,actionId,displayName,primaryKey,alternativeKey,mouseButton,inputType,category
,,,...(原有配置)
,MousePosition,鼠标位置,,,0,Axis,Combat
```

#### 4.3.2 #LSInputFieldMappingTable.csv
新增 MousePosition 映射条目：
```csv
##var,lsInputField,mappingType,sourceActions,requireNonZero,description
,,,...(原有配置)
,MouseWorldX,MousePosition,MousePosition,false,鼠标世界坐标X
,MouseWorldZ,MousePosition,false,false,鼠标世界坐标Z
```
- `mappingType = MousePosition`：表示此字段使用鼠标射线映射逻辑。
- `sourceActions = MousePosition`：引用 InputBindingTable 中的动作 ID。

#### 4.3.3 #ActionCommandMappingTable.csv
新增带目标位置的命令映射（命令名称可根据实际技能命名）：
```csv
##var,commandName,lsInputField,triggerCondition,validFrames,priority,description
,,,...(原有配置)
,attack_with_target,Attack|MouseWorldX|MouseWorldZ,TRUE,3,10,普通攻击（含鼠标坐标）
```
- `lsInputField` 包含 Attack（触发条件）及 MouseWorldX/Z（保证命令带有目标位置）。
- 其他技能可按需扩展，如 `skill1_with_target`。

---

## 五、核心算法与实现细节

### 5.1 LSInputAssembler 处理逻辑
路径：`AstrumProj/Assets/Script/AstrumClient/Input/LSInputAssembler.cs`

```csharp
using UnityEngine;
using Astrum.Generated;
using cfg.Input;

namespace Astrum.Client.Input
{
    public static class LSInputAssembler
    {
        public static LSInput AssembleFromRawInput(
            IRawInputProvider provider,
            long playerId,
            Camera camera = null,
            Transform characterTransform = null)
        {
            if (!_initialized) Initialize();

            var input = new LSInput { PlayerId = playerId };

            AssembleMovement(input, provider, camera);
            AssembleButtons(input, provider);
            AssembleMousePosition(input, provider, camera, characterTransform);

            return input;
        }

        private static void AssembleMousePosition(
            LSInput input,
            IRawInputProvider provider,
            Camera camera,
            Transform characterTransform)
        {
            if (!_fieldMappings.TryGetValue("MouseWorldX", out var mappingX) &&
                !_fieldMappings.TryGetValue("MouseWorldZ", out var mappingZ))
            {
                // 配置未启用，清零防止遗留
                input.MouseWorldX = 0;
                input.MouseWorldZ = 0;
                return;
            }

            if (camera == null || characterTransform == null)
            {
                input.MouseWorldX = 0;
                input.MouseWorldZ = 0;
                return;
            }

            // 屏幕坐标
            Vector2 screenPos = provider.GetMousePosition();
            Ray ray = camera.ScreenPointToRay(screenPos);

            // 角色所在平面
            float planeY = characterTransform.position.y;
            Plane plane = new Plane(Vector3.up, new Vector3(0f, planeY, 0f));

            if (!plane.Raycast(ray, out float distance))
            {
                input.MouseWorldX = 0;
                input.MouseWorldZ = 0;
                return;
            }

            Vector3 worldPos = ray.GetPoint(distance);

            input.MouseWorldX = ToFixedPoint(worldPos.x);
            input.MouseWorldZ = ToFixedPoint(worldPos.z);

            ASLogger.Instance.Debug(
                $"MousePos: Screen({screenPos.x:F0}, {screenPos.y:F0}) → World({worldPos.x:F2}, {worldPos.z:F2})",
                "Input.Mouse");
        }

        private static long ToFixedPoint(float value)
        {
            return (long)(value * (double)(1L << 32));
        }
    }
}
```

**注意事项**：
1. 使用角色所在平面（`characterTransform.position.y`）避免角色高度变化导致偏差。
2. 射线未命中平面的情况（如鼠标指向天空）时，返回 0，后续 Action 可做防御性判断。
3. `ToFixedPoint` 与 MoveX/MoveY 的实现保持一致（Q31.32）。
4. 需要在调用 `AssembleFromRawInput` 时传入角色 Transform，可通过 `GameDirector` 或 `MainRoom` 获取主控角色的视图对象。

### 5.2 ActionCapability 扩展
路径：`AstrumProj/Assets/Script/AstrumLogic/Capabilities/ActionCapability.cs`

```csharp
private void SyncInputCommands(Entity entity, ActionComponent actionComponent)
{
    // ...原有逻辑...

    if (configManager?.IsInitialized == true)
    {
        foreach (var mapping in configManager.Tables.TbActionCommandMappingTable.DataList)
        {
            if (mapping != null && ShouldAddCommand(currentInput, mapping))
            {
                AddOrRefreshCommandWithTarget(
                    commands,
                    mapping.CommandName,
                    mapping.ValidFrames,
                    currentInput.MouseWorldX,
                    currentInput.MouseWorldZ);
            }
        }
    }
}

private static void AddOrRefreshCommandWithTarget(
    List<ActionCommand> commands,
    string name,
    int validFrames,
    long targetX,
    long targetZ)
{
    if (validFrames <= 0 || commands == null)
    {
        return;
    }

    foreach (var cmd in commands)
    {
        if (cmd != null && string.Equals(cmd.CommandName, name, StringComparison.OrdinalIgnoreCase))
        {
            if (cmd.ValidFrames < validFrames)
            {
                cmd.ValidFrames = validFrames;
            }
            cmd.TargetPositionX = targetX;
            cmd.TargetPositionZ = targetZ;
            return;
        }
    }

    commands.Add(new ActionCommand(name, validFrames, targetX, targetZ));
}
```

### 5.3 业务层使用示例
以普通攻击动作为例：
```csharp
private void HandleNormalAttack(Entity entity, ActionCommand command)
{
    var trans = GetComponent<TransComponent>(entity);
    if (trans == null)
        return;

    TSVector targetPos = new TSVector(
        (FP)command.TargetPositionX / (1L << 32),
        trans.Position.y,
        (FP)command.TargetPositionZ / (1L << 32));

    TSVector direction = targetPos - trans.Position;
    direction.y = FP.Zero;

    if (direction.sqrMagnitude <= FP.EN4)
    {
        // 鼠标射线未命中或距离过近，使用备用逻辑（如朝向当前目标）
        return;
    }

    direction = TSVector.Normalize(direction);

    trans.Rotation = TSQuaternion.LookRotation(direction, TSVector.up);

    SpawnProjectile(entity, direction);
}
```

---

## 六、测试与验证计划

1. **Unity 编辑器调试**：
   - 使用 Gizmos 可视化射线与落点。
   - 检查日志输出的屏幕坐标与世界坐标。
2. **帧同步回放**：
   - 在帧同步回放工具中验证不同客户端的鼠标位置一致。
   - 观察角色朝向和弹道方向是否正确复现。
3. **边界条件测试**：
   - 鼠标指向远处天空/地表以外区域。
   - 角色位于不同高度（跳跃、地形起伏）。
   - 摄像机切换视角/高度。
4. **性能评估**：
   - 确认射线转换开销可接受。
   - 必要时增加缓存或限制刷新频率（本设计暂不实现）。

---

## 七、注意事项

1. **配置表更新流程**：修改 CSV 后需运行 Luban 生成工具，确保客户端/服务器均更新。
2. **数据类型一致**：所有鼠标位置数据均使用 Q31.32 定点数表示，与 MoveX/MoveY 完全一致。
3. **服务器安全性**：
   - 服务器可基于角色当前位置与鼠标位置计算并验证方向，防止篡改。
   - 如需进一步安全保障，可在服务器端重新根据摄像机状态与输入计算落点。
4. **空值处理**：鼠标位置无效时（射线未命中）应在业务层做防御性处理。
5. **ActionCommand 扩展**：已增加构造函数，需要同步更新 MemoryPack 生成的 partial 类。

---

## 八、实施步骤总结
1. 修改 `.proto` 文件并重新生成协议代码。
2. 更新配置表（InputBinding、LSInputFieldMapping、ActionCommandMapping）。
3. 扩展 `LSInputAssembler`、`ActionCapability`、`ActionCommand` 实现。
4. 在业务层（动作系统、射击系统）消费鼠标目标坐标。
5. 进行联调与帧同步一致性验证。

---

## 九、开放问题
1. **摄像机平面选择**：当前默认使用角色所在平面，可根据具体关卡需求调整（如地形高度变化时选取地形高度）。
2. **曲面/多层场景**：若需要支持多层楼层或曲面，需要扩展射线命中逻辑（与 NavMesh 或碰撞系统联动）。
3. **性能优化**：后续可考虑引入射线结果缓存、减少每帧重复转换的次数。

---

## 十、附录
- **相关文档**：
  - `Docs/02-CombatSystem 战斗系统/输入系统/Input-System 输入系统架构设计.md`
  - `Docs/02-CombatSystem 战斗系统/射击系统/Projectile-Shooting-System 射击系统技术设计.md`
- **关键代码位置**：
  - `AstrumProj/Assets/Script/AstrumClient/Input/LSInputAssembler.cs`
  - `AstrumProj/Assets/Script/AstrumLogic/Capabilities/ActionCapability.cs`
  - `AstrumProj/Assets/Script/AstrumLogic/ActionSystem/ActionCommand.cs`
