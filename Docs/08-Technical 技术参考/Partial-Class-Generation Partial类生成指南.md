# UIGenerator Partial Class 生成功能指南

## 功能概述

UIGenerator 现在支持生成 partial class 分离的代码结构，将自动生成的代码和手动编写的逻辑代码分开管理。

### 文件结构

对于UI页面名称为 `MainMenu` 的UI，会生成以下两个文件：

1. **设计器文件**: `MainMenuView.designer.cs` - 自动生成，包含UI元素引用和初始化逻辑
2. **逻辑文件**: `MainMenuView.cs` - 第一次生成后手动编辑，不会被重新生成覆盖

## 设计器文件 (.designer.cs)

### 特点
- ✅ **自动生成**: 每次UI更新时重新生成
- ✅ **包含UI引用**: 所有UI元素的字段定义
- ✅ **包含初始化逻辑**: UI元素的自动初始化
- ✅ **包含基础方法**: Show/Hide等基础功能
- ❌ **不可手动编辑**: 会被重新生成覆盖

### 生成内容
```csharp
// <auto-generated>
// 此文件由UI生成器自动生成，请勿手动修改
// </auto-generated>

using UnityEngine;
using UnityEngine.UI;
using System;
using Astrum.View.UI.Core;

namespace Astrum.View.UI.Generated
{
    /// <summary>
    /// MainMenuView 设计器部分
    /// 由UI生成器自动生成，包含UI元素引用和初始化逻辑
    /// </summary>
    public partial class MainMenuView
    {
        #region UI References
        
        // UI引用
        private UIRefs uiRefs;
        
        // Button/ButtonName
        private Button buttonNameButton;
        
        // Text/StatusText
        private Text statusTextText;
        
        #endregion
        
        #region Properties
        
        public bool IsInitialized => uiRefs != null;
        
        #endregion
        
        #region Initialization
        
        /// <summary>
        /// 初始化UI
        /// </summary>
        public void Initialize(UIRefs refs)
        {
            uiRefs = refs;
            InitializeUIElements();
            OnInitialize();
        }
        
        /// <summary>
        /// 初始化UI元素引用
        /// </summary>
        private void InitializeUIElements()
        {
            buttonNameButton = uiRefs.GetComponent<Button>("Button/ButtonName");
            statusTextText = uiRefs.GetComponent<Text>("Text/StatusText");
        }
        
        #endregion
        
        #region Basic Methods
        
        /// <summary>
        /// 显示UI
        /// </summary>
        public virtual void Show()
        {
            if (uiRefs != null)
            {
                uiRefs.gameObject.SetActive(true);
                OnShow();
            }
        }
        
        /// <summary>
        /// 隐藏UI
        /// </summary>
        public virtual void Hide()
        {
            if (uiRefs != null)
            {
                OnHide();
                uiRefs.gameObject.SetActive(false);
            }
        }
        
        #endregion
    }
}
```

## 逻辑文件 (.cs)

### 特点
- ✅ **手动编辑**: 第一次生成后可以自由编辑
- ✅ **业务逻辑**: 编写UI的业务逻辑代码
- ✅ **不会被覆盖**: 重新生成UI时不会覆盖此文件
- ✅ **虚方法重写**: 可以重写OnInitialize、OnShow、OnHide等方法

### 生成内容
```csharp
// 此文件用于编写UI逻辑代码
// 第一次生成后，可以手动编辑，不会被重新生成覆盖

using UnityEngine;
using UnityEngine.UI;
using System;
using Astrum.View.UI.Core;

namespace Astrum.View.UI.Generated
{
    /// <summary>
    /// MainMenuView 逻辑部分
    /// 用于编写UI的业务逻辑代码
    /// </summary>
    public partial class MainMenuView
    {
        #region Virtual Methods
        
        /// <summary>
        /// 初始化完成后的回调
        /// </summary>
        protected virtual void OnInitialize()
        {
            // 在这里添加初始化逻辑
            SetupButtonEvents();
        }
        
        /// <summary>
        /// 显示时的回调
        /// </summary>
        protected virtual void OnShow()
        {
            // 在这里添加显示逻辑
            RefreshUI();
        }
        
        /// <summary>
        /// 隐藏时的回调
        /// </summary>
        protected virtual void OnHide()
        {
            // 在这里添加隐藏逻辑
            CleanupUI();
        }
        
        #endregion
        
        #region Business Logic
        
        // 在这里添加业务逻辑方法
        private void SetupButtonEvents()
        {
            if (buttonNameButton != null)
            {
                buttonNameButton.onClick.AddListener(OnButtonNameClicked);
            }
        }
        
        private void OnButtonNameClicked()
        {
            // 按钮点击逻辑
            Debug.Log("Button clicked!");
        }
        
        private void RefreshUI()
        {
            // 刷新UI显示
            if (statusTextText != null)
            {
                statusTextText.text = "UI已显示";
            }
        }
        
        private void CleanupUI()
        {
            // 清理UI状态
            if (statusTextText != null)
            {
                statusTextText.text = "";
            }
        }
        
        #endregion
    }
}
```

## 配置选项

在 `UIGeneratorConfig` 中可以配置以下选项：

```csharp
public class CodeGenerationSettings
{
    // 是否使用partial class模式
    public bool UsePartialClass = true;
    
    // 设计器文件后缀
    public string DesignerFileSuffix = ".designer.cs";
    
    // 逻辑文件后缀
    public string LogicFileSuffix = ".cs";
}
```

## 使用方法

### 1. 生成UI代码
1. 在UIGenerator中选择UI文件
2. 点击"生成UI代码"按钮
3. 系统会自动生成两个文件：
   - `{UI页面名}View.designer.cs`
   - `{UI页面名}View.cs`

### 2. 编辑业务逻辑
1. 打开 `{UI页面名}View.cs` 文件
2. 在 `OnInitialize`、`OnShow`、`OnHide` 方法中添加逻辑
3. 在 `Business Logic` 区域添加自定义方法
4. 使用设计器文件中定义的UI元素字段

### 3. 重新生成设计器文件
1. 当UI结构发生变化时
2. 再次点击"生成UI代码"按钮
3. 设计器文件会被重新生成
4. 逻辑文件保持不变

## 状态检查

UIGenerator会检查以下状态：

### 设计器文件状态
- ✅ 文件是否存在
- ✅ 是否包含partial class定义
- ✅ 是否包含Initialize方法
- ✅ 是否包含InitializeUIElements方法
- ✅ 是否包含Show/Hide方法

### 逻辑文件状态
- ✅ 文件是否存在
- ✅ 是否包含partial class定义
- ✅ 是否包含虚方法定义

### 整体状态
- 🟢 **完整**: 两个文件都存在且有效
- 🟡 **部分**: 只有一个文件存在
- 🔴 **错误**: 文件存在但内容无效

## 优势

1. **代码分离**: 自动生成代码和手动编写代码分离
2. **保护逻辑**: 业务逻辑不会被重新生成覆盖
3. **易于维护**: UI结构变化时只需重新生成设计器文件
4. **类型安全**: 所有UI元素都有强类型引用
5. **开发效率**: 自动生成UI引用，减少手动编写

## 注意事项

1. **不要编辑设计器文件**: `.designer.cs` 文件会被重新生成覆盖
2. **使用正确的字段名**: 在逻辑文件中使用设计器文件定义的字段
3. **检查null引用**: 在使用UI元素前检查是否为null
4. **命名规范**: UI元素字段名遵循 `{对象名}{组件类型}` 的命名规则

## 示例：完整的使用流程

1. **创建UI Prefab**: 在Unity中创建包含Button、Text等组件的UI
2. **生成代码**: 使用UIGenerator生成partial class文件
3. **编写逻辑**: 在逻辑文件中添加按钮点击、文本更新等逻辑
4. **测试功能**: 在Unity中测试UI功能
5. **修改UI**: 如果需要修改UI结构，重新生成设计器文件
6. **更新逻辑**: 根据新的UI结构更新业务逻辑

这种设计模式确保了代码的可维护性和开发效率，是现代UI开发的最佳实践。
