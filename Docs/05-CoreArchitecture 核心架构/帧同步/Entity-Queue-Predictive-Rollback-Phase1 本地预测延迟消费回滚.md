# 实体消息队列预测回滚（阶段一）本地预测 · 影子自实体 · 延迟消费

## 背景与目标
- 现有回滚以全局世界为单位，实体间交互紧耦合，回滚与重放成本高。
- 已有消息队列可将交互转为消息，便于按实体拆分、按帧重放。
- 阶段一仅预测“自己”，但引入影子预测实体（自实体的预测镜像），解决预测过程中因外部状态未预测导致的错误输入采样。
- 目标：基于帧号化的按实体消息队列，实现本地零延迟预测，使用影子实体自洽预测并与权威实体比对；权威到达时仅对影子实体回滚重放。

## 术语
- 权威帧：服务器确认的帧编号。
- 预测帧：客户端本地超前执行的帧编号。
- 客户端请求帧号：客户端上报输入时使用的帧号（通常是预测帧号）。
- 服务器下发帧号：服务器实际下发该输入到客户端的帧号（可能因延迟顺延，与请求帧号不同）。

## 关键点
- 发送时只填“预测帧标记”（或权威帧戳），影子用来预测，自身权威实体不直接应用影子发出的消息。
- 所有对战消息统一携带帧戳；按 (entityId, frameId) 分片入队，保持同帧顺序。
- 本地可控实体的预测由“影子自实体”承担；原始实体始终按权威帧推进，且不接收影子消息的副作用。
- 影子实体 ID 约定：`shadowId = -entityId`（仅本地自实体），使用同配置、独立状态。
- 影子在预测帧运行；当权威帧到达，计算原始实体帧哈希与影子同帧哈希：
  - 一致：影子保持前进；原始实体仍权威驱动。
  - 不一致：影子回滚到该权威帧，重放备份输入/消息到当前预测帧。
- 对外消息标记预测帧号，目标实体待权威帧追平后再消费（阶段一不预测他人），影子产生的消息不直接作用于权威实体。

## 数据结构
- 帧索引（双路）：  
  - 权威实体：权威帧索引，仅按帧顺序消费下行权威消息，不缓存输入。  
  - 影子实体：预测帧索引，按预测帧记录并消费“统一的消息输入”。
- 队列：`EntityMessageQueue`，键 `<entityId, frameId>` → `List<Message>`，同帧内保持顺序。
- 备份区（影子专用）：滑动窗口缓存影子已消费的“每个预测帧的全部消息输入”，窗口大小=预测超前最大帧差。权威实体不存输入备份。
- 元信息：帧戳、来源（预测/权威）、顺序号；输入已抽象为消息，与实体间业务消息格式统一，便于备份/重放。
- 影子映射：`shadowId = -entityId`，影子持有独立状态/预测队列，原始实体保持权威状态。

## 发送/消费流程
1) 发送：构造消息 → 填充预测帧标记（或权威帧戳）→ 投递到目标实体分片；仅影子实体立即应用预测逻辑，权威实体不应用影子消息副作用。
2) 消费（权威侧）：原始实体只消费“权威消息”；如果下行消息的权威帧号尚未到达，则先入队，待帧进度追平后再按 (frameId asc, in-frame order) 消费。影子产生的预测消息不会作用于权威实体。
3) 消费（影子侧）：影子实体在预测帧消费本地输入与预测标记消息，用于预演效果，但不对权威实体/其他实体产生直接交互。
4) 备份：影子消费后的输入/消息写入备份区，以供影子回滚重放。

## 回滚流程（影子）
触发：权威帧到达，与影子同帧哈希不一致，或本地预测输入被否决/推迟。
步骤：1) 将影子回退到该权威帧快照；2) 取备份区 (authorityFrame, predictedFrame] 内的输入与消息分片，按帧顺序重放；3) 重新推进到当前预测帧。

### 占位空输入与预测输入顺延
**问题场景**：当网络延迟较高时，客户端上报的输入可能晚1-2帧到达服务器。服务器在未收到输入时会下发"占位空输入"（标记为缺失输入），导致原本有输入的帧变成空输入，下发到客户端后会造成权威实体与影子实体不一致。

**帧号区分**：
- **客户端请求帧号**：客户端上报输入时使用的帧号（通常是预测帧号），客户端本地备份输入时使用此帧号。
- **服务器下发帧号**：服务器实际下发该输入到客户端的帧号。当输入延迟到达时，服务器会将输入顺延到后续帧下发，此时下发帧号 > 请求帧号。
- **映射关系**：客户端需要维护"请求帧号 → 下发帧号"的映射关系，以便在收到服务器下发时正确匹配本地备份的输入。

**解决方案**：
1. **服务器端标记**：服务器在构造 FrameSyncData 时，对"未收到输入而补的空输入"增加显式标记（如 `missing=true`），真实空输入不打标记。同时，服务器下发的输入需要携带原始请求帧号信息，以便客户端匹配。
2. **客户端识别与处理**：
   - 客户端收到占位空输入（带缺失标记）后，识别该帧为"服务器未收到数据导致的占位"。
   - 回滚影子到该权威帧N（此时影子实体与权威实体一致，都是空输入的结果）。
   - **关键操作**：将本地备份的所有预测输入整体后移一位（基于请求帧号）：
     - 原请求帧N的输入 → 请求帧N+1（对应下发帧N+1）
     - 原请求帧N+1的输入 → 请求帧N+2（对应下发帧N+2）
     - 以此类推，所有后续预测输入都后移一位
   - 更新"请求帧号 → 下发帧号"的映射关系，所有映射帧号都+1。
   - 从帧N+1开始，用后移后的输入继续预测。
3. **连续占位处理**：如果下一帧还是占位空输入，继续将预测输入整体后移（再+1），支持连续占位场景。
4. **对齐验证**：当服务器后续下发真正的顺延帧（包含真实输入，携带原始请求帧号）时，客户端通过请求帧号匹配本地备份，通过下发帧号应用到正确的权威帧，确保帧号对齐。

**实现要点**：
- 输入备份数据结构需要支持帧号整体后移（重建字典或维护偏移量），备份时使用请求帧号作为key。
- 需要维护"请求帧号 → 下发帧号"的映射表，支持动态更新（顺延时整体+1，撤销时恢复）。
- 哈希记录（`_shadowFrameHashes`）需要相应处理，确保后续比对正确。
- 回滚重放逻辑需要使用后移后的请求帧号访问输入备份，使用下发帧号应用到正确的权威帧。

**输入覆盖与队列回拉**：
- **服务器端行为**：当输入被推迟后，如果后续收到该帧的原始输入，服务器会用原始输入覆盖推迟后的输入（在推迟后的帧号上）。服务器下发的输入需要携带原始请求帧号信息。
- **客户端识别**：客户端收到服务器下发的输入时，通过原始请求帧号进行鉴别：
  - 如果该请求帧号对应的输入之前已经被推迟（整体后移），说明服务器后续收到了原始输入并覆盖了推迟后的输入。
  - 客户端需要识别这种情况，将原本推迟的队列"拉回来"（撤销之前的后移操作）：
    - 将后移的输入恢复到原始请求帧号位置
    - 更新"请求帧号 → 下发帧号"的映射表，恢复原始映射关系
    - 重新回滚影子到当前权威帧，用恢复后的输入重新预测
- **关键点**：客户端的输入推迟只会影响影子实体的模拟，不会再次上报。但需要能够识别服务器端的覆盖行为，及时撤销后移操作，确保预测输入与服务器实际处理的输入保持一致。

## 监控与参数
- 指标：影子回滚次数、重放耗时、队列深度、预测超前帧差、哈希不一致率。
- 参数：预测超前窗口（建议 3~6 帧）、备份窗口=超前窗口，超过即裁剪。

## 风险与缓解
- 影子频繁回滚：缩小预测窗口或按延迟自适应；高抖动客户端降级为低预测。
- 备份膨胀：窗口裁剪+对象池；必要时压缩。
- 远端体验延迟：可选 UI 提示“远端同步中”，不影响本地零延迟。

## 回滚触发与无输入实体
- 回滚触发以权威帧为批次，不因同一帧多条第三方输入重复回滚。
- 无玩家输入的实体（纯 AI/环境）保持权威驱动，不参与预测。

## 与现有模块衔接（建议）
- FrameSyncHandler：帧号分发、权威帧推进、回滚触发点。
- WorldSnapshotStart/Chunk：权威快照输入，用于回滚基准和状态校正。
- 消息定义：为对战消息补充帧戳字段；分发侧根据 entityId 路由分片。

## 验证与测试
- 单元/组件：帧号标记、队列分片顺序、回滚重放。
- 集成/E2E：本地预测+远端延迟消费场景。
- 观测：日志/统计输出回滚次数、重放耗时、队列深度、超前帧差。

