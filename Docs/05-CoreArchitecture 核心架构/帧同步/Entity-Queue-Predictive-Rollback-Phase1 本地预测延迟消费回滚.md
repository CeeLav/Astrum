# 实体消息队列预测回滚（阶段一）本地预测 · 影子自实体 · 延迟消费

## 背景与目标
- 现有回滚以全局世界为单位，实体间交互紧耦合，回滚与重放成本高。
- 已有消息队列可将交互转为消息，便于按实体拆分、按帧重放。
- 阶段一仅预测“自己”，但引入影子预测实体（自实体的预测镜像），解决预测过程中因外部状态未预测导致的错误输入采样。
- 目标：基于帧号化的按实体消息队列，实现本地零延迟预测，使用影子实体自洽预测并与权威实体比对；权威到达时仅对影子实体回滚重放。

## 术语
- 权威帧：服务器确认的帧编号。
- 预测帧：客户端本地超前执行的帧编号。
- 客户端请求帧号：客户端上报输入时使用的帧号（通常是预测帧号）。
- 服务器下发帧号：服务器实际下发该输入到客户端的帧号（可能因延迟顺延，与请求帧号不同）。

## 关键点
- 发送时只填“预测帧标记”（或权威帧戳），影子用来预测，自身权威实体不直接应用影子发出的消息。
- 所有对战消息统一携带帧戳；按 (entityId, frameId) 分片入队，保持同帧顺序。
- 本地可控实体的预测由“影子自实体”承担；原始实体始终按权威帧推进，且不接收影子消息的副作用。
- 影子实体 ID 约定：`shadowId = -entityId`（仅本地自实体），使用同配置、独立状态。
- 影子在预测帧运行；当权威帧到达，计算原始实体帧哈希与影子同帧哈希：
  - 一致：影子保持前进；原始实体仍权威驱动。
  - 不一致：影子回滚到该权威帧，重放备份输入/消息到当前预测帧。
- 对外消息标记预测帧号，目标实体待权威帧追平后再消费（阶段一不预测他人），影子产生的消息不直接作用于权威实体。

## 数据结构
- 帧索引（双路）：  
  - 权威实体：权威帧索引，仅按帧顺序消费下行权威消息，不缓存输入。  
  - 影子实体：预测帧索引，按预测帧记录并消费“统一的消息输入”。
- 队列：`EntityMessageQueue`，键 `<entityId, frameId>` → `List<Message>`，同帧内保持顺序。
- 备份区（影子专用）：滑动窗口缓存影子已消费的“每个预测帧的全部消息输入”，窗口大小=预测超前最大帧差。权威实体不存输入备份。
- 元信息：帧戳、来源（预测/权威）、顺序号；输入已抽象为消息，与实体间业务消息格式统一，便于备份/重放。
- 影子映射：`shadowId = -entityId`，影子持有独立状态/预测队列，原始实体保持权威状态。

## 发送/消费流程
1) 发送：构造消息 → 填充预测帧标记（或权威帧戳）→ 投递到目标实体分片；仅影子实体立即应用预测逻辑，权威实体不应用影子消息副作用。
2) 消费（权威侧）：原始实体只消费“权威消息”；如果下行消息的权威帧号尚未到达，则先入队，待帧进度追平后再按 (frameId asc, in-frame order) 消费。影子产生的预测消息不会作用于权威实体。
3) 消费（影子侧）：影子实体在预测帧消费本地输入与预测标记消息，用于预演效果，但不对权威实体/其他实体产生直接交互。
4) 备份：影子消费后的输入/消息写入备份区，以供影子回滚重放。

## 回滚流程（影子）
触发：权威帧到达，与影子同帧哈希不一致，或本地预测输入被否决/推迟。
步骤：1) 将影子回退到该权威帧快照；2) 取备份区 (authorityFrame, predictedFrame] 内的输入与消息分片，按帧顺序重放；3) 重新推进到当前预测帧。

### 占位空输入与预测输入顺延
**问题场景**：当网络延迟较高时，客户端上报的输入可能晚1-2帧到达服务器。服务器在未收到输入时会下发"占位空输入"（标记为缺失输入），导致原本有输入的帧变成空输入，下发到客户端后会造成权威实体与影子实体不一致。

**帧号区分**：
- **客户端请求帧号**：客户端上报输入时使用的帧号（通常是预测帧号），客户端本地备份输入时使用此帧号。
- **服务器下发帧号**：服务器实际下发该输入到客户端的帧号。当输入延迟到达时，服务器会将输入顺延到后续帧下发，此时下发帧号 > 请求帧号。
- **映射关系**：客户端需要维护"请求帧号 → 下发帧号"的映射关系，以便在收到服务器下发时正确匹配本地备份的输入。

**解决方案**：
1. **服务器端标记**：服务器在构造 FrameSyncData 时，对"未收到输入而补的空输入"增加显式标记（如 `missing=true`），真实空输入不打标记。同时，服务器下发的输入需要携带原始请求帧号信息，以便客户端匹配。
2. **客户端识别与处理（优化方案）**：
   - 客户端收到占位空输入（带缺失标记）后，识别该帧为"服务器未收到数据导致的占位"。
   - 回滚影子到该权威帧N（此时影子实体与权威实体一致，都是空输入的结果）。
   - **关键优化**：**不再整体移动队列**，队列保持原样（按请求帧号存储），而是通过映射关系动态计算偏移量：
     - 维护"请求帧号 → 下发帧号"的映射表
     - 当收到占位空输入时，更新映射关系：请求帧N → 下发帧N+1（偏移量+1）
     - 后续所有请求帧的映射关系都增加相同的偏移量
     - 在应用输入时，根据映射关系计算偏移量（下发帧号 - 请求帧号），动态应用到正确的帧
   - 从帧N+1开始，通过偏移量计算，用对应的输入继续预测。
3. **连续占位处理**：如果下一帧还是占位空输入，继续增加偏移量（再+1），支持连续占位场景。
4. **输入覆盖与队列回拉**：
   - 当服务器后续收到原始输入并覆盖推迟后的输入时，服务器下发的输入会携带原始请求帧号。
   - 客户端通过原始请求帧号匹配本地备份，发现该请求帧号之前已经被推迟。
   - **关键优化**：**不需要移动队列**，只需要更新映射关系：
     - 将"请求帧号 → 下发帧号"的映射更新为新的下发帧号
     - 偏移量自然变化（如果下发帧号 = 请求帧号，偏移量为0，说明不再推迟）
     - 当偏移量为0时，客户端处理时自然就会跳过被覆盖的输入（因为映射关系已更新）

**实现要点**：
- **输入备份数据结构**：按请求帧号存储，保持不变，不需要移动数据。
- **映射表维护**：维护"请求帧号 → 下发帧号"的映射表，支持动态更新：
  - 当收到占位空输入时，更新映射关系（增加偏移量）
  - 当收到覆盖输入时，更新映射关系（减少或消除偏移量）
- **偏移量计算**：通过映射关系动态计算偏移量（下发帧号 - 请求帧号）：
  - 偏移量 > 0：输入被推迟，需要应用到后续帧
  - 偏移量 = 0：输入未被推迟，正常应用
  - 偏移量变化：说明服务器端发生了覆盖，需要更新映射关系
- **输入应用逻辑**：在应用输入时，根据映射关系计算偏移量，动态应用到正确的帧：
  - 访问输入备份：使用请求帧号（队列key）
  - 应用到权威帧：使用下发帧号（通过映射关系计算）
- **哈希记录处理**：哈希记录需要基于下发帧号进行比对，确保后续比对正确。
- **回滚重放逻辑**：回滚时使用请求帧号访问输入备份，通过映射关系计算下发帧号，应用到正确的权威帧。

**优势**：
- **无需数据移动**：队列保持原样，避免数据拷贝和重建字典的开销。
- **动态计算**：通过映射关系和偏移量动态计算，灵活应对各种场景。
- **自然处理覆盖**：当服务器覆盖输入后，映射关系更新，偏移量自然变化，客户端处理时自然跳过被覆盖的输入。
- **性能优化**：避免了整体移动队列的性能开销，只需要维护轻量级的映射表。

## 监控与参数
- 指标：影子回滚次数、重放耗时、队列深度、预测超前帧差、哈希不一致率。
- 参数：预测超前窗口（建议 3~6 帧）、备份窗口=超前窗口，超过即裁剪。

## 风险与缓解
- 影子频繁回滚：缩小预测窗口或按延迟自适应；高抖动客户端降级为低预测。
- 备份膨胀：窗口裁剪+对象池；必要时压缩。
- 远端体验延迟：可选 UI 提示“远端同步中”，不影响本地零延迟。

## 回滚触发与无输入实体
- 回滚触发以权威帧为批次，不因同一帧多条第三方输入重复回滚。
- 无玩家输入的实体（纯 AI/环境）保持权威驱动，不参与预测。

## 与现有模块衔接（建议）
- FrameSyncHandler：帧号分发、权威帧推进、回滚触发点。
- WorldSnapshotStart/Chunk：权威快照输入，用于回滚基准和状态校正。
- 消息定义：为对战消息补充帧戳字段；分发侧根据 entityId 路由分片。

## 验证与测试
- 单元/组件：帧号标记、队列分片顺序、回滚重放。
- 集成/E2E：本地预测+远端延迟消费场景。
- 观测：日志/统计输出回滚次数、重放耗时、队列深度、超前帧差。

