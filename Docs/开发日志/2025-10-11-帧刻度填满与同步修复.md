# 帧刻度填满与同步修复

> 📅 **日期**: 2025-10-11  
> 🎯 **目标**: 修复帧刻度不填满、不随窗口变化的问题  
> ✅ **状态**: 完成

---

## 🐛 **问题现象**

**轨道区域填满** ✅：
- ✅ 轨道背景已经正确填满
- ✅ Duration虚线显示正常

**帧刻度问题** ❌：
- ❌ 帧刻度只显示到30帧左右就结束，右边有大量空白
- ❌ 帧刻度不随窗口左右拉伸变化
- ❌ 帧刻度和轨道区域不同步滚动

---

## 🔍 **问题分析**

### **根本原因**

**1. 帧刻度没有使用ScrollView**：
- 轨道区域使用了 `ScrollView`，内容可以填满并滚动
- 帧刻度直接在固定 `Rect` 内绘制，内容宽度固定
- 导致帧刻度无法填满，也无法滚动

**2. 帧刻度和轨道不同步**：
- 轨道区域有自己的滚动位置 `_scrollPosition`
- 帧刻度没有使用 `_scrollPosition`
- 导致滚动时帧刻度和轨道错位

**3. 坐标系不一致**：
- 在ScrollView内部，坐标系从 (0, 0) 开始
- 帧刻度的绘制代码使用了 `rect.x + trackHeaderWidth`
- 应该使用 `trackHeaderWidth`（ScrollView内部坐标）

---

## 🔧 **解决方案**

### **核心修复**

**1. 为帧刻度添加ScrollView**：

```csharp
// === 修复前 ❌ ===
public void DrawFrameScale(Rect rect, int totalFrames, int currentFrame)
{
    EditorGUI.DrawRect(rect, COLOR_FRAME_SCALE_BG);
    DrawFrameLines(rect, totalFrames);
    DrawFrameNumbers(rect, totalFrames);
    DrawBorder(rect, COLOR_TIMELINE_BORDER);
}

// === 修复后 ✅ ===
public void DrawFrameScale(Rect rect, int totalFrames, int currentFrame)
{
    EditorGUI.DrawRect(rect, COLOR_FRAME_SCALE_BG);
    
    // 计算内容宽度，与轨道区域保持一致
    float contentWidth = Mathf.Max(
        _layoutCalculator.GetContentWidth() + _layoutCalculator.GetTrackHeaderWidth(),
        rect.width
    );
    
    // 创建ScrollView（与轨道区域共享滚动位置）
    Rect viewRect = new Rect(0, 0, contentWidth, rect.height);
    _scrollPosition = GUI.BeginScrollView(rect, _scrollPosition, viewRect, GUIStyle.none, GUIStyle.none);
    
    // 绘制左侧轨道标题背景区域（与轨道区域对齐）
    float trackHeaderWidth = _layoutCalculator.GetTrackHeaderWidth();
    Rect headerBgRect = new Rect(0, 0, trackHeaderWidth, viewRect.height);
    EditorGUI.DrawRect(headerBgRect, COLOR_TRACK_HEADER);
    DrawVerticalLine(new Vector2(trackHeaderWidth, 0), viewRect.height, COLOR_TRACK_SEPARATOR);
    
    // 绘制刻度线和数字
    DrawFrameLines(viewRect, totalFrames);
    DrawFrameNumbers(viewRect, totalFrames);
    
    GUI.EndScrollView();
    DrawBorder(rect, COLOR_TIMELINE_BORDER);
}
```

**关键点**：
- ✅ 使用相同的 `contentWidth` 计算方式（与轨道区域一致）
- ✅ 共享 `_scrollPosition`（帧刻度和轨道同步滚动）
- ✅ 使用 `GUIStyle.none` 隐藏ScrollView的滚动条（只在轨道区域显示）
- ✅ 绘制左侧标题背景区域（视觉对齐）

---

**2. 修复坐标系**：

```csharp
// === 修复前 ❌ ===
private void DrawFrameLines(Rect rect, int totalFrames)
{
    float startX = rect.x + trackHeaderWidth; // 外部坐标系
    
    for (int frame = 0; frame <= totalFrames; frame++)
    {
        float x = startX + _layoutCalculator.FrameToPixel(frame);
        if (x < rect.x || x > rect.xMax) continue; // 边界检查
        
        // 绘制刻度线（使用 rect.y）
        DrawVerticalLine(new Vector2(x, rect.y + rect.height), ...);
    }
}

// === 修复后 ✅ ===
private void DrawFrameLines(Rect rect, int totalFrames)
{
    float startX = trackHeaderWidth; // ScrollView内部坐标系（从0开始）
    
    for (int frame = 0; frame <= totalFrames; frame++)
    {
        float x = startX + _layoutCalculator.FrameToPixel(frame);
        // ScrollView会自动裁剪，无需边界检查
        
        // 绘制刻度线（使用相对坐标）
        DrawVerticalLine(new Vector2(x, rect.height), ...);
    }
}
```

**同样修复 `DrawFrameNumbers`**：

```csharp
// === 修复前 ❌ ===
float startX = rect.x + trackHeaderWidth;
Rect labelRect = new Rect(x - 20, rect.y + 2, 40, 12);

// === 修复后 ✅ ===
float startX = trackHeaderWidth;
Rect labelRect = new Rect(x - 20, 2, 40, 12);
```

---

## 📊 **效果对比**

### **修复前**

```
帧刻度区域：
┌─────────────────────────────────────────┐
│ [0] [5] [10] [15] [20] [25] [30]       │  ← 刻度在30帧就结束
│                                   [空白]│
└─────────────────────────────────────────┘

轨道区域：
┌─────────────────────────────────────────────────────┐
│ ████████████████████████████████████████ │  ← 轨道填满
└─────────────────────────────────────────────────────┘

问题：
❌ 帧刻度不填满
❌ 帧刻度和轨道宽度不一致
❌ 横向滚动时，帧刻度不动，轨道滚动（错位）
```

### **修复后**

```
帧刻度区域（ScrollView）：
┌──────────────────────────────────────────────────────┐
│ [0] [5] [10] [15] [20] [25] [30]                     │  ← 刻度填满
└──────────────────────────────────────────────────────┘
      ↕ 共享 _scrollPosition
┌──────────────────────────────────────────────────────┐
│ ████████████████████████████████████████             │  ← 轨道填满
└──────────────────────────────────────────────────────┘

效果：
✅ 帧刻度填满整个可用宽度
✅ 帧刻度和轨道宽度完全一致
✅ 横向滚动时，帧刻度和轨道同步滚动
✅ 窗口拉伸时，帧刻度自动调整
```

---

## 🎯 **实现细节**

### **1. ScrollView共享机制**

**关键代码**：
```csharp
// 帧刻度的ScrollView
_scrollPosition = GUI.BeginScrollView(rect, _scrollPosition, viewRect, GUIStyle.none, GUIStyle.none);
//                                      ↑                                    ↑           ↑
//                              共享滚动位置                          隐藏水平滚动条  隐藏垂直滚动条

// 轨道区域的ScrollView
_scrollPosition = GUI.BeginScrollView(rect, _scrollPosition, viewRect);
//                                      ↑
//                               同一个 _scrollPosition 变量
```

**工作原理**：
1. 帧刻度先绘制（更新 `_scrollPosition`）
2. 轨道区域后绘制（使用更新后的 `_scrollPosition`）
3. 如果轨道区域滚动，会更新 `_scrollPosition`
4. 下一帧绘制时，帧刻度使用新的 `_scrollPosition`
5. 结果：两者始终保持同步

### **2. 内容宽度计算**

**统一使用**：
```csharp
float contentWidth = Mathf.Max(
    _layoutCalculator.GetContentWidth() + _layoutCalculator.GetTrackHeaderWidth(),
    rect.width
);
```

**确保**：
- ✅ 帧刻度和轨道使用相同的内容宽度
- ✅ 内容宽度至少填满可用宽度
- ✅ 对于长动画，内容宽度可以超出（允许滚动）

### **3. 坐标系转换**

**ScrollView坐标系规则**：
```
外部坐标系（EditorWindow）：
┌────────────────────────────────────┐
│ (rect.x, rect.y)                   │
│                                    │
│   ScrollView区域                   │
│                                    │
└────────────────────────────────────┘

ScrollView内部坐标系：
┌────────────────────────────────────┐
│ (0, 0)  ← 始终从原点开始           │
│                                    │
│   内容区域 (viewRect)              │
│                                    │
└────────────────────────────────────┘
```

**坐标转换**：
- ❌ 外部：`rect.x + trackHeaderWidth`
- ✅ 内部：`trackHeaderWidth`

---

## 📝 **修改文件清单**

1. ✅ `Timeline/TimelineRenderer.cs`
   - 为 `DrawFrameScale` 添加ScrollView
   - 修复 `DrawFrameLines` 的坐标系
   - 修复 `DrawFrameNumbers` 的坐标系
   - 添加左侧标题背景区域绘制

---

## ✅ **编译结果**

```bash
✅ 编译成功 - 0 errors
✅ 帧刻度使用ScrollView
✅ 帧刻度和轨道同步滚动
✅ 坐标系修复
```

---

## 🎮 **验证步骤**

1. 打开Unity技能动作编辑器
2. 选择一个动作（例如：attack_01）
3. 验证效果：
   - ✅ 帧刻度填满整个宽度
   - ✅ 帧刻度和轨道宽度一致
   - ✅ 横向滚动时，帧刻度和轨道同步
   - ✅ 拉伸窗口时，帧刻度自动调整

---

## 🚀 **其他改进**

### **视觉对齐**

在帧刻度区域添加了左侧标题背景：

```csharp
// 绘制左侧轨道标题背景区域
Rect headerBgRect = new Rect(0, 0, trackHeaderWidth, viewRect.height);
EditorGUI.DrawRect(headerBgRect, COLOR_TRACK_HEADER);
DrawVerticalLine(new Vector2(trackHeaderWidth, 0), viewRect.height, COLOR_TRACK_SEPARATOR);
```

**效果**：
```
帧刻度：
┌───────┬──────────────────────────┐
│ 标题  │ [0] [5] [10] [15] [20]   │
└───────┴──────────────────────────┘
   ↕ 视觉对齐
┌───────┬──────────────────────────┐
│ 被取消│ ◆                        │
├───────┼──────────────────────────┤
│ 特效  │    ◆    ◆                │
├───────┼──────────────────────────┤
│ 音效  │        ◆                 │
└───────┴──────────────────────────┘
```

---

**修复完成！帧刻度现在完美填满并同步！** 🎊

