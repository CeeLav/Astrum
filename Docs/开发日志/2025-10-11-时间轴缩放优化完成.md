# 时间轴缩放优化完成 - Duration 分离显示

> 📅 **日期**: 2025-10-11  
> 🎯 **目标**: 时间轴显示完整动画，但限制编辑在 Duration 内  
> ✅ **状态**: 完成

---

## 🎯 **优化目标**

**问题**：
- 原有实现：时间轴范围 = Duration
- 如果 Duration < AnimationDuration，用户无法看到完整动画
- 用户无法参考动画尾部来配置技能效果

**新实现**：
- **时间轴显示范围** = AnimationDuration（完整动画）
- **可编辑范围** = Duration（技能有效帧数）
- **当前帧移动范围** = Duration
- **事件创建/移动范围** = Duration

**效果**：
- ✅ 用户可以滚动查看完整动画作为参考
- ✅ 但只能在有效帧数内配置技能效果
- ✅ 提供了Duration分界线作为视觉提示

---

## 📊 **视觉效果**

### **时间轴布局**

```
┌─────────────────────────────────────────────────────┐
│ 0    10   20   30   40   50│60   70   80   90  100 │  ← 刻度（到AnimationDuration）
│                             │                       │
│ ◆    ◆    ◆  ████████████  │                       │  ← 事件（仅在Duration内）
│                             │                       │
│            Duration:60      │                       │  ← 橙色虚线分界
│              ↑              │                       │
│         可编辑区域          │    参考区域（只读）    │
└─────────────────────────────────────────────────────┘

说明：
• 左侧（0-60）：可编辑区域，可以创建和移动事件
• 右侧（61-100）：参考区域，只能查看动画，不能编辑
• 橙色虚线：Duration 分界线，标记可编辑区域的右边界
```

### **Duration 边界线**

**视觉特征**：
- 🟠 橙色虚线（Handles.DrawAAPolyLine）
- 📝 标签：`Duration:60`
- 🎨 半透明黑色背景
- ⚡ 虚线效果：10px 实线 + 5px 间隔

---

## 🔧 **技术实现**

### **1. TimelineEditorModule**

**新增字段**：
```csharp
private int _totalFrames = 60;        // 时间轴显示范围（动画总帧数）
private int _maxEditableFrame = 60;   // 可编辑范围（技能Duration）
```

**新增方法**：
```csharp
// 单独设置可编辑帧数
public void SetMaxEditableFrame(int maxFrame)
{
    _maxEditableFrame = Mathf.Max(maxFrame, 1);
    _currentFrame = Mathf.Min(_currentFrame, _maxEditableFrame - 1);
}

// 同时设置总帧数和可编辑帧数
public void SetFrameRange(int totalFrames, int maxEditableFrame)
{
    _totalFrames = Mathf.Max(totalFrames, 1);
    _maxEditableFrame = Mathf.Max(maxEditableFrame, 1);
    _currentFrame = Mathf.Min(_currentFrame, _maxEditableFrame - 1);
}

// 获取可编辑帧数
public int GetMaxEditableFrame()
{
    return _maxEditableFrame;
}
```

**当前帧限制**：
```csharp
public void SetCurrentFrame(int frame)
{
    int oldFrame = _currentFrame;
    _currentFrame = Mathf.Clamp(frame, 0, _maxEditableFrame - 1); // ← 限制到可编辑范围
    
    if (_currentFrame != oldFrame)
    {
        OnCurrentFrameChanged?.Invoke(_currentFrame);
    }
}
```

**渲染边界线**：
```csharp
// 绘制可编辑范围边界线（如果小于总帧数）
if (_maxEditableFrame < _totalFrames)
{
    Rect trackAreaRect = _layoutCalculator.GetTrackAreaRect();
    _renderer.DrawEditableBoundary(trackAreaRect, _maxEditableFrame);
}
```

---

### **2. TimelineRenderer**

**新增方法**：
```csharp
/// <summary>
/// 绘制可编辑范围边界线（Duration分界线）
/// </summary>
public void DrawEditableBoundary(Rect rect, int maxEditableFrame)
{
    // 计算边界线位置
    float x = _layoutCalculator.FrameToPixel(maxEditableFrame) + _layoutCalculator.GetTrackHeaderWidth();
    
    // 绘制虚线
    Handles.BeginGUI();
    Handles.color = new Color(1f, 0.7f, 0.2f, 0.8f); // 橙色
    
    // 绘制虚线效果
    float dashLength = 10f;
    float gapLength = 5f;
    float currentY = rect.y;
    
    while (currentY < rect.yMax)
    {
        float endY = Mathf.Min(currentY + dashLength, rect.yMax);
        Handles.DrawAAPolyLine(3f, new Vector3(x, currentY), new Vector3(x, endY));
        currentY = endY + gapLength;
    }
    
    Handles.EndGUI();
    
    // 绘制标签
    GUIStyle labelStyle = new GUIStyle(EditorStyles.miniLabel);
    labelStyle.normal.textColor = new Color(1f, 0.7f, 0.2f);
    labelStyle.padding = new RectOffset(3, 3, 1, 1);
    labelStyle.fontSize = 9;
    
    string labelText = $"Duration:{maxEditableFrame}";
    Vector2 labelSize = labelStyle.CalcSize(new GUIContent(labelText));
    Rect labelRect = new Rect(x + 5, rect.y + 5, labelSize.x, labelSize.y);
    
    // 绘制半透明背景
    Color oldColor = GUI.color;
    GUI.color = new Color(0.1f, 0.1f, 0.1f, 0.8f);
    EditorGUI.DrawRect(new Rect(labelRect.x - 2, labelRect.y - 1, labelRect.width + 4, labelRect.height + 2), new Color(0.1f, 0.1f, 0.1f, 0.9f));
    GUI.color = oldColor;
    
    GUI.Label(labelRect, labelText, labelStyle);
}
```

---

### **3. TimelineInteraction**

**新增字段**：
```csharp
private int _totalFrames;           // 总帧数（时间轴显示范围）
private int _maxEditableFrame;      // 可编辑帧数（技能Duration）
```

**方法签名更新**：
```csharp
public void HandleInput(
    Rect rect,
    Event evt,
    List<TimelineTrackConfig> tracks,
    Dictionary<string, List<TimelineEvent>> eventsByTrack,
    int currentFrame,
    int totalFrames,
    int maxEditableFrame,  // ← 新增参数
    Vector2 scrollPosition = default)
{
    _currentFrame = currentFrame;
    _totalFrames = totalFrames;
    _maxEditableFrame = maxEditableFrame; // ← 保存可编辑帧数
    _scrollPosition = scrollPosition;
    // ...
}
```

**事件移动限制**：
```csharp
// 边界约束：限制移动，保持事件在 [0, maxEditableFrame-1] 范围内
if (newStartFrame < 0)
{
    newStartFrame = 0;
    newEndFrame = eventLength;
}
else if (newEndFrame > _maxEditableFrame - 1)  // ← 使用可编辑帧数
{
    newEndFrame = _maxEditableFrame - 1;
    newStartFrame = newEndFrame - eventLength;
}
```

**事件大小调整限制**：
```csharp
// 约束：不能小于起始帧，不能超过可编辑帧数-1
newEndFrame = Mathf.Clamp(newEndFrame, _draggingEvent.StartFrame, _maxEditableFrame - 1);  // ← 使用可编辑帧数
```

**新事件创建限制**：
```csharp
TimelineEvent evt = new TimelineEvent
{
    EventId = System.Guid.NewGuid().ToString(),
    TrackType = trackType,
    StartFrame = frame,
    EndFrame = Mathf.Min(frame + 10, _maxEditableFrame - 1), // ← 限制在可编辑范围内
    DisplayName = GetDefaultEventName(trackType)
};
```

---

### **4. SkillActionEditorWindow**

**使用新接口**：
```csharp
// OnActionSelected
int timelineFrames = _selectedSkillAction.AnimationDuration > 0 
    ? _selectedSkillAction.AnimationDuration 
    : _selectedSkillAction.Duration;
int maxEditableFrame = _selectedSkillAction.Duration;

_timelineModule.SetFrameRange(timelineFrames, maxEditableFrame);  // ← 同时设置

// LoadAnimationForAction
_timelineModule.SetFrameRange(animationTotalFrames, action.Duration);

// OnActionModified
int timelineFrames = skillAction.AnimationDuration > 0 
    ? skillAction.AnimationDuration 
    : skillAction.Duration;
_timelineModule.SetFrameRange(timelineFrames, skillAction.Duration);
```

---

## 📝 **修改文件清单**

### **更新文件 (4个)**

1. ✅ `Timeline/TimelineEditorModule.cs`
   - 添加 `_maxEditableFrame` 字段
   - 添加 `SetMaxEditableFrame()` 方法
   - 添加 `SetFrameRange()` 方法
   - 添加 `GetMaxEditableFrame()` 方法
   - 修改 `SetCurrentFrame()` 限制到可编辑范围
   - 修改 `DrawTimeline()` 绘制边界线
   - 修改 `CreateDefaultEvent()` 限制新事件范围
   - 更新 `HandleInput()` 调用传递 maxEditableFrame

2. ✅ `Timeline/TimelineRenderer.cs`
   - 添加 `DrawEditableBoundary()` 方法（50行）
   - 绘制橙色虚线分界线
   - 绘制Duration标签

3. ✅ `Timeline/TimelineInteraction.cs`
   - 添加 `_maxEditableFrame` 字段
   - 更新 `HandleInput()` 签名（添加 maxEditableFrame 参数）
   - 修改事件移动限制（使用 maxEditableFrame）
   - 修改事件调整限制（使用 maxEditableFrame）
   - 修改新事件创建限制（使用 maxEditableFrame）

4. ✅ `Windows/SkillActionEditorWindow.cs`
   - 更新 `OnActionSelected()` 使用 `SetFrameRange()`
   - 更新 `LoadAnimationForAction()` 使用 `SetFrameRange()`
   - 更新 `OnActionModified()` 使用 `SetFrameRange()`

---

## ✅ **编译结果**

```bash
✅ 编译成功 - 0 errors
✅ 所有功能正常
✅ 时间轴缩放符合预期
```

---

## 🎮 **使用示例**

### **示例场景**

**配置**：
- AnimationDuration = 120帧（2秒，完整攻击动画）
- Duration = 60帧（1秒，实际有效攻击时间）

**时间轴表现**：
```
刻度范围：0 ─────────────────────────── 120帧
         ↓                           ↓
编辑区域：0 ─────────── 60帧 │ 参考区域 61-120
         ↑               ↑
    可以创建事件      Duration边界
```

**用户操作**：
1. ✅ 在0-60帧内创建技能效果事件
2. ✅ 在0-60帧内移动事件
3. ✅ 播放头只能移动到0-60帧
4. ✅ 可以滚动查看61-120帧的动画（参考用）
5. ❌ 不能在61-120帧创建或移动事件

---

## 📊 **对比**

| 特性 | 优化前 | 优化后 |
|------|--------|--------|
| **时间轴范围** | 0-60 (Duration) | 0-120 (AnimationDuration) |
| **可编辑范围** | 0-60 | 0-60 (Duration) |
| **参考区域** | ❌ 无 | ✅ 61-120 (只读) |
| **边界提示** | ❌ 无 | ✅ 橙色虚线 + 标签 |
| **当前帧范围** | 0-60 | 0-60 (限制) |
| **事件创建范围** | 0-60 | 0-60 (限制) |
| **事件移动范围** | 0-60 | 0-60 (限制) |
| **查看完整动画** | ❌ 不能 | ✅ 可以 |

---

## 🎯 **用户体验提升**

### **优势**

1. **完整参考**：用户可以看到完整动画来配置技能时机
2. **明确边界**：橙色虚线清晰标记可编辑区域
3. **操作限制**：自动约束，防止在无效帧数配置
4. **直观理解**：可以理解Duration与AnimationDuration的关系

### **适用场景**

**长动画 + 短Duration**：
- 示例：2秒攻击动画（120帧），但只有前1秒（60帧）是有效攻击
- 后1秒是收招动画，用户需要看到完整动作来把握时机
- 但不应该在收招阶段配置攻击判定

**连击技能**：
- 第一段：0-30帧
- 第二段：30-60帧
- Duration=60帧，但动画=120帧（包含收招）
- 用户可以看到完整连击动作

---

## 🚀 **Phase 3 总进度**

```
Phase 3A (触发帧多帧支持): ████████████ 100% ✅
Phase 3B (效果选择器):     ░░░░░░░░░░░░   0% ⏳
Phase 3C (渲染器优化):     ████████████ 100% ✅
时间轴缩放优化:           ████████████ 100% ✅

总进度：75% (3/4 完成)
```

---

**时间轴优化完成！用户体验大幅提升！** 🎊

