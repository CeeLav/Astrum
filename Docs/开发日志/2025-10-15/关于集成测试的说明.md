# 关于集成测试的重要说明

> 📅 日期: 2025-10-15  
> 🎯 目的: 说明项目的集成测试正确写法

---

## ⚠️ 重要发现

项目已有完善的**数据驱动集成测试框架**，不应手动编写传统的集成测试代码！

---

## ❌ 错误做法

```csharp
// ❌ 不要这样写集成测试
[Fact]
public void TestCombat()
{
    // 手动创建 Room, World, Entity
    var room = new Room(1, "Test");
    var world = new World();
    room.MainWorld = world;
    room.Initialize();
    
    var knight1 = EntityFactory.Instance.CreateEntity(1001, world);
    var knight2 = EntityFactory.Instance.CreateEntity(1001, world);
    
    // 手动调用组件方法
    knight1.GetComponent<DynamicStatsComponent>().TakeDamage(...);
    
    // 手动断言
    Assert.True(knight2.GetComponent<DynamicStatsComponent>().Get(...) < ...);
}
```

**问题**:
- 代码量大，重复初始化
- 难以维护
- 不符合项目框架

---

## ✅ 正确做法

### 1. 创建 JSON 测试用例

**文件位置**: `AstrumTest.Shared/Integration/Data/Scenarios/StatsSystem_CombatFlow.json`

```json
{
  "name": "数值系统-战斗流程",
  "description": "测试属性计算、伤害、死亡流程",
  
  "entityTemplates": [
    {
      "templateId": "knight1",
      "roleId": 1001,
      "team": 1,
      "customHealth": 500
    },
    {
      "templateId": "knight2",
      "roleId": 1001,
      "team": 2,
      "customHealth": 500
    }
  ],
  
  "frames": [
    {
      "frameNumber": 0,
      "comment": "创建两个骑士",
      "inputs": [
        {
          "type": "CreateEntity",
          "templateId": "knight1",
          "position": {"x": 0, "y": 0, "z": 0},
          "entityId": "entity_0"
        },
        {
          "type": "CreateEntity",
          "templateId": "knight2",
          "position": {"x": 1.2, "y": 0, "z": 0},
          "entityId": "entity_1"
        }
      ],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "entity_0",
          "resultKey": "knight1_hp"
        },
        {
          "type": "EntityHealth",
          "entityId": "entity_1",
          "resultKey": "knight2_hp"
        },
        {
          "type": "EntityIsAlive",
          "entityId": "entity_0",
          "resultKey": "knight1_alive"
        }
      ],
      "expectedOutputs": {
        "knight1_hp": 500,
        "knight2_hp": 500,
        "knight1_alive": "True"
      }
    },
    {
      "frameNumber": 10,
      "comment": "骑士1攻击骑士2",
      "inputs": [
        {
          "type": "CastSkill",
          "entityId": "entity_0",
          "skillId": 3001,
          "targetId": "entity_1"
        }
      ],
      "queries": [
        {
          "type": "EntityAction",
          "entityId": "entity_0",
          "resultKey": "knight1_action"
        }
      ],
      "expectedOutputs": {
        "knight1_action": "CastingSkill"
      }
    },
    {
      "frameNumber": 30,
      "comment": "技能命中，验证伤害",
      "inputs": [],
      "queries": [
        {
          "type": "EntityHealth",
          "entityId": "entity_1",
          "resultKey": "knight2_hp"
        },
        {
          "type": "EntityIsAlive",
          "entityId": "entity_1",
          "resultKey": "knight2_alive"
        }
      ],
      "expectedOutputs": {
        "knight2_hp": {"min": 400, "max": 490},
        "knight2_alive": "True"
      }
    }
  ]
}
```

### 2. 在测试类中调用

**文件位置**: `AstrumTest.Shared/Integration/IntegrationTests.cs`

```csharp
[Collection("Logic Test Collection")]
[Trait("TestLevel", "Integration")]
public class IntegrationTests
{
    private readonly ITestOutputHelper _output;
    private readonly ConfigFixture _configFixture;
    
    public IntegrationTests(ITestOutputHelper output, ConfigFixture configFixture)
    {
        _output = output;
        _configFixture = configFixture;
    }
    
    /// <summary>
    /// 数值系统 - 战斗流程测试
    /// </summary>
    [Fact]
    [Trait("Module", "StatsSystem")]
    public void StatsSystem_CombatFlow()
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        
        // 只需一行！引擎自动完成：读取 → 初始化 → 执行 → 验证 → 报告
        var result = executor.RunTestCase("StatsSystem_CombatFlow.json");
        
        Assert.True(result.Success, result.FailureMessage);
    }
    
    /// <summary>
    /// 批量测试多个场景
    /// </summary>
    [Theory]
    [InlineData("StatsSystem_CombatFlow.json")]
    [InlineData("StatsSystem_LevelUp.json")]
    [InlineData("StatsSystem_BuffStacking.json")]
    [Trait("Module", "StatsSystem")]
    public void StatsSystem_Scenarios(string scenarioFile)
    {
        using var executor = new LogicTestExecutor(_output, _configFixture);
        var result = executor.RunTestCase(scenarioFile);
        Assert.True(result.Success, result.FailureMessage);
    }
}
```

---

## 🎯 框架特点

### 1. 以帧为单位
每一帧的执行流程：
```
inputs（输入指令）
  ↓
更新游戏逻辑一帧
  ↓
queries（查询状态）
  ↓
expectedOutputs（验证结果）
```

### 2. 支持的输入类型 (Inputs)
- `CreateEntity` - 创建实体
- `DestroyEntity` - 销毁实体
- `CastSkill` - 施放技能
- `Move` - 移动
- `Teleport` - 传送
- `Wait` - 等待

### 3. 支持的查询类型 (Queries)
- `EntityHealth` - 查询实体血量
- `EntityPosition` - 查询实体位置
- `EntityIsAlive` - 查询是否存活
- `EntityAction` - 查询当前动作
- `EntityDistance` - 查询两实体距离

### 4. 支持范围验证
```json
"expectedOutputs": {
  "knight_hp": {"min": 400, "max": 490},  // 范围验证
  "knight_alive": "True"                   // 精确匹配
}
```

---

## 🔧 框架已支持新数值系统

**更新文件**: `AstrumTest.Shared/Integration/Core/LogicTestExecutor.Executors.cs`

- ✅ 使用 `DynamicStatsComponent.Set(DynamicResourceType.CURRENT_HP, ...)` 设置血量
- ✅ 使用 `DynamicStatsComponent.Get(DynamicResourceType.CURRENT_HP)` 查询血量
- ✅ 使用 `StateComponent.Get(StateType.DEAD)` 判断死亡状态

---

## 📚 参考文档

详细设计方案：`AstrumTest/集成测试框架设计方案.md`

---

## 💡 优势对比

| 维度 | 传统手写 | 数据驱动框架 |
|------|---------|-------------|
| **代码量** | 50+ 行/测试 | 2-3 行/测试 |
| **维护性** | 难维护 | 易维护（只改JSON） |
| **可读性** | 代码混乱 | JSON清晰 |
| **非程序员** | 无法编写 | 可以编写 |
| **重复代码** | 大量重复 | 无重复 |
| **测试覆盖** | 手动控制 | 自动验证 |

---

## ✅ 结论

1. **不要手动编写集成测试类**
2. **使用 JSON 文件定义测试用例**
3. **测试代码只需调用 `executor.RunTestCase("file.json")`**
4. **框架已支持新数值系统**
5. **参考现有的 `TwoKnightsFight.json`**

---

**最后更新**: 2025-10-15

