# 动画根节点位移提取方案

## 1. 方案概述

本方案旨在在技能动作编辑器中加载动画时，自动提取动画的根节点位移（Root Motion）数据，并将其转换成适合运行时使用的数据结构，用于技能动作执行过程中的位移逻辑。

### 1.1 目标

- **编辑器端**：在加载动画时提取 Root Motion 数据，存储为每帧的位置和旋转信息
- **运行时**：根据当前动作帧索引，读取对应的位移数据，应用到逻辑层的实体位置
- **数据格式**：使用定点数（TrueSync）兼容的位置和旋转，支持帧同步

### 1.2 应用场景

- 技能动作的前冲、后跳等位移效果
- 动作过程中的轨迹编辑和可视化
- 位移动画在网格上的精确观察（已实现网格显示）

## 2. 技术方案

### 2.1 Root Motion 提取原理

Unity 的 `AnimationClip` 可以包含根节点的位移和旋转信息。通过以下方式提取：

1. **检查是否有 Root Motion 曲线**
   - 使用 `AnimationClip.hasRootMotion` 判断
   - 检查根节点的 `localPosition` 和 `localRotation` 曲线

2. **按帧采样动画数据**
   - 游戏逻辑帧率：20fps（50ms/帧）
   - 对动画进行逐帧采样，获取每帧的位移和旋转

3. **转换为相对位移**
   - 第一帧作为起始参考点（位置=0,旋转=identity）
   - 后续每帧记录相对于起始位置的累积位移

### 2.2 数据结构设计

#### 2.2.1 编辑器端数据结构

```csharp
/// <summary>
/// 动画根节点位移数据（编辑器端，使用浮点数）
/// </summary>
[Serializable]
public class AnimationRootMotionData
{
    /// <summary>
    /// 每帧的位移数据
    /// </summary>
    public List<RootMotionFrameData> Frames = new List<RootMotionFrameData>();
    
    /// <summary>
    /// 动画总帧数（逻辑帧）
    /// </summary>
    public int TotalFrames;
    
    /// <summary>
    /// 是否有有效的位移数据
    /// </summary>
    public bool HasMotion => Frames != null && Frames.Count > 0;
}

/// <summary>
/// 单帧位移数据（编辑器端）
/// </summary>
[Serializable]
public class RootMotionFrameData
{
    /// <summary>
    /// 帧索引（从0开始）
    /// </summary>
    public int FrameIndex;
    
    /// <summary>
    /// 相对位置（相对于起始位置的累积位移）
    /// </summary>
    public Vector3 RelativePosition;
    
    /// <summary>
    /// 相对旋转（相对于起始旋转的累积旋转）
    /// </summary>
    public Quaternion RelativeRotation;
    
    /// <summary>
    /// 相对于上一帧的增量位置
    /// </summary>
    public Vector3 DeltaPosition;
    
    /// <summary>
    /// 相对于上一帧的增量旋转
    /// </summary>
    public Quaternion DeltaRotation;
}
```

#### 2.2.2 运行时数据结构

```csharp
/// <summary>
/// 动画根节点位移数据（运行时，使用定点数）
/// </summary>
[MemoryPackable]
public partial class AnimationRootMotionData
{
    /// <summary>
    /// 每帧的位移数据
    /// </summary>
    public List<RootMotionFrameData> Frames = new List<RootMotionFrameData>();
    
    /// <summary>
    /// 动画总帧数（逻辑帧）
    /// </summary>
    public int TotalFrames;
}

/// <summary>
/// 单帧位移数据（运行时，使用定点数）
/// </summary>
[MemoryPackable]
public partial class RootMotionFrameData
{
    /// <summary>
    /// 帧索引（从0开始）
    /// </summary>
    public int FrameIndex;
    
    /// <summary>
    /// 相对位置（TrueSync 定点数）
    /// </summary>
    public TSVector RelativePosition;
    
    /// <summary>
    /// 相对旋转（TrueSync 定点数）
    /// </summary>
    public TSQuaternion RelativeRotation;
    
    /// <summary>
    /// 相对于上一帧的增量位置（TrueSync 定点数）
    /// </summary>
    public TSVector DeltaPosition;
    
    /// <summary>
    /// 相对于上一帧的增量旋转（TrueSync 定点数）
    /// </summary>
    public TSQuaternion DeltaRotation;
}
```

### 2.3 存储格式设计

#### 2.3.1 数组存储格式（紧凑高效）

在 `SkillActionTable` 中新增字段：

| 字段名 | 类型 | Luban 类型定义 | 说明 |
|--------|------|---------------|------|
| `root_motion_data` | `List<int>` | `array,int#sep=,` | 数组格式的根节点位移数据（可选，逗号分隔的整型数组） |

**存储策略**：
- ✅ **使用扁平数组**：避免 JSON 的字段名、括号等冗余信息
- ✅ **整型存储**：所有浮点数乘以 1000 后存储为整型，运行时直接转为定点数
- ✅ **包含位移和旋转**：每帧存储 `DeltaPosition (x, y, z)` 和 `DeltaRotation (x, y, z, w)` 四元数
- ✅ **紧凑高效**：整型占用空间小，解析速度快，无需浮点转换

**数据格式**：
```
格式: "frameCount,dx0,dy0,dz0,rx0,ry0,rz0,rw0,dx1,dy1,dz1,rx1,ry1,rz1,rw1,..."
示例: "60,0,0,0,0,0,0,1000,50,0,0,0,0,0,1000,100,0,0,0,0,0,1000,..."
```

- **第 1 个数字**：总帧数（`frameCount`，整型）
- **后续每 7 个数字**：代表一帧的数据
  - `dx, dy, dz`：DeltaPosition (x, y, z)，整型（实际值 * 1000）
  - `rx, ry, rz, rw`：DeltaRotation 四元数 (x, y, z, w)，整型（实际值 * 1000）
- **数据量**：`1 + frameCount * 7` 个整型数字

**数值转换规则**：
- **存储时**：浮点数 `value` → 整型 `(int)(value * 1000)`
- **读取时**：整型 `intValue` → 定点数 `(FP)(intValue) / 1000`

**示例对比**：

| 格式 | 60帧数据大小 | 说明 |
|------|------------|------|
| **JSON** | ~8 KB | 包含字段名、括号等冗余信息 |
| **数组（浮点）** | ~1 KB | 仅存储必要的数值数据 |
| **数组（整型）** | **~0.6 KB** | 整型存储更紧凑，且便于定点数转换 |
| **压缩比** | **约 13:1** | 显著减少存储空间 |

**完整示例**（60帧动画）：
```csv
##var,actionId,actualCost,actualCooldown,triggerFrames,rootMotionData
##type,int,int,int,string,array,int#sep=,
##group,,,,,
##desc,动作ID,实际法力消耗,实际冷却时间(帧),触发帧信息(含碰撞盒),根节点位移数据
,3001,20,100,Frame10:Collision:4001,"60,0,0,0,0,0,0,1000,50,0,0,0,0,0,1000,100,0,0,0,0,0,1000,80,0,0,0,0,0,1000,..."
```

**数据格式说明**：
- Luban 类型：`array,int#sep=,` （逗号分隔的整数数组）
- CSV 存储：在一个单元格中用逗号分隔，如 `"60,0,0,0,0,0,0,1000,..."`
- 运行时类型：Luban 会自动解析为 `List<int>` 或 `int[]`

**运行时使用**：
```csharp
// Luban 生成的 SkillActionTable 中
var skillActionTable = configManager.Tables.TbSkillActionTable.Get(actionId);
List<int> rootMotionDataArray = skillActionTable.RootMotionData; // 已解析为数组

// 直接使用数组转换（推荐，最高效）
var runtimeData = AnimationRootMotionExtractor.ConvertToRuntimeFromIntArray(rootMotionDataArray);
```

**优势**：
- ✅ Luban 自动解析：CSV 中的 `"60,0,0,0,..."` 自动解析为 `List<int>`
- ✅ 无需字符串解析：直接使用数组，避免 `Split(',')` 和 `TryParse()` 的开销
- ✅ 类型安全：编译时类型检查，避免运行时解析错误

## 3. 实现方案

### 3.1 编辑器端实现

#### 3.1.1 Root Motion 提取服务

创建 `AnimationRootMotionExtractor.cs`：

```csharp
using UnityEngine;
using UnityEditor;

namespace Astrum.Editor.RoleEditor.Services
{
    /// <summary>
    /// 动画根节点位移提取服务
    /// </summary>
    public static class AnimationRootMotionExtractor
    {
        private const float LOGIC_FRAME_RATE = 20f;  // 游戏逻辑帧率：20fps
        private const float FRAME_TIME = 0.05f;      // 每帧时间：50ms
        
        /// <summary>
        /// 从动画片段提取根节点位移数据
        /// </summary>
        /// <param name="clip">动画片段</param>
        /// <returns>根节点位移数据，如果动画没有Root Motion则返回null</returns>
        public static AnimationRootMotionData ExtractRootMotion(AnimationClip clip)
        {
            if (clip == null)
            {
                Debug.LogWarning("[AnimationRootMotionExtractor] AnimationClip is null");
                return null;
            }
            
            // 检查是否有Root Motion
            if (!clip.hasRootMotion)
            {
                Debug.Log($"[AnimationRootMotionExtractor] Animation {clip.name} has no root motion");
                return null;
            }
            
            var motionData = new AnimationRootMotionData();
            
            // 计算总帧数
            int totalFrames = Mathf.RoundToInt(clip.length * LOGIC_FRAME_RATE);
            motionData.TotalFrames = totalFrames;
            
            // 创建临时GameObject用于采样动画
            GameObject tempGO = new GameObject("TempRootMotionSampler");
            tempGO.hideFlags = HideFlags.HideAndDontSave;
            
            // 添加Animation组件
            Animation anim = tempGO.AddComponent<Animation>();
            anim.AddClip(clip, "RootMotionSample");
            anim.clip = clip;
            
            // 获取起始位置和旋转（第0帧）
            anim["RootMotionSample"].time = 0f;
            anim.Sample();
            Vector3 startPosition = tempGO.transform.localPosition;
            Quaternion startRotation = tempGO.transform.localRotation;
            
            // 逐帧采样
            for (int frame = 0; frame < totalFrames; frame++)
            {
                float time = frame * FRAME_TIME;
                
                // 采样动画到指定时间
                anim["RootMotionSample"].time = time;
                anim.Sample();
                
                Vector3 currentPosition = tempGO.transform.localPosition;
                Quaternion currentRotation = tempGO.transform.localRotation;
                
                // 计算相对位置和旋转
                Vector3 relativePosition = currentPosition - startPosition;
                Quaternion relativeRotation = currentRotation * Quaternion.Inverse(startRotation);
                
                // 计算增量位移（相对于上一帧）
                Vector3 deltaPosition = Vector3.zero;
                Quaternion deltaRotation = Quaternion.identity;
                
                if (frame > 0)
                {
                    float prevTime = (frame - 1) * FRAME_TIME;
                    anim["RootMotionSample"].time = prevTime;
                    anim.Sample();
                    
                    Vector3 prevPosition = tempGO.transform.localPosition;
                    Quaternion prevRotation = tempGO.transform.localRotation;
                    
                    deltaPosition = currentPosition - prevPosition;
                    deltaRotation = currentRotation * Quaternion.Inverse(prevRotation);
                }
                
                // 添加到帧数据列表
                motionData.Frames.Add(new RootMotionFrameData
                {
                    FrameIndex = frame,
                    RelativePosition = relativePosition,
                    RelativeRotation = relativeRotation,
                    DeltaPosition = deltaPosition,
                    DeltaRotation = deltaRotation
                });
            }
            
            // 清理临时对象
            Object.DestroyImmediate(tempGO);
            
            Debug.Log($"[AnimationRootMotionExtractor] Extracted root motion for {clip.name}: {totalFrames} frames");
            
            return motionData;
        }
        
        /// <summary>
        /// 将编辑器端数据序列化为整型数组（用于存储到CSV，Luban格式：array,int#sep=,）
        /// 所有浮点数乘以 1000 后转为整型存储，便于运行时转换为定点数
        /// </summary>
        /// <param name="motionData">根节点位移数据</param>
        /// <returns>整型数组，如果数据为空则返回空列表</returns>
        public static List<int> SerializeToIntArray(AnimationRootMotionData motionData)
        {
            if (motionData == null || !motionData.HasMotion || motionData.Frames == null || motionData.Frames.Count == 0)
            {
                return new List<int>();
            }
            
            // 格式: [frameCount, dx0, dy0, dz0, rx0, ry0, rz0, rw0, dx1, dy1, dz1, rx1, ry1, rz1, rw1, ...]
            var result = new List<int> { motionData.Frames.Count };
            
            const int SCALE = 1000; // 缩放因子
            
            foreach (var frame in motionData.Frames)
            {
                // DeltaPosition (x, y, z) - 浮点数 * 1000 转为整型
                result.Add((int)(frame.DeltaPosition.x * SCALE));
                result.Add((int)(frame.DeltaPosition.y * SCALE));
                result.Add((int)(frame.DeltaPosition.z * SCALE));
                
                // DeltaRotation 四元数 (x, y, z, w) - 浮点数 * 1000 转为整型
                result.Add((int)(frame.DeltaRotation.x * SCALE));
                result.Add((int)(frame.DeltaRotation.y * SCALE));
                result.Add((int)(frame.DeltaRotation.z * SCALE));
                result.Add((int)(frame.DeltaRotation.w * SCALE));
            }
            
            return result;
        }
        
        /// <summary>
        /// 将编辑器端数据序列化为数组格式字符串（用于兼容或调试）
        /// 注意：Luban 使用数组格式时，推荐使用 SerializeToIntArray() 返回 List<int>
        /// </summary>
        /// <param name="motionData">根节点位移数据</param>
        /// <returns>数组格式字符串（整型），如果数据为空则返回空字符串</returns>
        public static string SerializeToArrayString(AnimationRootMotionData motionData)
        {
            var intArray = SerializeToIntArray(motionData);
            if (intArray == null || intArray.Count == 0)
            {
                return string.Empty;
            }
            return string.Join(",", intArray);
        }
        
        /// <summary>
        /// 从数组格式字符串反序列化根节点位移数据（从CSV读取）
        /// 整型数据除以 1000 转为浮点数，便于编辑器端使用
        /// </summary>
        /// <param name="arrayString">数组格式字符串（整型）</param>
        /// <returns>根节点位移数据，如果字符串为空或格式错误则返回null</returns>
        public static AnimationRootMotionData DeserializeFromArrayString(string arrayString)
        {
            if (string.IsNullOrEmpty(arrayString) || string.IsNullOrWhiteSpace(arrayString))
            {
                return null;
            }
            
            var parts = arrayString.Split(',');
            if (parts.Length < 1)
            {
                Debug.LogWarning("[AnimationRootMotionExtractor] Invalid array format: empty string");
                return null;
            }
            
            // 解析帧数
            if (!int.TryParse(parts[0].Trim(), out int frameCount) || frameCount <= 0)
            {
                Debug.LogWarning($"[AnimationRootMotionExtractor] Invalid frame count: {parts[0]}");
                return null;
            }
            
            // 验证数据长度：1 (frameCount) + frameCount * 7 (dx,dy,dz,rx,ry,rz,rw) = 1 + 7*frameCount
            int expectedLength = 1 + frameCount * 7;
            if (parts.Length < expectedLength)
            {
                Debug.LogWarning($"[AnimationRootMotionExtractor] Invalid array length: expected {expectedLength}, got {parts.Length}");
                return null;
            }
            
            const float SCALE = 1000.0f; // 缩放因子（与序列化时一致）
            
            var motionData = new AnimationRootMotionData
            {
                TotalFrames = frameCount
            };
            
            // 解析每帧的位移和旋转数据
            for (int frame = 0; frame < frameCount; frame++)
            {
                int baseIndex = 1 + frame * 7; // 跳过 frameCount，每帧7个值 (dx,dy,dz,rx,ry,rz,rw)
                
                // 解析位移 (dx, dy, dz)
                if (!int.TryParse(parts[baseIndex].Trim(), out int dxInt) ||
                    !int.TryParse(parts[baseIndex + 1].Trim(), out int dyInt) ||
                    !int.TryParse(parts[baseIndex + 2].Trim(), out int dzInt))
                {
                    Debug.LogWarning($"[AnimationRootMotionExtractor] Failed to parse frame {frame} position data");
                    continue;
                }
                
                // 解析旋转四元数 (rx, ry, rz, rw)
                if (!int.TryParse(parts[baseIndex + 3].Trim(), out int rxInt) ||
                    !int.TryParse(parts[baseIndex + 4].Trim(), out int ryInt) ||
                    !int.TryParse(parts[baseIndex + 5].Trim(), out int rzInt) ||
                    !int.TryParse(parts[baseIndex + 6].Trim(), out int rwInt))
                {
                    Debug.LogWarning($"[AnimationRootMotionExtractor] Failed to parse frame {frame} rotation data");
                    continue;
                }
                
                // 整型转浮点数（除以 1000）
                Vector3 deltaPosition = new Vector3(
                    dxInt / SCALE,
                    dyInt / SCALE,
                    dzInt / SCALE
                );
                
                Quaternion deltaRotation = new Quaternion(
                    rxInt / SCALE,
                    ryInt / SCALE,
                    rzInt / SCALE,
                    rwInt / SCALE
                );
                
                motionData.Frames.Add(new RootMotionFrameData
                {
                    FrameIndex = frame,
                    DeltaPosition = deltaPosition,
                    DeltaRotation = deltaRotation,
                    // 编辑器端保留这些字段用于预览和调试
                    RelativePosition = Vector3.zero,
                    RelativeRotation = Quaternion.identity
                });
            }
            
            return motionData;
        }
        
        /// <summary>
        /// 从整型数组直接转换为运行时数据（整型转定点数）
        /// 这是运行时推荐的方式，Luban 已经将 CSV 数据解析为 List<int>，直接使用
        /// </summary>
        /// <param name="intArray">整型数组（Luban 解析后的格式）</param>
        /// <returns>运行时根节点位移数据，如果数组为空或格式错误则返回null</returns>
        public static Runtime.AnimationRootMotionData ConvertToRuntimeFromIntArray(List<int> intArray)
        {
            if (intArray == null || intArray.Count == 0)
            {
                return null;
            }
            
            // 解析帧数
            if (intArray.Count < 1)
            {
                return null;
            }
            
            int frameCount = intArray[0];
            if (frameCount <= 0)
            {
                return null;
            }
            
            // 验证数据长度：1 (frameCount) + frameCount * 7 (dx,dy,dz,rx,ry,rz,rw) = 1 + 7*frameCount
            int expectedLength = 1 + frameCount * 7;
            if (intArray.Count < expectedLength)
            {
                return null;
            }
            
            const FP SCALE = (FP)1000; // 缩放因子（定点数）
            
            var runtimeData = new Runtime.AnimationRootMotionData
            {
                TotalFrames = frameCount
            };
            
            // 直接从整型转换为定点数
            for (int frame = 0; frame < frameCount; frame++)
            {
                int baseIndex = 1 + frame * 7; // 跳过 frameCount，每帧7个值
                
                int dxInt = intArray[baseIndex];
                int dyInt = intArray[baseIndex + 1];
                int dzInt = intArray[baseIndex + 2];
                int rxInt = intArray[baseIndex + 3];
                int ryInt = intArray[baseIndex + 4];
                int rzInt = intArray[baseIndex + 5];
                int rwInt = intArray[baseIndex + 6];
                
                // 整型直接转定点数（除以 1000）
                runtimeData.Frames.Add(new Runtime.RootMotionFrameData
                {
                    FrameIndex = frame,
                    DeltaPosition = new TSVector(
                        (FP)dxInt / SCALE,
                        (FP)dyInt / SCALE,
                        (FP)dzInt / SCALE
                    ),
                    DeltaRotation = new TSQuaternion(
                        (FP)rxInt / SCALE,
                        (FP)ryInt / SCALE,
                        (FP)rzInt / SCALE,
                        (FP)rwInt / SCALE
                    ),
                    RelativePosition = TSVector.zero,
                    RelativeRotation = TSQuaternion.identity
                });
            }
            
            return runtimeData;
        }
        
        /// <summary>
        /// 从数组格式字符串直接转换为运行时数据（整型转定点数）
        /// 兼容方法：如果数据已经是字符串格式，使用此方法
        /// 注意：Luban 使用数组格式时，推荐使用 ConvertToRuntimeFromIntArray()
        /// </summary>
        /// <param name="arrayString">数组格式字符串（整型）</param>
        /// <returns>运行时根节点位移数据，如果字符串为空或格式错误则返回null</returns>
        public static Runtime.AnimationRootMotionData ConvertToRuntimeFromArrayString(string arrayString)
        {
            if (string.IsNullOrEmpty(arrayString) || string.IsNullOrWhiteSpace(arrayString))
            {
                return null;
            }
            
            var parts = arrayString.Split(',');
            if (parts.Length < 1)
            {
                return null;
            }
            
            // 解析帧数
            if (!int.TryParse(parts[0].Trim(), out int frameCount) || frameCount <= 0)
            {
                return null;
            }
            
            // 验证数据长度
            int expectedLength = 1 + frameCount * 7;
            if (parts.Length < expectedLength)
            {
                return null;
            }
            
            const FP SCALE = (FP)1000; // 缩放因子（定点数）
            
            var runtimeData = new Runtime.AnimationRootMotionData
            {
                TotalFrames = frameCount
            };
            
            // 直接从整型转换为定点数
            for (int frame = 0; frame < frameCount; frame++)
            {
                int baseIndex = 1 + frame * 7;
                
                if (!int.TryParse(parts[baseIndex].Trim(), out int dxInt) ||
                    !int.TryParse(parts[baseIndex + 1].Trim(), out int dyInt) ||
                    !int.TryParse(parts[baseIndex + 2].Trim(), out int dzInt) ||
                    !int.TryParse(parts[baseIndex + 3].Trim(), out int rxInt) ||
                    !int.TryParse(parts[baseIndex + 4].Trim(), out int ryInt) ||
                    !int.TryParse(parts[baseIndex + 5].Trim(), out int rzInt) ||
                    !int.TryParse(parts[baseIndex + 6].Trim(), out int rwInt))
                {
                    continue;
                }
                
                // 整型直接转定点数（除以 1000）
                runtimeData.Frames.Add(new Runtime.RootMotionFrameData
                {
                    FrameIndex = frame,
                    DeltaPosition = new TSVector(
                        (FP)dxInt / SCALE,
                        (FP)dyInt / SCALE,
                        (FP)dzInt / SCALE
                    ),
                    DeltaRotation = new TSQuaternion(
                        (FP)rxInt / SCALE,
                        (FP)ryInt / SCALE,
                        (FP)rzInt / SCALE,
                        (FP)rwInt / SCALE
                    ),
                    // 运行时不需要 RelativePosition，可以根据 DeltaPosition 累积计算
                    RelativePosition = TSVector.zero,
                    RelativeRotation = TSQuaternion.identity
                });
            }
            
            return runtimeData;
        }
        
        /// <summary>
        /// 将编辑器端数据转换为运行时数据（浮点数转定点数）
        /// 注意：如果已有数组字符串，建议直接使用 ConvertToRuntimeFromArrayString
        /// </summary>
        public static Runtime.AnimationRootMotionData ConvertToRuntime(
            AnimationRootMotionData editorData)
        {
            if (editorData == null || !editorData.HasMotion)
                return null;
            
            var runtimeData = new Runtime.AnimationRootMotionData
            {
                TotalFrames = editorData.TotalFrames
            };
            
            foreach (var frame in editorData.Frames)
            {
                runtimeData.Frames.Add(new Runtime.RootMotionFrameData
                {
                    FrameIndex = frame.FrameIndex,
                    DeltaPosition = new TSVector(
                        (FP)frame.DeltaPosition.x,
                        (FP)frame.DeltaPosition.y,
                        (FP)frame.DeltaPosition.z
                    ),
                    DeltaRotation = new TSQuaternion(
                        (FP)frame.DeltaRotation.x,
                        (FP)frame.DeltaRotation.y,
                        (FP)frame.DeltaRotation.z,
                        (FP)frame.DeltaRotation.w
                    ),
                    RelativePosition = TSVector.zero,
                    RelativeRotation = TSQuaternion.identity
                });
            }
            
            return runtimeData;
        }
    }
}
```

#### 3.1.2 编辑器数据模型扩展

在 `SkillActionEditorData.cs` 中添加：

```csharp
[TitleGroup("动画位移")]
[LabelText("根节点位移数据")]
[InfoBox("从动画文件自动提取，用于运行时位移逻辑", InfoMessageType.Info)]
[HideInInspector]
public AnimationRootMotionData RootMotionData;

/// <summary>
/// 根节点位移数据（整型数组格式，用于保存到CSV）
/// Luban 类型：array,int#sep=,
/// </summary>
[HideInInspector]
public List<int> RootMotionDataArray = new List<int>();
```

#### 3.1.3 在编辑器窗口集成

在 `SkillActionEditorWindow.cs` 的 `LoadAnimationForAction` 方法中添加：

```csharp
private void LoadAnimationForAction(SkillActionEditorData action)
{
    if (action == null || _previewModule == null)
        return;
    
    if (string.IsNullOrEmpty(action.AnimationPath))
    {
        Debug.LogWarning($"[SkillActionEditor] No animation path for action {action.ActionId}");
        _previewModule.Stop();
        return;
    }
    
    // 加载动画片段
    AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(action.AnimationPath);
    _previewModule.LoadAnimationFromPath(action.AnimationPath);
    
    // 提取根节点位移数据
    if (clip != null)
    {
        action.RootMotionData = AnimationRootMotionExtractor.ExtractRootMotion(clip);
        
        if (action.RootMotionData != null && action.RootMotionData.HasMotion)
        {
            // 将位移数据序列化为整型数组（用于保存到CSV，Luban格式：array,int#sep=,）
            action.RootMotionDataArray = AnimationRootMotionExtractor.SerializeToIntArray(action.RootMotionData);
            
            Debug.Log($"[SkillActionEditor] Extracted root motion for action {action.ActionId}: " +
                      $"{action.RootMotionData.TotalFrames} frames, " +
                      $"data array size: {action.RootMotionDataArray.Count} integers");
        }
        else
        {
            action.RootMotionDataArray = new List<int>();
        }
    }
    
    // 计算动画总帧数
    int animationTotalFrames = _previewModule.GetTotalFrames();
    
    if (animationTotalFrames > 0)
    {
        action.AnimationDuration = animationTotalFrames;
        
        if (action.Duration <= 0 || action.Duration > animationTotalFrames)
        {
            action.Duration = animationTotalFrames;
        }
        
        _timelineModule.SetFrameRange(animationTotalFrames, action.Duration);
    }
}
```

### 3.2 运行时实现

#### 3.2.1 位移应用逻辑

**使用 `SkillDisplacementCapability` 处理技能位移**

位移应用逻辑已封装在独立的 `SkillDisplacementCapability` 中，无需在其他能力中添加代码。该能力会在每逻辑帧自动：

1. 检查当前动作是否为技能动作（`SkillActionInfo`）
2. 检查是否有根节点位移数据（`RootMotionData`）
3. 应用当前帧的增量位移和旋转
4. 更新 `TransComponent.Position` 和 `Rotation`

**实现位置**：
- 完整实现参考：[SkillDisplacementCapability 技能位移能力](../02-CombatSystem%20战斗系统/移动-位移/SkillDisplacementCapability%20技能位移能力.md)

**核心逻辑**：
```csharp
// SkillDisplacementCapability.Tick() 中：
// 1. 从 ActionComponent 获取当前动作和帧索引
var actionComponent = GetOwnerComponent<ActionComponent>();
var skillAction = actionComponent.CurrentAction as SkillActionInfo;
int currentFrame = actionComponent.CurrentFrame;

// 2. 检查是否有位移数据
if (skillAction?.RootMotionData != null && 
    skillAction.RootMotionData.Frames != null &&
    skillAction.RootMotionData.Frames.Count > 0)
{
    // 3. 应用当前帧的位移和旋转
    ApplyRootMotion(skillAction, currentFrame);
}

// ApplyRootMotion() 方法：
// - 读取当前帧的 DeltaPosition 和 DeltaRotation
// - 局部空间转世界空间（基于角色朝向）
// - 更新 TransComponent.Position 和 Rotation
// - 同步物理世界位置
```

**优势**：
- ✅ 职责分离：技能位移逻辑独立封装
- ✅ 自动运行：每逻辑帧自动检查和应用
- ✅ 易于扩展：支持位移和旋转，可扩展位移限制等功能

#### 3.2.2 配置加载

在 `ActionConfigManager` 中添加根节点位移数据的加载：

```csharp
/// <summary>
/// 获取动作信息（包含根节点位移数据）
/// </summary>
public ActionInfo GetAction(int actionId, int entityId)
{
    // ... 现有代码 ...
    
    // 加载根节点位移数据（如果存在）
    // Luban 已经将 CSV 中的数组解析为 List<int>，直接使用
    if (skillActionTable?.RootMotionData != null && 
        skillActionTable.RootMotionData.Count > 0)
    {
        try
        {
            // 直接从整型数组转换为运行时数据（整型转定点数）
            // 这是最高效的方式，Luban 已解析为数组，无需字符串解析
            actionInfo.RootMotionData = AnimationRootMotionExtractor.ConvertToRuntimeFromIntArray(
                skillActionTable.RootMotionData
            );
            
            if (actionInfo.RootMotionData != null)
            {
                ASLogger.Instance.Debug($"[ActionConfigManager] Loaded root motion data for action {actionId}: " +
                                        $"{actionInfo.RootMotionData.TotalFrames} frames");
            }
        }
        catch (Exception ex)
        {
            ASLogger.Instance.Warning($"[ActionConfigManager] Failed to parse root motion data for action {actionId}: {ex.Message}");
            actionInfo.RootMotionData = null;
        }
    }
    
    return actionInfo;
}
```

## 4. 使用流程

### 4.1 编辑器端流程

1. **打开技能动作编辑器**
2. **选择技能动作并加载动画**
   - 编辑器自动提取 Root Motion 数据
   - 在预览窗口显示网格（已实现）
   - 可以在时间轴上观察位移轨迹
3. **保存技能动作数据**
   - Root Motion 数据序列化为整型数组（`List<int>`）
   - 存储到 `SkillActionTable` 的 `rootMotionData` 字段（Luban 类型：`array,int#sep=,`）
   - Luban 会自动将数组转换为 CSV 单元格中的逗号分隔字符串

### 4.2 运行时流程

1. **动作开始执行**
   - 从配置加载动作信息（包含 Root Motion 数据）
   - `SkillDisplacementCapability` 自动检测到技能动作有位移数据
   
2. **每帧更新**（由 `SkillDisplacementCapability` 自动处理）
   - 检查当前动作是否为技能动作（`SkillActionInfo`）
   - 检查是否有根节点位移数据（`RootMotionData`）
   - 根据当前动作帧索引，读取对应的位移数据
   - 应用增量位移和旋转到实体的 `TransComponent`
   
3. **动作结束**
   - `SkillDisplacementCapability` 自动停止应用位移（检测到动作切换）
   - 最终位置保留在 `TransComponent` 中

## 5. 注意事项

### 5.1 位移方向处理

- **局部空间 vs 世界空间**：动画中的位移通常是局部空间的（相对于角色朝向）
- **朝向转换**：应用位移时需要根据角色的当前朝向转换到世界空间
- **旋转同步**：如果动画包含旋转，需要考虑旋转对位移方向的影响

### 5.2 性能考虑

- **数据大小**：每个动作可能包含几十到上百帧的位移数据，需要评估内存占用
- **采样精度**：20fps 的采样频率足够大多数动作使用，特殊动作可能需要更高精度
- **压缩优化**：可以考虑只存储非零帧的数据，或使用差值压缩

### 5.3 兼容性

- **无 Root Motion 动画**：对于没有 Root Motion 的动画，系统应优雅降级
- **旧数据兼容**：需要处理旧版本没有 Root Motion 数据的动作配置
- **编辑器预览**：预览时关闭 Root Motion（已有实现），使用提取的数据进行可视化

## 6. 后续优化方向

### 6.1 可视化增强

- **位移轨迹绘制**：在编辑器预览窗口中绘制位移轨迹线
- **网格对齐**：结合已实现的网格，显示位移与网格的对齐关系
- **速度曲线**：显示每帧的移动速度变化

### 6.2 编辑功能

- **手动调整**：允许手动编辑某些帧的位移数据
- **曲线编辑**：提供可视化曲线编辑器，调整位移曲线
- **碰撞检测**：在编辑器中检测位移路径是否与障碍物碰撞

### 6.3 运行时增强

- **插值处理**：支持帧间插值，平滑位移
- **速度限制**：添加速度上限，防止异常位移
- **物理交互**：与物理系统集成，处理位移过程中的碰撞

## 7. 相关文件

### 7.1 编辑器文件

- `AnimationRootMotionExtractor.cs` - 根节点位移提取服务（待创建）
- `SkillActionEditorWindow.cs` - 技能动作编辑器窗口（需修改）
- `SkillActionEditorData.cs` - 技能动作数据模型（需扩展）

### 7.2 运行时文件

- `AnimationRootMotionData.cs` - 运行时位移数据结构（待创建）
- `ActionConfigManager.cs` - 动作配置管理器（需修改，加载 RootMotionData）
- `SkillDisplacementCapability.cs` - 技能位移能力（待创建，负责应用位移）
  - 参考：[SkillDisplacementCapability 技能位移能力](../02-CombatSystem%20战斗系统/移动-位移/SkillDisplacementCapability%20技能位移能力.md)

### 7.3 配置表

- `SkillActionTable` - 技能动作配置表（需添加 `rootMotionData` 字段）
  - **字段名**: `rootMotionData`
  - **Luban 类型**: `array,int#sep=,`
  - **运行时类型**: `List<int>`（Luban 自动解析）
  - **编辑器类型**: `List<int>`（SkillActionTableData）
  - **CSV 格式**: 单元格中存储逗号分隔的整数字符串，如 `"60,0,0,0,0,0,0,1000,..."`
  - **写入方式**: `SkillActionDataWriter` 会将 `List<int>` 自动转换为 CSV 字符串格式
  - **读取方式**: Luban 自动将 CSV 字符串解析回 `List<int>`

## 8. 存储格式说明

### 8.1 整型存储优势

**为什么使用整型（*1000）而不是浮点数？**

1. **便于定点数转换**：
   - 运行时使用 TrueSync 定点数（`FP`），整型直接除以 1000 即可转换
   - 避免浮点数到定点数的精度损失和性能开销

2. **存储空间更小**：
   - 整型数字字符串比浮点数更紧凑（如 `50` vs `0.0500`）
   - 60 帧数据：浮点格式 ~1KB，整型格式 ~0.6KB

3. **解析速度快**：
   - `int.TryParse()` 比 `float.TryParse()` 更快
   - 无需处理小数点格式和精度问题

4. **精度保证**：
   - 毫米级精度（0.001 米）对于游戏位移足够
   - 1000 倍缩放可以表示 ±2,147,483.647 米的范围（远超游戏需求）

### 8.2 旋转数据说明

**为什么包含旋转数据？**

1. **特殊技能需求**：
   - 翻滚、旋转攻击等技能需要根节点旋转
   - 某些技能可能有旋转连击效果

2. **完整性**：
   - 与 Unity Root Motion 行为一致，完整保留动画信息
   - 即使大多数技能不使用旋转，也保留数据便于后续扩展

3. **存储开销**：
   - 每帧增加 4 个整数（rx, ry, rz, rw）
   - 60 帧动画增加约 240 字节（可接受）

**如果不需要旋转**：
- 大多数情况下，四元数值为 `(0, 0, 0, 1000)` 表示 `(0, 0, 0, 1)` 即无旋转
- 运行时可以通过检查 `DeltaRotation != TSQuaternion.identity` 来跳过旋转应用

---

*文档版本：v1.3*  
*创建时间：2025-01-16*  
*更新时间：2025-01-16*  
*状态：方案设计完成，待实现*

**更新日志**：
- v1.3 (2025-01-16)：
  - 改用 Luban 数组格式：`rootMotionData` 字段类型从 `string` 改为 `array,int#sep=,`
  - 运行时类型为 `List<int>`，Luban 自动解析，无需手动字符串解析
  - 新增 `SerializeToIntArray()` 方法，返回 `List<int>`
  - 新增 `ConvertToRuntimeFromIntArray()` 方法，直接使用数组转换（推荐）
  - 保留字符串方法作为兼容方案
  - 更新所有相关代码示例和配置说明
- v1.2 (2025-01-16)：
  - 更新位移应用逻辑：改为使用独立的 `SkillDisplacementCapability`
  - 移除旧的手动位移应用代码示例，改为引用新的 Capability
  - 更新运行时流程说明，强调自动处理和职责分离
  - 更新相关文件列表，添加 `SkillDisplacementCapability` 引用
- v1.1 (2025-01-16)：
  - 改用整型存储（浮点数 * 1000），便于运行时转换为定点数
  - 增加旋转数据（四元数）存储，每帧包含完整的 DeltaRotation
  - 优化运行时转换流程，直接从整型转定点数，避免中间浮点数转换
  - 更新存储格式说明和优势分析
- v1.0 (2025-01-16)：初始版本，基于 JSON 格式的位移数据存储方案
