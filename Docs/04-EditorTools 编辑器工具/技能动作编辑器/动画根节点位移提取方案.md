# 动画根节点位移提取方案

## 1. 方案概述

本方案旨在在技能动作编辑器中加载动画时，自动提取动画的根节点位移（Root Motion）数据，并将其转换成适合运行时使用的数据结构，用于技能动作执行过程中的位移逻辑。

### 1.1 目标

- **编辑器端**：在加载动画时提取 Root Motion 数据，存储为每帧的位置和旋转信息
- **运行时**：根据当前动作帧索引，读取对应的位移数据，应用到逻辑层的实体位置
- **数据格式**：使用定点数（TrueSync）兼容的位置和旋转，支持帧同步

### 1.2 应用场景

- 技能动作的前冲、后跳等位移效果
- 动作过程中的轨迹编辑和可视化
- 位移动画在网格上的精确观察（已实现网格显示）

## 2. 技术方案

### 2.1 Root Motion 提取原理

Unity 的 `AnimationClip` 可以包含根节点的位移和旋转信息。通过以下方式提取：

1. **检查是否有 Root Motion 曲线**
   - 使用 `AnimationClip.hasRootMotion` 判断
   - 检查根节点的 `localPosition` 和 `localRotation` 曲线

2. **按帧采样动画数据**
   - 游戏逻辑帧率：20fps（50ms/帧）
   - 对动画进行逐帧采样，获取每帧的位移和旋转

3. **转换为相对位移**
   - 第一帧作为起始参考点（位置=0,旋转=identity）
   - 后续每帧记录相对于起始位置的累积位移

### 2.2 数据结构设计

#### 2.2.1 编辑器端数据结构

```csharp
/// <summary>
/// 动画根节点位移数据（编辑器端，使用浮点数）
/// </summary>
[Serializable]
public class AnimationRootMotionData
{
    /// <summary>
    /// 每帧的位移数据
    /// </summary>
    public List<RootMotionFrameData> Frames = new List<RootMotionFrameData>();
    
    /// <summary>
    /// 动画总帧数（逻辑帧）
    /// </summary>
    public int TotalFrames;
    
    /// <summary>
    /// 是否有有效的位移数据
    /// </summary>
    public bool HasMotion => Frames != null && Frames.Count > 0;
}

/// <summary>
/// 单帧位移数据（编辑器端）
/// </summary>
[Serializable]
public class RootMotionFrameData
{
    /// <summary>
    /// 帧索引（从0开始）
    /// </summary>
    public int FrameIndex;
    
    /// <summary>
    /// 相对位置（相对于起始位置的累积位移）
    /// </summary>
    public Vector3 RelativePosition;
    
    /// <summary>
    /// 相对旋转（相对于起始旋转的累积旋转）
    /// </summary>
    public Quaternion RelativeRotation;
    
    /// <summary>
    /// 相对于上一帧的增量位置
    /// </summary>
    public Vector3 DeltaPosition;
    
    /// <summary>
    /// 相对于上一帧的增量旋转
    /// </summary>
    public Quaternion DeltaRotation;
}
```

#### 2.2.2 运行时数据结构

```csharp
/// <summary>
/// 动画根节点位移数据（运行时，使用定点数）
/// </summary>
[MemoryPackable]
public partial class AnimationRootMotionData
{
    /// <summary>
    /// 每帧的位移数据
    /// </summary>
    public List<RootMotionFrameData> Frames = new List<RootMotionFrameData>();
    
    /// <summary>
    /// 动画总帧数（逻辑帧）
    /// </summary>
    public int TotalFrames;
}

/// <summary>
/// 单帧位移数据（运行时，使用定点数）
/// </summary>
[MemoryPackable]
public partial class RootMotionFrameData
{
    /// <summary>
    /// 帧索引（从0开始）
    /// </summary>
    public int FrameIndex;
    
    /// <summary>
    /// 相对位置（TrueSync 定点数）
    /// </summary>
    public TSVector RelativePosition;
    
    /// <summary>
    /// 相对旋转（TrueSync 定点数）
    /// </summary>
    public TSQuaternion RelativeRotation;
    
    /// <summary>
    /// 相对于上一帧的增量位置（TrueSync 定点数）
    /// </summary>
    public TSVector DeltaPosition;
    
    /// <summary>
    /// 相对于上一帧的增量旋转（TrueSync 定点数）
    /// </summary>
    public TSQuaternion DeltaRotation;
}
```

### 2.3 存储格式设计

#### 2.3.1 CSV 存储格式

在 `SkillActionTable` 中新增字段：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `root_motion_data` | string | JSON 格式的根节点位移数据（可选） |

**数据格式示例**：
```json
{
  "totalFrames": 60,
  "frames": [
    {
      "frameIndex": 0,
      "relativePosition": {"x": 0, "y": 0, "z": 0},
      "relativeRotation": {"x": 0, "y": 0, "z": 0, "w": 1},
      "deltaPosition": {"x": 0, "y": 0, "z": 0},
      "deltaRotation": {"x": 0, "y": 0, "z": 0, "w": 1}
    },
    {
      "frameIndex": 1,
      "relativePosition": {"x": 0.05, "y": 0, "z": 0},
      "relativeRotation": {"x": 0, "y": 0, "z": 0, "w": 1},
      "deltaPosition": {"x": 0.05, "y": 0, "z": 0},
      "deltaRotation": {"x": 0, "y": 0, "z": 0, "w": 1}
    }
  ]
}
```

#### 2.3.2 编辑器数据模型扩展

在 `SkillActionEditorData` 中添加：

```csharp
[TitleGroup("动画位移")]
[LabelText("根节点位移数据")]
[InfoBox("从动画文件自动提取，用于运行时位移逻辑", InfoMessageType.Info)]
[HideInInspector]
public AnimationRootMotionData RootMotionData;
```

## 3. 实现方案

### 3.1 编辑器端实现

#### 3.1.1 Root Motion 提取服务

创建 `AnimationRootMotionExtractor.cs`：

```csharp
using UnityEngine;
using UnityEditor;

namespace Astrum.Editor.RoleEditor.Services
{
    /// <summary>
    /// 动画根节点位移提取服务
    /// </summary>
    public static class AnimationRootMotionExtractor
    {
        private const float LOGIC_FRAME_RATE = 20f;  // 游戏逻辑帧率：20fps
        private const float FRAME_TIME = 0.05f;      // 每帧时间：50ms
        
        /// <summary>
        /// 从动画片段提取根节点位移数据
        /// </summary>
        /// <param name="clip">动画片段</param>
        /// <returns>根节点位移数据，如果动画没有Root Motion则返回null</returns>
        public static AnimationRootMotionData ExtractRootMotion(AnimationClip clip)
        {
            if (clip == null)
            {
                Debug.LogWarning("[AnimationRootMotionExtractor] AnimationClip is null");
                return null;
            }
            
            // 检查是否有Root Motion
            if (!clip.hasRootMotion)
            {
                Debug.Log($"[AnimationRootMotionExtractor] Animation {clip.name} has no root motion");
                return null;
            }
            
            var motionData = new AnimationRootMotionData();
            
            // 计算总帧数
            int totalFrames = Mathf.RoundToInt(clip.length * LOGIC_FRAME_RATE);
            motionData.TotalFrames = totalFrames;
            
            // 创建临时GameObject用于采样动画
            GameObject tempGO = new GameObject("TempRootMotionSampler");
            tempGO.hideFlags = HideFlags.HideAndDontSave;
            
            // 添加Animation组件
            Animation anim = tempGO.AddComponent<Animation>();
            anim.AddClip(clip, "RootMotionSample");
            anim.clip = clip;
            
            // 获取起始位置和旋转（第0帧）
            anim["RootMotionSample"].time = 0f;
            anim.Sample();
            Vector3 startPosition = tempGO.transform.localPosition;
            Quaternion startRotation = tempGO.transform.localRotation;
            
            // 逐帧采样
            for (int frame = 0; frame < totalFrames; frame++)
            {
                float time = frame * FRAME_TIME;
                
                // 采样动画到指定时间
                anim["RootMotionSample"].time = time;
                anim.Sample();
                
                Vector3 currentPosition = tempGO.transform.localPosition;
                Quaternion currentRotation = tempGO.transform.localRotation;
                
                // 计算相对位置和旋转
                Vector3 relativePosition = currentPosition - startPosition;
                Quaternion relativeRotation = currentRotation * Quaternion.Inverse(startRotation);
                
                // 计算增量位移（相对于上一帧）
                Vector3 deltaPosition = Vector3.zero;
                Quaternion deltaRotation = Quaternion.identity;
                
                if (frame > 0)
                {
                    float prevTime = (frame - 1) * FRAME_TIME;
                    anim["RootMotionSample"].time = prevTime;
                    anim.Sample();
                    
                    Vector3 prevPosition = tempGO.transform.localPosition;
                    Quaternion prevRotation = tempGO.transform.localRotation;
                    
                    deltaPosition = currentPosition - prevPosition;
                    deltaRotation = currentRotation * Quaternion.Inverse(prevRotation);
                }
                
                // 添加到帧数据列表
                motionData.Frames.Add(new RootMotionFrameData
                {
                    FrameIndex = frame,
                    RelativePosition = relativePosition,
                    RelativeRotation = relativeRotation,
                    DeltaPosition = deltaPosition,
                    DeltaRotation = deltaRotation
                });
            }
            
            // 清理临时对象
            Object.DestroyImmediate(tempGO);
            
            Debug.Log($"[AnimationRootMotionExtractor] Extracted root motion for {clip.name}: {totalFrames} frames");
            
            return motionData;
        }
        
        /// <summary>
        /// 将编辑器端数据转换为运行时数据（浮点数转定点数）
        /// </summary>
        public static Runtime.AnimationRootMotionData ConvertToRuntime(
            AnimationRootMotionData editorData)
        {
            if (editorData == null || !editorData.HasMotion)
                return null;
            
            var runtimeData = new Runtime.AnimationRootMotionData
            {
                TotalFrames = editorData.TotalFrames
            };
            
            foreach (var frame in editorData.Frames)
            {
                runtimeData.Frames.Add(new Runtime.RootMotionFrameData
                {
                    FrameIndex = frame.FrameIndex,
                    RelativePosition = new TSVector(
                        (FP)frame.RelativePosition.x,
                        (FP)frame.RelativePosition.y,
                        (FP)frame.RelativePosition.z
                    ),
                    RelativeRotation = new TSQuaternion(
                        (FP)frame.RelativeRotation.x,
                        (FP)frame.RelativeRotation.y,
                        (FP)frame.RelativeRotation.z,
                        (FP)frame.RelativeRotation.w
                    ),
                    DeltaPosition = new TSVector(
                        (FP)frame.DeltaPosition.x,
                        (FP)frame.DeltaPosition.y,
                        (FP)frame.DeltaPosition.z
                    ),
                    DeltaRotation = new TSQuaternion(
                        (FP)frame.DeltaRotation.x,
                        (FP)frame.DeltaRotation.y,
                        (FP)frame.DeltaRotation.z,
                        (FP)frame.DeltaRotation.w
                    )
                });
            }
            
            return runtimeData;
        }
    }
}
```

#### 3.1.2 在编辑器窗口集成

在 `SkillActionEditorWindow.cs` 的 `LoadAnimationForAction` 方法中添加：

```csharp
private void LoadAnimationForAction(SkillActionEditorData action)
{
    if (action == null || _previewModule == null)
        return;
    
    if (string.IsNullOrEmpty(action.AnimationPath))
    {
        Debug.LogWarning($"[SkillActionEditor] No animation path for action {action.ActionId}");
        _previewModule.Stop();
        return;
    }
    
    // 加载动画片段
    AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(action.AnimationPath);
    _previewModule.LoadAnimationFromPath(action.AnimationPath);
    
    // 提取根节点位移数据
    if (clip != null)
    {
        action.RootMotionData = AnimationRootMotionExtractor.ExtractRootMotion(clip);
        
        if (action.RootMotionData != null && action.RootMotionData.HasMotion)
        {
            Debug.Log($"[SkillActionEditor] Extracted root motion for action {action.ActionId}: " +
                      $"{action.RootMotionData.TotalFrames} frames");
        }
    }
    
    // 计算动画总帧数
    int animationTotalFrames = _previewModule.GetTotalFrames();
    
    if (animationTotalFrames > 0)
    {
        action.AnimationDuration = animationTotalFrames;
        
        if (action.Duration <= 0 || action.Duration > animationTotalFrames)
        {
            action.Duration = animationTotalFrames;
        }
        
        _timelineModule.SetFrameRange(animationTotalFrames, action.Duration);
    }
}
```

### 3.2 运行时实现

#### 3.2.1 位移应用逻辑

在 `SkillExecutorCapability` 或专门的位移能力中添加：

```csharp
/// <summary>
/// 应用动画根节点位移
/// </summary>
/// <param name="entity">实体</param>
/// <param name="actionId">动作ID</param>
/// <param name="currentFrame">当前帧索引</param>
private void ApplyRootMotion(Entity entity, int actionId, int currentFrame)
{
    // 从配置获取根节点位移数据
    var actionConfig = ActionConfigManager.Instance.GetAction(actionId, entity.Id);
    if (actionConfig?.RootMotionData == null || 
        !actionConfig.RootMotionData.HasMotion)
    {
        return;
    }
    
    // 检查帧索引有效性
    if (currentFrame < 0 || 
        currentFrame >= actionConfig.RootMotionData.Frames.Count)
    {
        return;
    }
    
    // 获取当前帧的位移数据
    var frameData = actionConfig.RootMotionData.Frames[currentFrame];
    
    // 获取实体的变换组件
    var transComponent = entity.GetComponent<TransComponent>();
    if (transComponent == null)
    {
        return;
    }
    
    // 应用增量位移（使用DeltaPosition，逐帧累积）
    // 注意：需要根据动作的初始朝向调整位移方向
    TSVector worldDeltaPosition = TransformDeltaToWorld(
        frameData.DeltaPosition, 
        transComponent.Rotation
    );
    
    transComponent.Position = transComponent.Position + worldDeltaPosition;
    
    // 可选：应用旋转（如果需要）
    // transComponent.Rotation = transComponent.Rotation * frameData.DeltaRotation;
}

/// <summary>
/// 将局部空间的增量位移转换为世界空间
/// </summary>
private TSVector TransformDeltaToWorld(TSVector localDelta, TSQuaternion rotation)
{
    // 将局部位移旋转到世界空间
    return TSQuaternion.op_Multiply(rotation, localDelta);
}
```

#### 3.2.2 配置加载

在 `ActionConfigManager` 中添加根节点位移数据的加载：

```csharp
/// <summary>
/// 获取动作信息（包含根节点位移数据）
/// </summary>
public ActionInfo GetAction(int actionId, int entityId)
{
    // ... 现有代码 ...
    
    // 加载根节点位移数据（如果存在）
    if (tableData.RootMotionData != null && 
        !string.IsNullOrEmpty(tableData.RootMotionData))
    {
        try
        {
            actionInfo.RootMotionData = JsonUtility.FromJson<AnimationRootMotionData>(
                tableData.RootMotionData
            );
        }
        catch (Exception ex)
        {
            Debug.LogWarning($"[ActionConfigManager] Failed to parse root motion data: {ex.Message}");
        }
    }
    
    return actionInfo;
}
```

## 4. 使用流程

### 4.1 编辑器端流程

1. **打开技能动作编辑器**
2. **选择技能动作并加载动画**
   - 编辑器自动提取 Root Motion 数据
   - 在预览窗口显示网格（已实现）
   - 可以在时间轴上观察位移轨迹
3. **保存技能动作数据**
   - Root Motion 数据序列化为 JSON 字符串
   - 存储到 `SkillActionTable` 的 `root_motion_data` 字段

### 4.2 运行时流程

1. **动作开始执行**
   - 从配置加载动作信息（包含 Root Motion 数据）
   - 初始化位移累积变量（初始位置）
2. **每帧更新**
   - 根据当前动作帧索引，读取对应的位移数据
   - 应用增量位移到实体的 `TransComponent`
3. **动作结束**
   - 清理位移状态
   - 可选择是否保留最终位置

## 5. 注意事项

### 5.1 位移方向处理

- **局部空间 vs 世界空间**：动画中的位移通常是局部空间的（相对于角色朝向）
- **朝向转换**：应用位移时需要根据角色的当前朝向转换到世界空间
- **旋转同步**：如果动画包含旋转，需要考虑旋转对位移方向的影响

### 5.2 性能考虑

- **数据大小**：每个动作可能包含几十到上百帧的位移数据，需要评估内存占用
- **采样精度**：20fps 的采样频率足够大多数动作使用，特殊动作可能需要更高精度
- **压缩优化**：可以考虑只存储非零帧的数据，或使用差值压缩

### 5.3 兼容性

- **无 Root Motion 动画**：对于没有 Root Motion 的动画，系统应优雅降级
- **旧数据兼容**：需要处理旧版本没有 Root Motion 数据的动作配置
- **编辑器预览**：预览时关闭 Root Motion（已有实现），使用提取的数据进行可视化

## 6. 后续优化方向

### 6.1 可视化增强

- **位移轨迹绘制**：在编辑器预览窗口中绘制位移轨迹线
- **网格对齐**：结合已实现的网格，显示位移与网格的对齐关系
- **速度曲线**：显示每帧的移动速度变化

### 6.2 编辑功能

- **手动调整**：允许手动编辑某些帧的位移数据
- **曲线编辑**：提供可视化曲线编辑器，调整位移曲线
- **碰撞检测**：在编辑器中检测位移路径是否与障碍物碰撞

### 6.3 运行时增强

- **插值处理**：支持帧间插值，平滑位移
- **速度限制**：添加速度上限，防止异常位移
- **物理交互**：与物理系统集成，处理位移过程中的碰撞

## 7. 相关文件

### 7.1 编辑器文件

- `AnimationRootMotionExtractor.cs` - 根节点位移提取服务（待创建）
- `SkillActionEditorWindow.cs` - 技能动作编辑器窗口（需修改）
- `SkillActionEditorData.cs` - 技能动作数据模型（需扩展）

### 7.2 运行时文件

- `AnimationRootMotionData.cs` - 运行时位移数据结构（待创建）
- `ActionConfigManager.cs` - 动作配置管理器（需修改）
- `SkillExecutorCapability.cs` - 技能执行能力（需修改）

### 7.3 配置表

- `SkillActionTable` - 技能动作配置表（需添加 `root_motion_data` 字段）

---

*文档版本：v1.0*  
*创建时间：2025-01-16*  
*状态：方案设计完成，待实现*
